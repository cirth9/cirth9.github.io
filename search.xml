<?xml version="1.0" encoding="utf-8"?>
<search> 
  
  
    
    <entry>
      <title></title>
      <link href="/2023/08/27/Time/"/>
      <url>/2023/08/27/Time/</url>
      
        <content type="html"><![CDATA[<h1 id="Golang时间格式化"><a href="#Golang时间格式化" class="headerlink" title="Golang时间格式化"></a>Golang时间格式化</h1><p>来自于知乎，懒得自己写了。</p><p>Golang时间类型通过自带的 Format 方法进行格式化。</p><p>需要注意的是Go语言中格式化时间模板不是常见的<code>Y-m-d H:M:S</code>而是使用Go语言的诞生时间 <strong>2006-01-02 15:04:05 -0700 MST</strong>。</p><p>为了记忆方便，按照美式时间格式 月日时分秒年 外加时区 排列起来依次是 <strong>01&#x2F;02 03:04:05PM ‘06 -0700</strong>，刚开始使用时需要注意。</p><p>实际项目中，Format 函数中可以自定义时间格式，也可以使用time包中的预定义格式：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> (</span><br><span class="line">   ANSIC       = <span class="string">&quot;Mon Jan _2 15:04:05 2006&quot;</span></span><br><span class="line">   UnixDate    = <span class="string">&quot;Mon Jan _2 15:04:05 MST 2006&quot;</span></span><br><span class="line">   RubyDate    = <span class="string">&quot;Mon Jan 02 15:04:05 -0700 2006&quot;</span></span><br><span class="line">   RFC822      = <span class="string">&quot;02 Jan 06 15:04 MST&quot;</span></span><br><span class="line">   RFC822Z     = <span class="string">&quot;02 Jan 06 15:04 -0700&quot;</span> <span class="comment">// RFC822 with numeric zone</span></span><br><span class="line">   RFC850      = <span class="string">&quot;Monday, 02-Jan-06 15:04:05 MST&quot;</span></span><br><span class="line">   RFC1123     = <span class="string">&quot;Mon, 02 Jan 2006 15:04:05 MST&quot;</span></span><br><span class="line">   RFC1123Z    = <span class="string">&quot;Mon, 02 Jan 2006 15:04:05 -0700&quot;</span> <span class="comment">// RFC1123 with numeric zone</span></span><br><span class="line">   RFC3339     = <span class="string">&quot;2006-01-02T15:04:05Z07:00&quot;</span></span><br><span class="line">   RFC3339Nano = <span class="string">&quot;2006-01-02T15:04:05.999999999Z07:00&quot;</span></span><br><span class="line">   Kitchen     = <span class="string">&quot;3:04PM&quot;</span></span><br><span class="line">   <span class="comment">// Handy time stamps.</span></span><br><span class="line">   Stamp      = <span class="string">&quot;Jan _2 15:04:05&quot;</span></span><br><span class="line">   StampMilli = <span class="string">&quot;Jan _2 15:04:05.000&quot;</span></span><br><span class="line">   StampMicro = <span class="string">&quot;Jan _2 15:04:05.000000&quot;</span></span><br><span class="line">   StampNano  = <span class="string">&quot;Jan _2 15:04:05.000000000&quot;</span></span><br><span class="line">)</span><br></pre></td></tr></table></figure><p>time包中，定义了年、月、日、时、分、秒、周、时区的多种表现形式：</p><ul><li>年：　 06,2006</li><li>月份： 1,01,Jan,January</li><li>日：　 2,02,_2</li><li>时：　 3,03,15,PM,pm,AM,am</li><li>分：　 4,04</li><li>秒：　 5,05</li><li>周几： Mon,Monday</li><li>时区： -07,-0700,Z0700,Z07:00,-07:00,MST</li></ul><p>根据以上提供的数据，我们可以组合成多种格式化模板，示例代码如下：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line"></span><br><span class="line"> currentTime := time.Now()</span><br><span class="line"></span><br><span class="line"> fmt.Println(<span class="string">&quot;当前时间  : &quot;</span>, currentTime)</span><br><span class="line"></span><br><span class="line"> fmt.Println(<span class="string">&quot;当前时间字符串: &quot;</span>, currentTime.String())</span><br><span class="line"></span><br><span class="line"> fmt.Println(<span class="string">&quot;MM-DD-YYYY : &quot;</span>, currentTime.Format(<span class="string">&quot;01-02-2006&quot;</span>))</span><br><span class="line"></span><br><span class="line"> fmt.Println(<span class="string">&quot;YYYY-MM-DD : &quot;</span>, currentTime.Format(<span class="string">&quot;2006-01-02&quot;</span>))</span><br><span class="line"></span><br><span class="line"> fmt.Println(<span class="string">&quot;YYYY.MM.DD : &quot;</span>, currentTime.Format(<span class="string">&quot;2006.01.02 15:04:05&quot;</span>))</span><br><span class="line"></span><br><span class="line"> fmt.Println(<span class="string">&quot;YYYY#MM#DD &#123;Special Character&#125; : &quot;</span>, currentTime.Format(<span class="string">&quot;2006#01#02&quot;</span>))</span><br><span class="line"></span><br><span class="line"> fmt.Println(<span class="string">&quot;YYYY-MM-DD hh:mm:ss : &quot;</span>, currentTime.Format(<span class="string">&quot;2006-01-02 15:04:05&quot;</span>))</span><br><span class="line"></span><br><span class="line"> fmt.Println(<span class="string">&quot;Time with MicroSeconds: &quot;</span>, currentTime.Format(<span class="string">&quot;2006-01-02 15:04:05.000000&quot;</span>))</span><br><span class="line"></span><br><span class="line"> fmt.Println(<span class="string">&quot;Time with NanoSeconds: &quot;</span>, currentTime.Format(<span class="string">&quot;2006-01-02 15:04:05.000000000&quot;</span>))</span><br><span class="line"></span><br><span class="line"> fmt.Println(<span class="string">&quot;ShortNum Month : &quot;</span>, currentTime.Format(<span class="string">&quot;2006-1-02&quot;</span>))</span><br><span class="line"></span><br><span class="line"> fmt.Println(<span class="string">&quot;LongMonth : &quot;</span>, currentTime.Format(<span class="string">&quot;2006-January-02&quot;</span>))</span><br><span class="line"></span><br><span class="line"> fmt.Println(<span class="string">&quot;ShortMonth : &quot;</span>, currentTime.Format(<span class="string">&quot;2006-Jan-02&quot;</span>))</span><br><span class="line"></span><br><span class="line"> fmt.Println(<span class="string">&quot;ShortYear : &quot;</span>, currentTime.Format(<span class="string">&quot;06-Jan-02&quot;</span>))</span><br><span class="line"></span><br><span class="line"> fmt.Println(<span class="string">&quot;LongWeekDay : &quot;</span>, currentTime.Format(<span class="string">&quot;2006-01-02 15:04:05 Monday&quot;</span>))</span><br><span class="line"></span><br><span class="line"> fmt.Println(<span class="string">&quot;ShortWeek Day : &quot;</span>, currentTime.Format(<span class="string">&quot;2006-01-02 Mon&quot;</span>))</span><br><span class="line"></span><br><span class="line"> fmt.Println(<span class="string">&quot;ShortDay : &quot;</span>, currentTime.Format(<span class="string">&quot;Mon 2006-01-2&quot;</span>))</span><br><span class="line"></span><br><span class="line"> fmt.Println(<span class="string">&quot;Short Hour Minute Second: &quot;</span>, currentTime.Format(<span class="string">&quot;2006-01-02 3:4:5&quot;</span>))</span><br><span class="line"></span><br><span class="line"> fmt.Println(<span class="string">&quot;Short Hour Minute Second: &quot;</span>, currentTime.Format(<span class="string">&quot;2006-01-02 3:4:5 PM&quot;</span>))</span><br><span class="line"></span><br><span class="line"> fmt.Println(<span class="string">&quot;Short Hour Minute Second: &quot;</span>, currentTime.Format(<span class="string">&quot;2006-01-02 3:4:5 pm&quot;</span>))</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>输出结果:</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">当前时间  :  <span class="number">2020</span><span class="number">-06</span><span class="number">-01</span> <span class="number">10</span>:<span class="number">10</span>:<span class="number">46.1551731</span> +<span class="number">0800</span> CST m=+<span class="number">0.002992001</span></span><br><span class="line">当前时间字符串:  <span class="number">2020</span><span class="number">-06</span><span class="number">-01</span> <span class="number">10</span>:<span class="number">10</span>:<span class="number">46.1551731</span> +<span class="number">0800</span> CST m=+<span class="number">0.002992001</span></span><br><span class="line">MM-DD-YYYY :  <span class="number">06</span><span class="number">-01</span><span class="number">-2020</span></span><br><span class="line">YYYY-MM-DD :  <span class="number">2020</span><span class="number">-06</span><span class="number">-01</span></span><br><span class="line">YYYY.MM.DD :  <span class="number">2020.06</span><span class="number">.01</span> <span class="number">10</span>:<span class="number">10</span>:<span class="number">46</span></span><br><span class="line">YYYY#MM#DD &#123;Special Character&#125; :  <span class="number">2020</span>#<span class="number">06</span>#<span class="number">01</span></span><br><span class="line">YYYY-MM-DD hh:mm:ss :  <span class="number">2020</span><span class="number">-06</span><span class="number">-01</span> <span class="number">10</span>:<span class="number">10</span>:<span class="number">46</span></span><br><span class="line">Time with MicroSeconds:  <span class="number">2020</span><span class="number">-06</span><span class="number">-01</span> <span class="number">10</span>:<span class="number">10</span>:<span class="number">46.155173</span></span><br><span class="line">Time with NanoSeconds:  <span class="number">2020</span><span class="number">-06</span><span class="number">-01</span> <span class="number">10</span>:<span class="number">10</span>:<span class="number">46.155173100</span></span><br><span class="line">ShortNum Month :  <span class="number">2020</span><span class="number">-6</span><span class="number">-01</span></span><br><span class="line">LongMonth :  <span class="number">2020</span>-June<span class="number">-01</span></span><br><span class="line">ShortMonth :  <span class="number">2020</span>-Jun<span class="number">-01</span></span><br><span class="line">ShortYear :  <span class="number">20</span>-Jun<span class="number">-01</span></span><br><span class="line">LongWeekDay :  <span class="number">2020</span><span class="number">-06</span><span class="number">-01</span> <span class="number">10</span>:<span class="number">10</span>:<span class="number">46</span> Monday</span><br><span class="line">ShortWeek Day :  <span class="number">2020</span><span class="number">-06</span><span class="number">-01</span> Mon</span><br><span class="line">ShortDay :  Mon <span class="number">2020</span><span class="number">-06</span><span class="number">-1</span></span><br><span class="line">Short Hour Minute Second:  <span class="number">2020</span><span class="number">-06</span><span class="number">-01</span> <span class="number">10</span>:<span class="number">10</span>:<span class="number">46</span></span><br><span class="line">Short Hour Minute Second:  <span class="number">2020</span><span class="number">-06</span><span class="number">-01</span> <span class="number">10</span>:<span class="number">10</span>:<span class="number">46</span> AM</span><br><span class="line">Short Hour Minute Second:  <span class="number">2020</span><span class="number">-06</span><span class="number">-01</span> <span class="number">10</span>:<span class="number">10</span>:<span class="number">46</span> am</span><br></pre></td></tr></table></figure>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title></title>
      <link href="/2023/08/22/%E4%B8%9A%E5%8A%A1%E9%80%BB%E8%BE%91/"/>
      <url>/2023/08/22/%E4%B8%9A%E5%8A%A1%E9%80%BB%E8%BE%91/</url>
      
        <content type="html"><![CDATA[<h2 id="Session"><a href="#Session" class="headerlink" title="Session"></a>Session</h2><p>session在网络应用中称为“会话控制”，是服务器为了保存用户状态而创建的一个特殊的对象。简而言之，session就是一个对象，用于存储信息。 </p><h3 id="基于Session登录"><a href="#基于Session登录" class="headerlink" title="基于Session登录"></a>基于Session登录</h3><p><img src="/2023/08/22/%E4%B8%9A%E5%8A%A1%E9%80%BB%E8%BE%91/Session.png" alt="image-20230822164536066"></p><h3 id="登录验证功能"><a href="#登录验证功能" class="headerlink" title="登录验证功能"></a>登录验证功能</h3><p><img src="/2023/08/22/%E4%B8%9A%E5%8A%A1%E9%80%BB%E8%BE%91/Session1.png" alt="image-20230822164536066"></p><h3 id="集群的session共享问题"><a href="#集群的session共享问题" class="headerlink" title="集群的session共享问题"></a>集群的session共享问题</h3><p><code>tomcat</code>: Tomcat是常见的免费的web服务器。 简单而言就是，你写的页面只能自己访问，<strong>别人不能远程访问你写的页面</strong>，Tomcat就是<strong>提供能够让别人访问自己写的页面的一个程序</strong></p><p><code>nginx</code>: nginx是由俄罗斯人发明的一款高性能的web服务器，它同早期的Apache，IIS，Lighttpd等都具有web服务器的功能，能够发布网站代码等资源，为用户提供信息资讯。但是nginx的功能不单单只是做为web服务器，它还可以用来做反向代理和负载均衡服务器，并且整体性能非常强大，在web前端服务器目前是企业的首选。</p><p><img src="/2023/08/22/%E4%B8%9A%E5%8A%A1%E9%80%BB%E8%BE%91/%E9%9B%86%E7%BE%A4session%E5%85%B1%E4%BA%AB%E9%97%AE%E9%A2%98.png" alt="image"></p><p>此问题主要在于，如果基于session实现登录功能，客户端发送登录后发送携带session文件的信息给nginx，nginx将其负载均衡给tomcat，这就可能会造成对于不同的tomcat服务而言的数据丢失问题，虽然可以通过拷贝，将数据拷贝到所有的tomcat上，但是因为拷贝耗时且耗内存。</p><p>那么，很显然，对于session的替代方案，我们很显然需要满足以下特点：</p><ol><li>数据共享</li><li>内存存储</li><li>k-v结构</li></ol><p>很显然，redis完美满足以上特点。</p><h3 id="基于Redis实现贡献session存储"><a href="#基于Redis实现贡献session存储" class="headerlink" title="基于Redis实现贡献session存储"></a>基于Redis实现贡献session存储</h3><p><img src="/2023/08/22/%E4%B8%9A%E5%8A%A1%E9%80%BB%E8%BE%91/%E5%9F%BA%E4%BA%8ERedis%E5%AE%9E%E7%8E%B0Session%E7%99%BB%E5%BD%95.png" alt="image"></p><p>保存用户的登录信息，我们可以采用String结构，以Json字符串的形式来保存，或者也可以采用Hash结构将对象中的每个字段独立存储。</p><p><img src="/2023/08/22/%E4%B8%9A%E5%8A%A1%E9%80%BB%E8%BE%91/%E5%9F%BA%E4%BA%8ERedis%E5%AE%9E%E7%8E%B0Session%E7%99%BB%E5%BD%952.png" alt="image"></p><p>在上述中，我们使用手机号作为key值进行登录，虽然可以满足功能，但是实际上是不太合适的。</p><p>正确的方式应该是后端校验用户成功之后，将用户保存到redis，并且返回token（令牌，这里的话简单理解成一串加密字符串就好）给前端，保存在对应的浏览器上，下次校验登录状态时，客户端请求并鞋带token，以token作为key获取用户数据，判断用户是否存在，以此判断放行或者是拦截。</p>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title></title>
      <link href="/2023/08/20/%E6%97%A5%E5%BF%97/"/>
      <url>/2023/08/20/%E6%97%A5%E5%BF%97/</url>
      
        <content type="html"><![CDATA[<p>1、当用户在使用某个功能报错时，开发该如何排查问题？2、当出现某个接口返回数据很慢时，该如何优化？</p><p>要想快速的解决已上2个问题，就依赖于日志了。</p><p>日志是开发为了跟踪用户行为和代码异常而打的记录。</p><p>当一个请求到来时，我们一般会登记以下几种日志：</p><p>1、AccessLog：用户访问日志。一般会记录请求URL、请求参数、用户ID、行为发生时间、接口返回值等几个关键指标。</p><p>2、Exception：代码异常。代码异常一般会记录报错信息、报错发生的代码是哪一行、报错发生时间等指标。代码异常日志是最重要也是经常要看的日志，根据报错可以快速定位到发生错误的原因，快速地修复问题。</p><p>3、SqlLog：数据库查询日志。一般会记录SQL查询语句、数据库名表名、查询耗时等指标。</p><p>4、第三方服务日志：调用第三方服务日志。如果后台调用了第三方服务，比如接入了公司内的统一登录服务，当调用该登录服务时，就记录这些行为。</p><p>5、CronLog：定时任务日志。如果后台有定时任务，比如每天凌晨同步某个数据库到另一个仓库，则可以记录下该任务是否成功、成功耗时等。</p><p>上面说的都是后台产生的日志，那么前端有没有错误日志呢？当然是有的，但是前端日志比后台就简单纯粹多了。前端一般只要记录发生错误的日志，上报到日志平台就可以了。</p><p>如果没有用户向你投诉某个功能报错了，开发如何在用户发现错误之前避免这些错误？这时就需要给异常添加监控告警了。</p><p>监控告警一般监控以下这些指标：</p><p>1、流量异常：指的是pv相比于以前，猛然升高。可能存在有人在恶意刷页面</p><p>2、服务崩溃：服务因为某种异常，导致的服务停止，不能正常访问。3、代码异常：代码发生错误。4、数据库查询过慢：可能因为查询人数过多、数据量过大、查询语句有问题导致的查询耗时过长。5、服务占用CPU&#x2F;内存过高：可能因为访问人数过多或者代码有bug导致的内存泄漏&#x2F;CPU占用高。</p>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title></title>
      <link href="/2023/08/18/Untitled/"/>
      <url>/2023/08/18/Untitled/</url>
      
        <content type="html"><![CDATA[]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title></title>
      <link href="/2023/07/29/%E6%B6%88%E6%81%AF%E9%98%9F%E5%88%97/"/>
      <url>/2023/07/29/%E6%B6%88%E6%81%AF%E9%98%9F%E5%88%97/</url>
      
        <content type="html"><![CDATA[<h1 id="消息队列"><a href="#消息队列" class="headerlink" title="消息队列"></a>消息队列</h1>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>存储和数据库</title>
      <link href="/2023/07/25/%E5%AD%98%E5%82%A8%E4%B8%8E%E6%95%B0%E6%8D%AE%E5%BA%93/"/>
      <url>/2023/07/25/%E5%AD%98%E5%82%A8%E4%B8%8E%E6%95%B0%E6%8D%AE%E5%BA%93/</url>
      
        <content type="html"><![CDATA[<p>来源于知乎</p><h1 id="系统存储"><a href="#系统存储" class="headerlink" title="系统存储"></a>系统存储</h1><h2 id="01-块存储"><a href="#01-块存储" class="headerlink" title="01 块存储"></a><strong>01 块存储</strong></h2><h3 id="1-1-概述"><a href="#1-1-概述" class="headerlink" title="1.1 概述"></a><strong>1.1 概述</strong></h3><p>块存储是将裸磁盘空间整个映射给主机使用的，比如磁阵中有3块1T硬盘，可以选择直接将裸设备给操作系统使用（此时识别出3个1T的硬盘），也可以划分经过RAID、逻辑卷等方式划分出多个逻辑的磁盘供系统使用（比如划分为6个500G的磁盘），主机层面操作系统识别出硬盘，但是操作系统无法区分这些映射上来的磁盘到底是真正的物理磁盘还是二次划分的逻辑磁盘，操作系统接着对磁盘进行分区、格式化，与我们服务器内置的硬盘没有什么差异。</p><p>块存储不仅仅是直接使用物理设备，间接使用物理设备的也叫块设备，比如虚机创建虚拟磁盘。VMware、VirtualBox都可以创建虚拟磁盘，虚机创建的磁盘格式包括raw、qcow2等，这与主机使用的裸设备不一样，且有不同的应用场景。</p><h3 id="1-2-特点"><a href="#1-2-特点" class="headerlink" title="1.2 特点"></a><strong>1.2 特点</strong></h3><p><strong>优点</strong></p><p>1、通过RAID与LVM等手段，对数据提供了保护（RAID可实现磁盘的备份和校验，LVM可以做快照）；</p><p>2、RAID将多块廉价的硬盘组合起来，构建大容量的逻辑盘对外提供服务，性价比高；</p><p>3、写数据时，由于是多块磁盘组合成的逻辑盘，可以并行写入，提升了读写效率；</p><p>4、很多时候块存储采用SAN架构组网，传输速率以及封装协议的原因，使得传输速度与读写速率得到提升。</p><p><strong>缺点</strong></p><p>1、采用SAN架构组网时，需要额外为主机购买光纤通道卡，还要买光纤交换机，造价成本高；</p><p>2、不利于不同操作系统主机间的数据共享，因为操作系统使用不同的文件系统，格式化完成后，不同文件系统间的数据是无法共享的。</p><h3 id="1-3-典型设备"><a href="#1-3-典型设备" class="headerlink" title="1.3 典型设备"></a><strong>1.3 典型设备</strong></h3><p>磁盘，磁盘阵列</p><h3 id="1-4-应用场景"><a href="#1-4-应用场景" class="headerlink" title="1.4 应用场景"></a><strong>1.4 应用场景</strong></h3><p>一般用于主机的直接存储空间和数据库应用的存储分两种形式：</p><p>DAS：一台服务器一个存储，多机无法直接共享，需要借助操作系统的功能，如共享文件夹；</p><p>SAN：金融电信级别，成本较高，但是可提供高性能和高可靠服务。</p><p>云存储的块存储：具备SAN的优势，成本低，可提供弹性拓容，存储介质可选普通硬盘和SSD。</p><h3 id="1-5-主流技术"><a href="#1-5-主流技术" class="headerlink" title="1.5 主流技术"></a><strong>1.5 主流技术</strong></h3><p>Microsoft：Azure Block Storage</p><p>Google：Google Block Storage</p><p>Amazon：Elastic Block Storag（EBS）</p><p>OpenStack：Cinder</p><p>其他：Ceph RBD、sheepdog</p><h2 id="02-文件存储"><a href="#02-文件存储" class="headerlink" title="02 文件存储"></a><strong>02 文件存储</strong></h2><h3 id="2-1-概述"><a href="#2-1-概述" class="headerlink" title="2.1 概述"></a><strong>2.1 概述</strong></h3><p>为了克服块存储无法共享的问题，所以就有了文件存储。</p><p>文件存储也有软硬一体化的设备，用一台普通服务器&#x2F;笔记本，只要安装上合适的操作系统与软件，就可以对外提供FTP与NFS服务。</p><h3 id="2-2-特点"><a href="#2-2-特点" class="headerlink" title="2.2 特点"></a><strong>2.2 特点</strong></h3><p><strong>优点</strong></p><p>1、造价较低：只需要普通机器和普通网络即可满足需求，不需要专用的SAN网络；</p><p>2、方便文件共享。</p><p><strong>缺点</strong></p><p>1、读写速率低，传输速率慢：以太网，上传下载速度较慢，另外读写操作都分布到单台服务器，与磁阵的并行写相比性能差距较大。</p><h3 id="2-3-典型设备"><a href="#2-3-典型设备" class="headerlink" title="2.3 典型设备"></a><strong>2.3 典型设备</strong></h3><p>FTP、NFS服务器</p><h3 id="2-4-应用场景"><a href="#2-4-应用场景" class="headerlink" title="2.4 应用场景"></a><strong>2.4 应用场景</strong></h3><p>与偏向底层的块存储不同，文件存储上升到了应用层，一般指的是NAS。</p><p>一套网络存储设备，通过TCP&#x2F;IP进行访问，协议为NFSv3&#x2F;v4由于通过网络，且采用上层协议，因此开销大，延时肯定比块存储高，一般用于多个云服务器共享数据，如存放共享文件等。</p><h3 id="2-5-主流技术"><a href="#2-5-主流技术" class="headerlink" title="2.5 主流技术"></a><strong>2.5 主流技术</strong></h3><p>Microsoft；Windows Azure文件共享存储</p><p>Google：Google FileStorage（GFS）</p><p>Amazon：Elastic File Storage(EFS)</p><p>OpenStack：Swift</p><p>其他：CephFS、HDFS、NFS、CIFS、Samba、FTP</p><h2 id="03-对象存储"><a href="#03-对象存储" class="headerlink" title="03 对象存储"></a><strong>03 对象存储</strong></h2><h3 id="3-1-概述"><a href="#3-1-概述" class="headerlink" title="3.1 概述"></a><strong>3.1 概述</strong></h3><p>之所以出现对象存储，是为了克服块存储与文件存储的缺点，发扬他俩各自的优点。简单地说，块存储读写块，不利于共享，文件存储读写慢，利于共享。</p><p><strong>为什么对象存储兼具块存储与文件存储的好处，还要使用块存储或文件存储呢？</strong></p><p>1、有一类应用是需要存储直接裸盘映射的，例如数据库。因为数据库需要存储裸盘映射给自己后，再根据自己的数据库文件系统来对裸盘进行格式化，所以是不能够采用其他已经被格式化为某种文件系统的存储的。数据库更适合使用块存储。</p><p>2、对象存储的成本比普通的文件存储高，需要购买专门的对象存储软件以及大容量硬盘。</p><h3 id="3-2-特点"><a href="#3-2-特点" class="headerlink" title="3.2 特点"></a><strong>3.2 特点</strong></h3><p><strong>优点</strong></p><p>1、结合了块存储与文件存储的优点。</p><p><strong>缺点</strong></p><p>1、数据库等追求高性能的应用更适合采用块存储。</p><p>2、对象存储的成本比普通的文件存储还是较高。</p><h3 id="3-3-典型设备"><a href="#3-3-典型设备" class="headerlink" title="3.3 典型设备"></a><strong>3.3 典型设备</strong></h3><p>内置大容量硬盘的分布式服务器</p><h3 id="3-4-应用场景"><a href="#3-4-应用场景" class="headerlink" title="3.4 应用场景"></a><strong>3.4 应用场景</strong></h3><p>对象具备块存储的高速以及文件存储的共享等特性，有自己的CPU、内存、网络和磁盘，比块存储和文件存储更上层。云服务商一般提供用户文件上传下载读取的REST API，方便应用集成此类服务。</p><h3 id="3-5-主流技术"><a href="#3-5-主流技术" class="headerlink" title="3.5 主流技术"></a><strong>3.5 主流技术</strong></h3><p>Microsoft：Azure Storage</p><p>Google：Google Cloud Storage</p><p>Amazon：Simple Storage Service（S3）</p><p>OpenStack：Swift</p><p>其他：Ceph OSD</p><h2 id="04-对比"><a href="#04-对比" class="headerlink" title="04 对比"></a><strong>04 对比</strong></h2><h3 id="4-1-块存储-vs-文件存储"><a href="#4-1-块存储-vs-文件存储" class="headerlink" title="4.1 块存储 vs 文件存储"></a><strong>4.1 块存储 vs 文件存储</strong></h3><p>物理块与文件系统之间的关系图：映射关系：扇区-&gt;物理块-&gt;逻辑块-&gt;文件系统</p><p>块级备份：块级备份是指物理块复制，效率高，实时性强，备份时间短，且增量备份时，只备份修改过的物理块。</p><p>文件级备份：文件级备份是指在指定某些文件进行备份时，首先会查找每个文件逻辑块，其次物理块，由于逻辑块是分散在物理块上，而物理块也是分散在不同扇区上。需要一层一层往下查找，最后才完成整个文件复制。文件级备份比较费时间，效率不高，实时性不强，备份时间长，且增量备份时，单文件某一小部分修改，不会只备份修改部分，而是整个文件都备份。</p><h3 id="4-2-文件存储-vs-对象存储"><a href="#4-2-文件存储-vs-对象存储" class="headerlink" title="4.2 文件存储 vs 对象存储"></a><strong>4.2 文件存储 vs 对象存储</strong></h3><p><strong>对象存储：</strong></p><p>1、大多数对象存储的实现本质是键值对存储系统；</p><p>2、采用扁平化的管理方式（根据键找到值）；</p><p>3、值可以是任何东西，可以是小文件（小二进制片段），可以是大文件；</p><p>4、对象存储一般不支持追加写和更新，面向的是一次写入，多次读取的需求场景；</p><p>5、多采用Restful API。</p><p><strong>文件存储：</strong></p><p>1、不考虑底层到底是怎么实现的；</p><p>2、采用目录结构管理数据；</p><p>3、一般要尽可能兼容Posix文件系统API。</p>]]></content>
      
      
      <categories>
          
          <category> 数据库和存储 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>JWT-GO</title>
      <link href="/2023/07/03/JWT/"/>
      <url>/2023/07/03/JWT/</url>
      
        <content type="html"><![CDATA[<h3 id="什么是JWT"><a href="#什么是JWT" class="headerlink" title="什么是JWT"></a>什么是JWT</h3><blockquote><p>JSON Web Token (JWT)是一个开放标准(RFC 7519) ，它定义了一种紧凑和自包含的方式，**<code>用于作为 JSON 对象在各方之间安全地传输信息</code>**。此信息可以进行验证和信任，因为它是经过数字签名的。JWT 可以使用机密(使用 HMAC 算法)或使用 RSA 或 ECDSA 的公钥&#x2F;私钥对进行签名。<br>虽然可以对 JWT 进行加密，以便在各方之间提供保密性，但是我们将关注已签名的Token。签名Token可以验证其中包含的声明的完整性，而加密Token可以向其他方隐藏这些声明。当使用公钥&#x2F;私钥对对令牌进行签名时，该签名还证明只有持有私钥的一方才是对其进行签名的一方( <strong><code>签名技术是保证传输的信息不被篡改,并不能保证信息传输的安全</code></strong> )。</p></blockquote><p><em><strong>说人话的话，JWT就是一个是基于<code>JSON</code>格式用于网络传输的令牌，通过这个令牌可以去服务器上获取资源，也可以说是客户端和服务器端安全传输信息的一个标准。</strong></em></p><h3 id="BASE64"><a href="#BASE64" class="headerlink" title="BASE64"></a>BASE64</h3><p>Base64是一种二进制到文本的编码方式。如果要更具体一点的话，可以认为它是一种将 <code>byte</code>数组编码为字符串的方法，而且编码出的字符串只包含ASCII基础字符。</p><p>例如字符串<code>ShuSheng007</code>对应的Base64为<code>U2h1U2hlbmcwMDc=</code>。其中那个<code>=</code>比较特殊，是填充符，这里仅作了解就好，不多做说明。</p><p>值得注意的是Base64不是加密算法，其仅仅是一种编码方式，算法也是公开的，所以不能依赖它进行加密。</p><p>编码和加密的区别：</p><ul><li><p><strong>编码是将一系列字符放入一种特殊格式以进行传输或存储的过程。</strong></p></li><li><p><strong>加密是将数据转换成密码的过程</strong>。</p></li></ul><p>至于为什么这里会提到base64，因为jwt本质上就是一个用base64编码的字符串。</p><h3 id="JWT的结构"><a href="#JWT的结构" class="headerlink" title="JWT的结构"></a>JWT的结构</h3><p>在其紧凑的形式中，JWT由以点(.)分隔的三个部分组成，它们是:</p><ul><li>Header（首部）</li><li>Payload（负载）</li><li>Signature（签名）</li></ul><p>类似于xxxx.xxxx.xxxx格式,真实情况如下:</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">eyJhbGciOiJIUzI1NiIsInR5cCI6IkpXVCJ9.eyJzdWIiOiIxMjM0NTY3ODkwIiwibmFtZSI6IkpvaG4gRG9lIiwiaWF0IjoxNTE2MjM5MDIyfQ.SflKxwRJSMeKKF2QT4fwpMeJf36POk6yJV_adQssw5c</span><br></pre></td></tr></table></figure><p>并且你可以通过官网<a href="https://jwt.io/#debugger-io%E8%A7%A3%E6%9E%90%E5%87%BA%E4%B8%89%E9%83%A8%E5%88%86%E8%A1%A8%E7%A4%BA%E7%9A%84%E4%BF%A1%E6%81%AF">https://jwt.io/#debugger-io解析出三部分表示的信息</a>( <strong><code>可使用 JWT.io Debugger 来解码、验证和生成 JWT</code></strong> ):<br><img src="https://ucc.alicdn.com/images/user-upload-01/98d3fc61aa364cefa3ec866275569377.png" alt="在这里插入图片描述"></p><h4 id="1-Header"><a href="#1-Header" class="headerlink" title="(1) Header"></a>(1) Header</h4><blockquote><p>报头通常由两部分组成: Token的类型(即 JWT)和所使用的签名算法(如 HMAC SHA256或 RSA)。</p></blockquote><p>例如:</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">  &quot;alg&quot;: &quot;HS256&quot;,</span><br><span class="line">  &quot;typ&quot;: &quot;JWT&quot;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>最终这个 JSON 将由base64进行加密（该加密是可以对称解密的)，用于构成 JWT 的第一部分,eyJhbGciOiJIUzI1NiIsInR5cCI6IkpXVCJ9就是base64加密后的结果。</p><p>在<code>JWT</code>规范文件中称这些<code>Header</code>为<code>JOSE Header</code>，<code>JOSE</code>的全称为<code>Javascript Object Signature Encryption</code>，也就是<code>Javascript</code>对象签名和加密框架，<code>JOSE Header</code>其实就是<code>Javascript</code>对象签名和加密的头部参数。**<code>JWS</code>中常用的<code>Header</code>**：</p><table><thead><tr><th align="center">简称</th><th align="center">全称</th><th align="center">含义</th></tr></thead><tbody><tr><td align="center">alg</td><td align="center">Algorithm</td><td align="center">用于保护<code>JWS</code>的加解密算法</td></tr><tr><td align="center">jku</td><td align="center">JWK Set URL</td><td align="center">一组<code>JSON</code>编码的公共密钥的<code>URL</code>，其中一个是用于对<code>JWS</code>进行数字签名的密钥</td></tr><tr><td align="center">jwk</td><td align="center">JSON Web Key</td><td align="center">用于对<code>JWS</code>进行数字签名的密钥相对应的公共密钥</td></tr><tr><td align="center">kid</td><td align="center">Key ID</td><td align="center">用于保护<code>JWS</code>进的密钥</td></tr><tr><td align="center">x5u</td><td align="center">X.509 URL</td><td align="center"><code>X.509</code>相关</td></tr><tr><td align="center">x5c</td><td align="center">X.509 Certificate Chain</td><td align="center"><code>X.509</code>相关</td></tr><tr><td align="center">x5t</td><td align="center">X.509 Certificate SHA-1 Thumbprin</td><td align="center"><code>X.509</code>相关</td></tr><tr><td align="center">x5t#S256</td><td align="center">X.509 Certificate SHA-256 Thumbprint</td><td align="center"><code>X.509</code>相关</td></tr><tr><td align="center">typ</td><td align="center">Type</td><td align="center">类型，例如<code>JWT</code>、<code>JWS</code>或者<code>JWE</code>等等</td></tr><tr><td align="center">cty</td><td align="center">Content Type</td><td align="center">内容类型，决定<code>payload</code>部分的<code>MediaType</code></td></tr></tbody></table><h4 id="2-Payload"><a href="#2-Payload" class="headerlink" title="(2) Payload"></a>(2) Payload</h4><blockquote><p>Token的第二部分是有效负载，其中包含声明。声明是关于实体(通常是用户)和其他数据的语句。有三种类型的声明: registered claims, public claims, and private claims。</p></blockquote><p>例如:</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">  &quot;sub&quot;: &quot;1234567890&quot;,// 注册声明</span><br><span class="line">  &quot;name&quot;: &quot;John Doe&quot;,// 公共声明</span><br><span class="line">  &quot;admin&quot;: true // 私有声明</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这部分的声明也会通过base64进行加密,最终形成JWT的第二部分eyJzdWIiOiIxMjM0NTY3ODkwIiwibmFtZSI6IkpvaG4gRG9lIiwiaWF0IjoxNTE2MjM5MDIyfQ<br><strong>registered claims(注册声明)</strong></p><blockquote><p>这些是一组预定义的声明，它们 <strong><code>不是强制性的，而是推荐的</code></strong> ，以 <strong><code>提供一组有用的、可互操作的声明</code></strong> 。</p></blockquote><p><code>JWT</code>的核心作用就是保护<code>Claims</code>的完整性（或者数据加密），保证<code>JWT</code>传输的过程中<code>Claims</code>不被篡改（或者不被破解）。<code>Claims</code>在<code>JWT</code>原始内容中是一个<code>JSON</code>格式的字符串，其中单个<code>Claim</code>是<code>K-V</code>结构，作为<code>JsonNode</code>中的一个<code>field-value</code>，这里列出常用的规范中预定义好的<code>Claim</code>：</p><table><thead><tr><th align="center">简称</th><th align="center">全称</th><th align="center">含义</th></tr></thead><tbody><tr><td align="center">iss</td><td align="center">Issuer</td><td align="center">发行方</td></tr><tr><td align="center">sub</td><td align="center">Subject</td><td align="center">主体</td></tr><tr><td align="center">aud</td><td align="center">Audience</td><td align="center">（接收）目标方</td></tr><tr><td align="center">exp</td><td align="center">Expiration Time</td><td align="center">过期时间</td></tr><tr><td align="center">nbf</td><td align="center">Not Before</td><td align="center">早于该定义的时间的<code>JWT</code>不能被接受处理</td></tr><tr><td align="center">iat</td><td align="center">Issued At</td><td align="center"><code>JWT</code>发行时的时间戳</td></tr><tr><td align="center">jti</td><td align="center">JWT ID</td><td align="center"><code>JWT</code>的唯一标识</td></tr></tbody></table><p><strong><code>注意:声明名称只有三个字符，因为 JWT 意味着是紧凑的。</code></strong></p><p><strong>Public claims(公共的声明)</strong></p><blockquote><p>使用 JWT 的人可以随意定义这些声明( <strong><code>可以自己声明一些有效信息如用户的id,name等,但是不要设置一些敏感信息,如密码</code></strong> )。但是为了避免冲突，应该在 JWT注册表中定义它们，或者将它们定义为包含抗冲突名称空间的 URI。</p></blockquote><p><strong>Private claims(私人声明)</strong></p><blockquote><p>这些是创建用于在同意使用它们的各方之间共享信息的习惯声明，既不是注册声明，也不是公开声明( <strong><code>私人声明是提供者和消费者所共同定义的声明</code></strong> )。</p></blockquote><p><strong><code>注意:对于已签名的Token，这些信息虽然受到保护，不会被篡改，但任何人都可以阅读。除非加密，否则不要将机密信息放在 JWT 的有效负载或头元素中。</code></strong></p><h4 id="3-Signature"><a href="#3-Signature" class="headerlink" title="(3) Signature"></a>(3) Signature</h4><blockquote><p>要创建Signature，您必须获取编码的标头（header）、编码的有效载荷(payload)、secret、标头中指定的算法，并对其进行签名。</p></blockquote><p>例如，如果您想使用 HMAC SHA256算法，签名将按以下方式创建:</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">HMACSHA256(</span><br><span class="line">  base64UrlEncode(header) + &quot;.&quot; +base64UrlEncode(payload),</span><br><span class="line">  secret</span><br><span class="line">  )</span><br></pre></td></tr></table></figure><p>上面的JSON将会通过HMACSHA256算法结合secret进行加验签名(私钥加密)，其中header和payload将通过base64UrlEncode()方法进行base64加密然后通过字符串拼接 <strong><code>&quot;.&quot;</code></strong> 生成新字符串,最终生成JWT的第三部分SflKxwRJSMeKKF2QT4fwpMeJf36POk6yJV_adQssw5c</p><p><strong><code>注意:secret是保存在服务器端的，jwt的签发生成也是在服务器端的，secret就是用来进行jwt的签发和验证，所以，它就是你服务端的私钥，在任何场景都不应该流露出去。一旦客户端得知这个secret, 那就意味着客户端是可以自我签发jwt了</code></strong></p><h4 id="4-JWT的生成与解析"><a href="#4-JWT的生成与解析" class="headerlink" title="(4) JWT的生成与解析"></a>(4) JWT的生成与解析</h4><blockquote><p>JWT输出是三个由点分隔的 Base64-URL 字符串，这些字符串可以在 HTML 和 HTTP 环境中轻松传递，同时与基于 XML 的标准(如 SAML)相比更加紧凑。</p></blockquote><p>下面显示了一个 JWT，该 JWT 对前一个头和有效负载进行了编码，并使用一个 secret 进行签名。</p><p><img src="https://ucc.alicdn.com/images/user-upload-01/fe7a3884df1443329a1f35b2a7ae838c.png" alt="在这里插入图片描述"></p><p>真实情况,一般是在请求头里加入Authorization，并加上Bearer标注最后是JWT(格式:Authorization: Bearer <strong><code>&lt;token&gt;</code></strong>)：</p><p><img src="https://ucc.alicdn.com/images/user-upload-01/2aa1d619cd3c4dbcbc0c7eb587f678a1.png" alt="在这里插入图片描述"></p><h4 id="5-总结"><a href="#5-总结" class="headerlink" title="(5) 总结"></a>(5) 总结</h4><p>第一部分是header, 是一个json字符串, 描述了自己是什么和生成的算法。这一串字符是经过base64编码后的结果。</p><p>第二部分是 payload, 翻译过来就是负载，简而言之也就是令牌token的内容，其内部的字段是可以自定义的。</p><p>第三部分是签名。所谓签名, 就是对第二部分的payload进行取哈希值。由于哈希函数具有 单向性和 很强的方碰撞性，所以可以防止有人串改第二部分的 payload。</p><p>当接受jwt的一方需要对签名进行验证, 这个过程叫做验签。只有经过验签的jwt才是有效和真实的。</p><p>jwt的签名和验签都需要密钥的参与，要不然谁都可以生成一个 jwt, 服务端无法确认 jwt 的真实性，也就无法使用了。</p><h3 id="应用"><a href="#应用" class="headerlink" title="应用"></a>应用</h3><p>一般是在请求头里加入Authorization，并加上Bearer标注：</p><figure class="highlight php"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="title function_ invoke__">fetch</span>(<span class="string">&#x27;api/user/1&#x27;</span>, &#123;  <span class="attr">headers</span>: &#123;    <span class="string">&#x27;Authorization&#x27;</span>: <span class="string">&#x27;Bearer &#x27;</span> + token  &#125;&#125;)</span><br></pre></td></tr></table></figure><p>服务端会验证token，如果验证通过就会返回相应的资源。</p><h3 id="常见的签名和验签-算法"><a href="#常见的签名和验签-算法" class="headerlink" title="常见的签名和验签 算法"></a>常见的签名和验签 算法</h3><h4 id="对称式签名（验签）"><a href="#对称式签名（验签）" class="headerlink" title="对称式签名（验签）"></a>对称式签名（验签）</h4><p>对称式最常见的当属 HS256。简单来说, 签名过程 就是对 header,payload和密钥的拼接 进行一次取SHA256哈希值, 作为 jwt 的第三部分。 用公式来写, 就是这样:</p><p>$signedString&#x3D;SHA256(header+payload+key)$</p><p>验签过程需要拿到 密钥 key(提前约定好的), 根据 header 和 payload  计算SHA256哈希值，如果和 jwt 的第三部分一致, 说明 jwt 真实, 否则说明 jwt 被篡改。</p><h4 id="非对称式签名-验签"><a href="#非对称式签名-验签" class="headerlink" title="非对称式签名(验签)"></a>非对称式签名(验签)</h4><p>非对称式最常见的当属 RS256。简单来说, 就是对  header 和 payload  计算SHA256哈希值, 随后对这个哈希值使用私钥进行加密。 用公式来写就是这样:</p><p>$signedString&#x3D;SHA256(header+payload)$</p><p>$cipherText&#x3D;RSAencrypt(signedString,privateKey)$</p><p>验签的时候使用公钥解密出 signedString, 再根据 header 和 payload  计算SHA256哈希值,  随后对这个哈希值和 jwt的部分进行比对。如果和 jwt 的第三部分一致, 说明 jwt 真实, 否则说明 jwt 被篡改。</p><h4 id="HS256-与-RS256-区别"><a href="#HS256-与-RS256-区别" class="headerlink" title="HS256 与 RS256 区别"></a>HS256 与 RS256 区别</h4><p>HS256 需要双方严格保管密钥, 如果有一方泄露了密钥, 那么就可以伪造出 jwt. 而 RS256 签名的时候使用私钥, 验签的时候使用公钥，只要私钥不泄露, 那么jwt是不能被伪造的, 充其量只是公钥泄露, 谁都验证jwt而已。</p><p><code>其实也就是对称加密和非对称加密的区别</code></p><h3 id="jwt-go"><a href="#jwt-go" class="headerlink" title="jwt-go"></a>jwt-go</h3><h4 id="安装-jwt-go"><a href="#安装-jwt-go" class="headerlink" title="安装 jwt-go"></a>安装 jwt-go</h4><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">go get -u github.<span class="property">com</span>/dgrijalva/jwt-go@latest</span><br></pre></td></tr></table></figure><h4 id="生成token"><a href="#生成token" class="headerlink" title="生成token"></a>生成token</h4><p>使用 <code>jwt-go</code> 库生成<code> token</code>，我们需要定义需求（<code>claims</code>），也就是说我们需要通过 jwt 传输的数据。假如我们需要传输 ID 和 Username，我们可以定义 Claims 结构体，其中包含 ID 和 Username 字段，还有在 <code>jwt-go</code> 包预定义的 <code>jwt.StandardClaims</code>。</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> Claims <span class="keyword">struct</span> &#123;</span><br><span class="line">ID       <span class="type">int64</span></span><br><span class="line">Username <span class="type">string</span></span><br><span class="line">jwt.StandardClaims</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><code>jwt.StandardClaims</code> 包含的字段：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> StandardClaims <span class="keyword">struct</span> &#123;</span><br><span class="line">  Audience  <span class="type">string</span> <span class="string">`json:&quot;aud,omitempty&quot;`</span></span><br><span class="line">  ExpiresAt <span class="type">int64</span>  <span class="string">`json:&quot;exp,omitempty&quot;`</span></span><br><span class="line">  Id        <span class="type">string</span> <span class="string">`json:&quot;jti,omitempty&quot;`</span></span><br><span class="line">  IssuedAt  <span class="type">int64</span>  <span class="string">`json:&quot;iat,omitempty&quot;`</span></span><br><span class="line">  Issuer    <span class="type">string</span> <span class="string">`json:&quot;iss,omitempty&quot;`</span></span><br><span class="line">  NotBefore <span class="type">int64</span>  <span class="string">`json:&quot;nbf,omitempty&quot;`</span></span><br><span class="line">  Subject   <span class="type">string</span> <span class="string">`json:&quot;sub,omitempty&quot;`</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><code>jwt.NewWithClaims</code> 方法：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">func jwt.<span class="title class_">NewWithClaims</span>(method jwt.<span class="property">SigningMethod</span>, claims jwt.<span class="property">Claims</span>) *jwt.<span class="property">Token</span></span><br></pre></td></tr></table></figure><p><code>jwt.NewWithClaims</code> 方法根据 <code>Claims</code> 结构体创建 <code>Token</code> 示例。</p><p>参数 1 是 jwt.SigningMethod，</p><p>其中包含</p><ul><li><p><code>jwt.SigningMethodHS256</code>，</p></li><li><p><code>jwt.SigningMethodHS384</code>，</p></li><li><p><code>jwt.SigningMethodHS512</code></p></li></ul><p>三种<code>crypto.Hash</code> 加密算法的方案。</p><p>参数 2 是 Claims，包含自定义类型和 StandardClaim，StandardClaim 嵌入在自定义类型中，以方便对标准声明进行编码，解析和验证。</p><p>SignedString 方法：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(*jwt.Token)</span></span>.SignedString(key <span class="keyword">interface</span>&#123;&#125;) (<span class="type">string</span>, <span class="type">error</span>)</span><br></pre></td></tr></table></figure><p>SignedString 方法根据传入的空接口类型参数 key，返回完整的签名令牌。</p><h5 id="示例"><a href="#示例" class="headerlink" title="示例"></a>示例</h5><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//claims.go</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">package</span> claims</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> <span class="string">&quot;github.com/dgrijalva/jwt-go&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> Claims <span class="keyword">struct</span> &#123;</span><br><span class="line">ID       <span class="type">int64</span></span><br><span class="line">Username <span class="type">string</span></span><br><span class="line">jwt.StandardClaims</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> Token</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> (</span><br><span class="line"><span class="string">&quot;github.com/dgrijalva/jwt-go&quot;</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="comment">// GenerateTokenString</span></span><br><span class="line"><span class="comment">// 获取CLAIMS结构体对应的token值</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">GenerateTokenString</span><span class="params">(claims jwt.Claims)</span></span> (<span class="type">string</span>, <span class="type">error</span>) &#123;</span><br><span class="line"><span class="comment">//func NewWithClaims(method SigningMethod, claims Claims) *Token</span></span><br><span class="line"><span class="comment">//参数解析：method表示加密方法，claims表示对应的claims结构体，后续跟着.SignedString([]byte(&quot;golang&quot;))，其中的参数其实是代表私钥</span></span><br><span class="line">token, err := jwt.NewWithClaims(jwt.SigningMethodHS256, claims).SignedString([]<span class="type">byte</span>(<span class="string">&quot;golang&quot;</span>))</span><br><span class="line"><span class="keyword">return</span> token, err</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//main.go</span></span><br><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> (</span><br><span class="line"><span class="string">&quot;GO_JWT/Token&quot;</span></span><br><span class="line"><span class="string">&quot;GO_JWT/claims&quot;</span></span><br><span class="line"><span class="string">&quot;fmt&quot;</span></span><br><span class="line"><span class="string">&quot;github.com/dgrijalva/jwt-go&quot;</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">TokenString, err := Token.GenerateTokenString(claims.Claims&#123;</span><br><span class="line">ID:             <span class="number">1</span>,</span><br><span class="line">Username:       <span class="string">&quot;Tom&quot;</span>,</span><br><span class="line">StandardClaims: jwt.StandardClaims&#123;&#125;,</span><br><span class="line">&#125;)</span><br><span class="line"><span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line"><span class="built_in">panic</span>(err)</span><br><span class="line">&#125;</span><br><span class="line">fmt.Printf(<span class="string">&quot;%v&quot;</span>, TokenString)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//output:eyJhbGciOiJIUzI1NiIsInR5cCI6IkpXVCJ9.eyJJRCI6MSwiVXNlcm5hbWUiOiJUb20ifQ.2rzyQl4GG3DSXC7BbNKgClh0iMYA2dIz7c35hoTxhcQ</span></span><br></pre></td></tr></table></figure><h4 id="解析token"><a href="#解析token" class="headerlink" title="解析token"></a>解析token</h4><p>使用 jwt-go 库解析 token，主要用到两个方法，分别用通过与解析传入的 token 字符串，和根据 <code>MyCustomClaims</code> 结构体定义的相关属性要求进行校验。</p><p><code>jwt.ParseWithClaims</code> 方法：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">func jwt.<span class="title class_">ParseWithClaims</span>(tokenString string, claims jwt.<span class="property">Claims</span>, keyFunc jwt.<span class="property">Keyfunc</span>) (*jwt.<span class="property">Token</span>, error)</span><br></pre></td></tr></table></figure><p><code>jwt.ParseWithClaims</code> 方法用于解析鉴权的声明，返回 &#96;*jwt.Token。</p><p><code>Valid</code> 方法用于校验鉴权的声明。</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//ParseToken.go</span></span><br><span class="line"><span class="keyword">package</span> Token</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> (</span><br><span class="line"><span class="string">&quot;GO_JWT/claims&quot;</span></span><br><span class="line"><span class="string">&quot;github.com/dgrijalva/jwt-go&quot;</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="comment">// ParseTokenString</span></span><br><span class="line"><span class="comment">// 解析Token字符串，将其转换为claims结构体对象</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">ParseTokenString</span><span class="params">(tokenString <span class="type">string</span>)</span></span> (<span class="keyword">interface</span>&#123;&#125;, <span class="type">error</span>) &#123;</span><br><span class="line"><span class="comment">//func jwt.ParseWithClaims(tokenString string, claims jwt.Claims, keyFunc jwt.Keyfunc) (*jwt.Token, error)</span></span><br><span class="line"><span class="comment">//参数解析：tokenString token字符串，claims 目标结构体对象，keyFunc表示通过这个token返回私钥</span></span><br><span class="line">tokenClaims, err := jwt.ParseWithClaims(tokenString, &amp;claims.Claims&#123;&#125;, <span class="function"><span class="keyword">func</span><span class="params">(token *jwt.Token)</span></span> (<span class="keyword">interface</span>&#123;&#125;, <span class="type">error</span>) &#123;</span><br><span class="line"><span class="keyword">return</span> []<span class="type">byte</span>(<span class="string">&quot;golang&quot;</span>), <span class="literal">nil</span></span><br><span class="line">&#125;)</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line"><span class="keyword">return</span> <span class="literal">nil</span>, err</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> tokenClaims != <span class="literal">nil</span> &#123;</span><br><span class="line"><span class="keyword">if</span> value, ok := tokenClaims.Claims.(*claims.Claims); ok &amp;&amp; tokenClaims.Valid &#123;</span><br><span class="line"><span class="keyword">return</span> value, <span class="literal">nil</span></span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> <span class="literal">nil</span>, err</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> (</span><br><span class="line"><span class="string">&quot;GO_JWT/Token&quot;</span></span><br><span class="line"><span class="string">&quot;GO_JWT/claims&quot;</span></span><br><span class="line"><span class="string">&quot;fmt&quot;</span></span><br><span class="line"><span class="string">&quot;github.com/dgrijalva/jwt-go&quot;</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">TokenString, err := Token.GenerateTokenString(claims.Claims&#123;</span><br><span class="line">ID:             <span class="number">1</span>,</span><br><span class="line">Username:       <span class="string">&quot;Tom&quot;</span>,</span><br><span class="line">StandardClaims: jwt.StandardClaims&#123;&#125;,</span><br><span class="line">&#125;)</span><br><span class="line"><span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line"><span class="built_in">panic</span>(err)</span><br><span class="line">&#125;</span><br><span class="line">fmt.Printf(<span class="string">&quot;%v\n&quot;</span>, TokenString)</span><br><span class="line"></span><br><span class="line">value, err := Token.ParseTokenString(TokenString)</span><br><span class="line">fmt.Printf(<span class="string">&quot;%#v&quot;</span>, value)</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//output:</span></span><br><span class="line"><span class="comment">//eyJhbGciOiJIUzI1NiIsInR5cCI6IkpXVCJ9.eyJJRCI6MSwiVXNlcm5hbWUiOiJUb20ifQ.2rzyQl4GG3DSXC7BbNKgClh0iMYA2dIz7c35hoTxhcQ</span></span><br><span class="line"><span class="comment">//&amp;claims.Claims&#123;ID:1, Username:&quot;Tom&quot;, StandardClaims:jwt.StandardClaims&#123;Audience:&quot;&quot;, ExpiresAt:0, Id:&quot;&quot;, IssuedAt:0, Issuer:&quot;&quot;, NotBefore:0, Subject:&quot;&quot;&#125;&#125;</span></span><br></pre></td></tr></table></figure><p>主要参考自<a href="https://developer.aliyun.com/article/995894">https://developer.aliyun.com/article/995894</a></p>]]></content>
      
      
      <categories>
          
          <category> golang </category>
          
          <category> jwt </category>
          
      </categories>
      
      
        <tags>
            
            <tag> golang </tag>
            
            <tag> jwt </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>MySQL</title>
      <link href="/2023/07/03/MySQL/"/>
      <url>/2023/07/03/MySQL/</url>
      
        <content type="html"><![CDATA[<h1 id="SQl数据类型"><a href="#SQl数据类型" class="headerlink" title="SQl数据类型"></a><strong>SQl数据类型</strong></h1><h2 id="数值类型"><a href="#数值类型" class="headerlink" title="数值类型"></a><strong>数值类型</strong></h2><ul><li>tinyint1byte小整数值</li><li>smallint2bytes大整数值</li><li>mediumint3bytes大整数值</li><li>int&#x2F;integer4bytes大整数值</li><li>bigint8bytes极大整数值</li><li>float4bytes 单精度浮点数值</li><li>double8bytes双精度浮点数值</li><li>decimal            小数值；</li></ul><h2 id="日期和时间类型"><a href="#日期和时间类型" class="headerlink" title="日期和时间类型"></a><strong>日期和时间类型</strong></h2><ul><li>date3日期值</li><li>time3时间或持续时间</li><li>year1年份值</li><li>datetime8混合日期和时间值</li><li>timestamp4混合日期和时间值，时间戳</li></ul><h2 id="字符串类型"><a href="#字符串类型" class="headerlink" title="字符串类型"></a><strong>字符串类型</strong></h2><ul><li>char 0-255byes定长字符串</li><li>varchar0-65535bytes变长字符串</li><li>tinyblob0-255byes不超过255个字符串的二进制字符串</li><li>tinytext 0-255byes短文本字符串</li><li>blob0-65535bytes二进制形式的长文本数据</li><li>text0-65535bytes长文本数据</li><li>mediumblob0-16777215bytes二进制形式的中等长度文本数据</li><li>mediumtext0-16777215bytes中等长度文本数据</li><li>longblob0-4294967295bytes二进制形式的极大本文数据</li><li>longtext0-4294967295bytes极大文本数据</li></ul><h1 id="SQL分类"><a href="#SQL分类" class="headerlink" title="SQL分类:"></a><strong>SQL分类:</strong></h1><p>1.DDL数据定义语言，用来定义数据库对象：数据库，表，列等。</p><p>2.DML数据操作语言，用来对数据库中的表的数据进行增删改操作</p><p>3.DQL数据查询语言，用来查询数据库中的表的记录（数据）</p><p>4.DCL数据控制语言，用来定义数据库的访问权限和安全级别，以及创建用户。</p><h2 id="DDL-操作数据库"><a href="#DDL-操作数据库" class="headerlink" title="DDL-操作数据库"></a><strong>DDL-操作数据库</strong></h2><h3 id="查询"><a href="#查询" class="headerlink" title="查询"></a><strong>查询</strong></h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">show databases;  #查询</span><br></pre></td></tr></table></figure><h3 id="创建"><a href="#创建" class="headerlink" title="创建"></a><strong>创建</strong></h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">create database 数据库名称;  #创建数据库</span><br><span class="line"></span><br><span class="line">create database if not exists 数据库名称； #如果不存在就创建数据库</span><br></pre></td></tr></table></figure><h3 id="删除"><a href="#删除" class="headerlink" title="删除"></a><strong>删除</strong></h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">drop database 数据库名称; #删除数据库</span><br><span class="line"></span><br><span class="line">drop database if exists 数据库名称; #如果数据库存在，则删除</span><br></pre></td></tr></table></figure><h3 id="使用"><a href="#使用" class="headerlink" title="使用"></a><strong>使用</strong></h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">use 数据库名称; #使用数据库</span><br><span class="line"></span><br><span class="line">select database(); #查看当前使用的数据库</span><br></pre></td></tr></table></figure><h2 id="DDL-操作表"><a href="#DDL-操作表" class="headerlink" title="DDL-操作表"></a><strong>DDL-操作表</strong></h2><h3 id="查询表"><a href="#查询表" class="headerlink" title="查询表"></a><strong>查询表</strong></h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">show tables;#查询当前数据库下所有表的名称</span><br><span class="line"></span><br><span class="line">desc 表名称;#查询表结构</span><br></pre></td></tr></table></figure><h3 id="创建表"><a href="#创建表" class="headerlink" title="创建表"></a><strong>创建表</strong></h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">create table 表明(    字段名1 数据类型1,    字段名2 数据类型2,    ...    字段名n，数据类型n );</span><br></pre></td></tr></table></figure><h3 id="删除表"><a href="#删除表" class="headerlink" title="删除表"></a><strong>删除表</strong></h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">drop table 表名;</span><br><span class="line"></span><br><span class="line">drop table if exists 表名; #如果存在就删除</span><br></pre></td></tr></table></figure><h3 id="修改表"><a href="#修改表" class="headerlink" title="修改表"></a><strong>修改表</strong></h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">alter table 表名 rename to 新表名;    修改表名</span><br><span class="line"></span><br><span class="line">alter table 表名 add 列名 数据类型;    添加一列数据;</span><br><span class="line"></span><br><span class="line">alter table 表名 modify 列名 新数据类型;    修改某一列的数据类型</span><br><span class="line"></span><br><span class="line">alter table 表名 change 列名 新列名 新数据类型;     修改列名和数据类型</span><br><span class="line"></span><br><span class="line">alter table 表名 drop 列名; 删除列;</span><br></pre></td></tr></table></figure><h2 id="DML"><a href="#DML" class="headerlink" title="DML"></a><strong>DML</strong></h2><h3 id="添加数据"><a href="#添加数据" class="headerlink" title="添加数据"></a><strong>添加数据</strong></h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">insert into 表名(列名1，列明2...) values(值1,值2...) #给指定列添加数据  </span><br><span class="line"></span><br><span class="line">insert into 表名 values(值1,值2...)  #给全部列添加数据  </span><br><span class="line"></span><br><span class="line">insert into 表名(列名1，列明2...) values(值1,值2...),(值1,值2...),(值1,值2...)...; </span><br><span class="line"></span><br><span class="line">insert into 表名 values(值1,值2...),(值1,值2...),(值1,值2...)...; #批量增加数据</span><br></pre></td></tr></table></figure><h3 id="修改数据"><a href="#修改数据" class="headerlink" title="修改数据"></a><strong>修改数据</strong></h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">update 表名 set 列名1=值1, 列名2=值2, ...[where 条件]; #修改表数据</span><br></pre></td></tr></table></figure><h3 id="删除数据"><a href="#删除数据" class="headerlink" title="删除数据"></a><strong>删除数据</strong></h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">delete from 表名 [where 条件];#删除数据</span><br></pre></td></tr></table></figure><h2 id="DQL"><a href="#DQL" class="headerlink" title="DQL"></a><strong>DQL</strong></h2><h3 id="查询语法"><a href="#查询语法" class="headerlink" title="查询语法"></a><strong>查询语法</strong></h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">select    字段1  from    表名列表  where    条件列表 group by    分组字段 having    分组后条件 order by    排序字段 limit    分页限定</span><br></pre></td></tr></table></figure><h3 id="基础查询"><a href="#基础查询" class="headerlink" title="基础查询"></a><strong>基础查询</strong></h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">1.查询多个字段 select 字段列表 from 表名; select * from 表名;#查询所有数据 星号意味着选择所有列  </span><br><span class="line"></span><br><span class="line">2.去除重复记录 select distinct 字段列表 from 表名;  </span><br><span class="line"></span><br><span class="line">3.起别名 as:</span><br></pre></td></tr></table></figure><h3 id="模糊查寻"><a href="#模糊查寻" class="headerlink" title="模糊查寻"></a><strong>模糊查寻</strong></h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">select* from 表名 where 列名 like &#x27;%String%&#x27;;</span><br></pre></td></tr></table></figure><h3 id="条件查询"><a href="#条件查询" class="headerlink" title="条件查询"></a><strong>条件查询</strong></h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">select 字段列表 from 表名 where 条件;</span><br></pre></td></tr></table></figure><h4 id="条件"><a href="#条件" class="headerlink" title="条件"></a><strong>条件</strong></h4><p>​    <img src="/2023/07/03/MySQL/%E6%9D%A1%E4%BB%B6.png" alt="0"></p><h3 id="排序查询"><a href="#排序查询" class="headerlink" title="排序查询"></a><strong>排序查询</strong></h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">select 字段列表 from 表名 order by 排序字段名1[排序方式1]，排序字段名2[排序方式2]...; #排序查询语法 </span><br><span class="line">/* 排序方式 ASC:升序排序 DESC:降序排序 */</span><br></pre></td></tr></table></figure><h3 id="分组查询"><a href="#分组查询" class="headerlink" title="分组查询"></a><strong>分组查询</strong></h3><h4 id="聚合函数"><a href="#聚合函数" class="headerlink" title="聚合函数"></a><strong>聚合函数</strong></h4><h5 id="分类"><a href="#分类" class="headerlink" title="分类"></a><strong>分类</strong></h5><ul><li>count(列名) 统计数量 </li><li>max(列名)  最大值 </li><li>min(列名)  最小值 </li><li>sum(列名)  求和 </li><li>avg(列名)   求平均值</li></ul><h5 id="语法"><a href="#语法" class="headerlink" title="语法"></a><strong>语法</strong></h5><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">select 聚合函数名(列名) from 表;</span><br></pre></td></tr></table></figure><h4 id="分组查询语法"><a href="#分组查询语法" class="headerlink" title="分组查询语法"></a><strong>分组查询语法</strong></h4><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">SELECT column_name, function(column_name)</span><br><span class="line">FROM table_name</span><br><span class="line">WHERE column_name operator value</span><br><span class="line">GROUP BY column_name;</span><br></pre></td></tr></table></figure><h3 id="分页查询"><a href="#分页查询" class="headerlink" title="分页查询"></a>分页查询</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">select 字段列表 from 表名 limit 起始索引,查询条目数;</span><br></pre></td></tr></table></figure><h3 id="并集-union"><a href="#并集-union" class="headerlink" title="并集 union"></a>并集 union</h3><p>MySQL UNION 操作符用于连接两个以上的 SELECT 语句的结果组合到一个结果集合中。多个 SELECT 语句会删除重复的数据。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">SELECT expression1, expression2, ... expression_n</span><br><span class="line">FROM tables</span><br><span class="line">[WHERE conditions]</span><br><span class="line">UNION [ALL | DISTINCT]</span><br><span class="line">SELECT expression1, expression2, ... expression_n</span><br><span class="line">FROM tables</span><br><span class="line">[WHERE conditions];</span><br></pre></td></tr></table></figure><ul><li><strong>expression1, expression2, … expression_n</strong>: 要检索的列。</li><li><strong>tables:</strong> 要检索的数据表。</li><li><strong>WHERE conditions:</strong> 可选， 检索条件。</li><li><strong>DISTINCT:</strong> 可选，删除结果集中重复的数据。默认情况下 UNION 操作符已经删除了重复数据，所以 DISTINCT 修饰符对结果没啥影响。</li><li><strong>ALL:</strong> 可选，返回所有结果集，包含重复数据。</li></ul><h1 id="约束"><a href="#约束" class="headerlink" title="约束"></a><strong>约束</strong></h1><h2 id="概念"><a href="#概念" class="headerlink" title="概念"></a><strong>概念</strong></h2><p>约束是作用于表中列上的规则，用于限制加入表的数据。</p><p>约束的存在保证了数据库中数据的正确性，有效性和完整性。</p><h2 id="分类-1"><a href="#分类-1" class="headerlink" title="分类"></a><strong>分类</strong></h2><p>​    <img src="/2023/07/03/MySQL/%E7%BA%A6%E6%9D%9F.png" alt="0"></p><h2 id="语法-1"><a href="#语法-1" class="headerlink" title="语法"></a><strong>语法</strong></h2><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">#添加约束 </span><br><span class="line">create table 表名(   </span><br><span class="line">    列名 数据类型 约束关键字,#通过给字段添加 AUTO_INCREMENT 属性来实现主键自增长    </span><br><span class="line">    ... </span><br><span class="line">) </span><br><span class="line"></span><br><span class="line">alter table 表名 modify 字段名 数据类型 约束关键字;  </span><br><span class="line"></span><br><span class="line"></span><br><span class="line">删除约束 </span><br><span class="line">alter table 表名 modify 字段名 数据类型;</span><br></pre></td></tr></table></figure><h2 id="外键约束"><a href="#外键约束" class="headerlink" title="外键约束"></a><strong>外键约束</strong></h2><p>前面的各种约束都差不多，这里着重讲解外键约束</p><p>外键用来让两个表之间的数据建立链接，保证数据的一致性和完整性。</p><h3 id="语法-2"><a href="#语法-2" class="headerlink" title="语法"></a><strong>语法</strong></h3><p>外键的使用：</p><p>外键字段不能为该表的主键；</p><p>外键字段参考字段必须为参考表的主键(primary key)。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">#添加外键约束 </span><br><span class="line">create table 表名(    </span><br><span class="line">    列名 数据类型,</span><br><span class="line">    ...    </span><br><span class="line">    [constraint] [外键名称] foreign key(外键列名) references 主表(主表列名) </span><br><span class="line">) </span><br><span class="line"></span><br><span class="line">alter table 表名 add constraint 外键名称 foreign key (外键字段名称) references 主表名称(主表列名称) </span><br><span class="line"></span><br><span class="line">#删除外键约束 </span><br><span class="line">alter table 表名 drop foreign key 外键名称;</span><br></pre></td></tr></table></figure><h1 id="数据库设计"><a href="#数据库设计" class="headerlink" title="数据库设计"></a><strong>数据库设计</strong></h1><h2 id="概念-1"><a href="#概念-1" class="headerlink" title="概念"></a><strong>概念</strong></h2><p>数据库设计就是根据业务系统的具体需求，结合我们所选用的DBMS,为这个业务构建出最佳的数据存储结构</p><p>建立数据库中的表结构以及表与表之间的关联关系的过程。</p><h2 id="设计步骤"><a href="#设计步骤" class="headerlink" title="设计步骤"></a><strong>设计步骤</strong></h2><p>​    <img src="/2023/07/03/MySQL/%E8%AE%BE%E8%AE%A1%E6%AD%A5%E9%AA%A4.png" alt="0"></p><h2 id="表关系"><a href="#表关系" class="headerlink" title="表关系"></a><strong>表关系</strong></h2><ul><li><p>一对一</p></li><li><p>一对多</p></li><li><p>多对多</p></li></ul><h3 id="多表关系实现"><a href="#多表关系实现" class="headerlink" title="多表关系实现"></a><strong>多表关系实现</strong></h3><h4 id="一对一"><a href="#一对一" class="headerlink" title="一对一"></a><strong>一对一</strong></h4><p>一对一关系多用于表拆分，将一个实体中经常使用的字段放一张表，不经常使用的放另一张表，用于提升查询性能</p><h4 id="一对多"><a href="#一对多" class="headerlink" title="一对多"></a><strong>一对多</strong></h4><p>在多的一方建立外键，指向一的一方的主键。</p><h4 id="多对多"><a href="#多对多" class="headerlink" title="多对多"></a><strong>多对多</strong></h4><p>建立第三张中间表，中间表中至少包含两个外键，分别关联双方的主键。</p><h1 id="多表查询"><a href="#多表查询" class="headerlink" title="多表查询"></a><strong>多表查询</strong></h1><h2 id="基础概念"><a href="#基础概念" class="headerlink" title="基础概念:"></a><strong>基础概念:</strong></h2><p>笛卡尔积：有两个集合AB，取AB的所有组合情况。</p><p>多表查询：从多张表中查询数据。</p><h2 id="连接查询："><a href="#连接查询：" class="headerlink" title="连接查询："></a>连接查询：</h2><p>内连接：</p><ul><li>相当于查询A B的交集数据；</li></ul><p>外连接：</p><ul><li><p>左外连接：相当于查询A表所有数据和交集部分数据；</p></li><li><p>右外连接：相当于查询B表所有数据和交集部分数据；</p></li></ul><p>子查询。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">select * from 表1,表2;  </span><br><span class="line">//可以达到目的，但是会产生笛卡尔积，产生很多无用数据 </span><br><span class="line"></span><br><span class="line">select * from 表1,表2 where 条件;  </span><br><span class="line">//where筛选</span><br></pre></td></tr></table></figure><h3 id="内连接"><a href="#内连接" class="headerlink" title="内连接"></a><strong>内连接</strong></h3><p>相当于查询两集合A B的交集数据</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">//隐式内连接 </span><br><span class="line">select 字段名称 from 表1,表2... where 条件; </span><br><span class="line"></span><br><span class="line">//显式内连接 </span><br><span class="line">select 字段名称 from 表1 [inner] join 表2 on 条件;</span><br></pre></td></tr></table></figure><h3 id="外连接"><a href="#外连接" class="headerlink" title="外连接"></a><strong>外连接</strong></h3><ul><li><p>左外连接：相当于查询A表所有数据和交集部分数据；</p></li><li><p>右外连接：相当于查询B表所有数据和交集部分数据；</p></li></ul><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">//左外连接 </span><br><span class="line">select 字段名称 from 表1 left [outer] join 表2 on 条件; </span><br><span class="line"></span><br><span class="line">//右外连接 </span><br><span class="line">select 字段名称 from 表1 right [outer] join 表2 on 条件;</span><br></pre></td></tr></table></figure><h2 id="子查询"><a href="#子查询" class="headerlink" title="子查询"></a><strong>子查询</strong></h2><p>概念：</p><p>查询中嵌套查询，则称嵌套查询为子查询。</p><p>子查询根据查询结果不同，作用不同：</p><ul><li>单行单列</li><li>多行单列</li><li>多行多列</li></ul><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">单行单列 </span><br><span class="line">select 字段列表 from 表 where 字段名=(子查询); </span><br><span class="line"></span><br><span class="line">多行单列 </span><br><span class="line">select 字段列表 from 表 where 字段名 in (子查询); </span><br><span class="line"></span><br><span class="line">多行多列 </span><br><span class="line">select 字段列表 from (子查询) where 条件;</span><br></pre></td></tr></table></figure><h1 id="事务"><a href="#事务" class="headerlink" title="事务"></a><strong>事务</strong></h1><h2 id="简介"><a href="#简介" class="headerlink" title="简介"></a><strong>简介</strong></h2><ul><li>数据库的事务是一种机制，一个操作序列，包含了一组数据库操作命令。</li><li>十五把所有的命令作为一个整体一起向系统提交或者撤销操作请求，即这一组数据库命令要么同时成功，要么同时失败。</li><li>事务是一个不可分割的工作逻辑单元。</li></ul><h2 id="基础语法："><a href="#基础语法：" class="headerlink" title="基础语法："></a><strong>基础语法：</strong></h2><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">--开启事务 start transaction; 或者 begin; </span><br><span class="line">--提交事务 commit; </span><br><span class="line">--回滚事务 rollback;</span><br></pre></td></tr></table></figure><h2 id="事务的四大特征："><a href="#事务的四大特征：" class="headerlink" title="事务的四大特征："></a><strong>事务的四大特征：</strong></h2><ul><li>原子性：事务是不可分割的最小操作单位，要么同时成功，要么同时失败。</li><li>一致性：事务完成时，必须使所有的数据都保持一致状态</li><li>隔离性：多个事物之间，操作的可见性</li><li>持久性：事务一旦提交或者回滚，它对数据库中的数据的改变就是永久的。</li></ul><h2 id="MySQL事务默认提交"><a href="#MySQL事务默认提交" class="headerlink" title="MySQL事务默认提交"></a><strong>MySQL事务默认提交</strong></h2><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">--查看事务的默认提交方式 </span><br><span class="line">select @@autocommit;</span><br><span class="line">--1自动提交 0手动提交 </span><br><span class="line"></span><br><span class="line">--修改事务提交方式 </span><br><span class="line">set @@autocommit =0;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> SQL </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>RPC概念</title>
      <link href="/2023/07/03/RPC/"/>
      <url>/2023/07/03/RPC/</url>
      
        <content type="html"><![CDATA[<h1 id="什么是RPC"><a href="#什么是RPC" class="headerlink" title="什么是RPC"></a>什么是RPC</h1><p><em>远程过程调用（Remote Procedure Call，缩写为 RPC）是一个计算机通信协议。 该协议允许运行于一台计算机的程序调用另一台计算机的子程序，而程序员无需额外地为这个交互作用编程。 如果涉及的软件采用面向对象编程，那么远程过程调用亦可称作远程调用或远程方法调用，比如 Java RMI. 简单来说，通过使用 RPC，我们可以像调用方法一样快捷的与远程服务进行交互。</em></p><p>其中所谓的过程，就是业务处理、计算任务等等，更直白的说，就是程序，就是想调用本地方法一样调用远程的过程。</p><p>远程过程调用是一个分布式计算的客户端-服务器（Client&#x2F;Server）的例子，它简单而又广受欢迎。 **远程过程调用总是由客户端对服务器发出一个执行若干过程请求，并用客户端提供的参数。执行结果将返回给客户端。 **由于存在各式各样的变体和细节差异，对应地派生了各式远程过程调用协议，而且它们并不互相兼容。</p><p>为了允许不同的客户端均能访问服务器，许多标准化的 RPC 系统应运而生了。其中大部分采用接口描述语言（Interface Description Language，IDL），方便跨平台的远程过程调用。</p><p>总而言之，RPC主要有两大重要特性：</p><ol><li>RPC是一种通过网络从远程计算机程序上请求服务，不需要了解底层网络技术的协议。</li><li>RPC主要作用是不同的服务间方法调用就像本地调用一样便捷。</li></ol><h1 id="架构"><a href="#架构" class="headerlink" title="架构"></a>架构</h1><p><img src="http://books.studygolang.com/go-rpc-programming-guide/ch0-RPC.gif" alt="来自microsoft"></p><p>可以看出<em>RPC采用客户端&#x2F;服务端的模式，通过request-response消息模式实现，我们所熟知的 HTTP协议也是一个简单的请求响应协议</em></p><p>这里的Stub，我们通常称之为存根，用来转换RPC过程中传递的参数：</p><ul><li><p><strong>客户端存根（Client Stub）：</strong>存放服务端的地址消息，再将客户端的请求参数打包成网络消息，然后通过网络远程发送给服务方。</p></li><li><p><strong>服务端存根（Server Stub）：</strong>接收客户端发送过来的消息，将消息解包，并调用本地的方法。</p></li></ul><p>服务的调用过程为：</p><ol><li>client调用client stub，这是一次本地过程调用</li><li>client stub将参数打包成一个消息，然后发送这个消息。打包过程也叫做 marshalling（序列化）</li><li>client所在的系统将消息发送给server</li><li>server的的系统将收到的包传给server stub</li><li>server stub解包得到参数。 解包也被称作 unmarshalling（反序列化）</li><li>最后server stub调用服务过程. 返回结果按照相反的步骤传给client</li></ol><p>可以看出来 RPC 的客户端和服务器端是高度耦合的</p><h1 id="RPC-vs-RESTful"><a href="#RPC-vs-RESTful" class="headerlink" title="RPC vs RESTful"></a>RPC vs RESTful</h1><p>RPC 的消息传输可以通过 TCP、UDP 或者 HTTP等，所以有时候我们称之为 RPC over TCP、 RPC over HTTP。RPC 通过 HTTP 传输消息的时候和 RESTful的架构是类似的，但是也有不同。</p><p>首先我们比较 RPC over HTTP 和 RESTful。</p><p><strong>首先 RPC 的客户端和服务器端是紧耦合的，客户端需要知道调用的过程的名字，过程的参数以及它们的类型、顺序等。</strong>一旦服务器更改了过程的实现， 客户端的实现很容易出问题。RESTful基于 http的语义操作资源，参数的顺序一般没有关系，也很容易的通过代理转换链接和资源位置，从这一点上来说，RESTful 更灵活。</p><p><strong>其次，它们操作的对象不一样。</strong> RPC 操作的是方法和过程，它要操作的是方法对象。 RESTful 操作的是资源(resource)，而不是方法。</p><p><strong>第三，RESTful执行的是对资源的操作，增加、查找、修改和删除等,主要是CURD</strong>，所以如果你要实现一个特定目的的操作，比如为名字姓张的学生的数学成绩都加上10这样的操作， RESTful的API设计起来就不是那么直观或者有意义。在这种情况下, RPC的实现更有意义，它可以实现一个 <code>Student.Increment(Name, Score)</code> 的方法供客户端调用。</p><p><img src="http://books.studygolang.com/go-rpc-programming-guide/restful.jpg" alt="img"></p><p>我们再来比较一下 RPC over TCP 和 RESTful。 如果我们直接使用socket实现 RPC，除了上面的不同外，我们可以获得性能上的优势。</p><p>RPC over TCP可以通过长连接减少连接的建立所产生的花费，在调用次数非常巨大的时候(这是目前互联网公司经常遇到的情况,大并发的情况下)，这个花费影响是非常巨大的。<strong>当然 RESTful 也可以通过 keep-alive 实现长连接， 但是它最大的一个问题是它的request-response模型是阻塞的 (http1.0和 http1.1, http 2.0没这个问题)， 发送一个请求后只有等到response返回才能发送第二个请求 (有些http server实现了pipeling的功能，但不是标配)， RPC的实现没有这个限制</strong></p><p>在当今用户和资源都是大数据大并发的趋势下，一个大规模的公司不可能使用一个单体程序提供所有的功能，微服务的架构模式越来越多的被应用到产品的设计和开发中， 服务和服务之间的通讯也越发的重要， 所以 RPC 不失是一个解决服务之间通讯的好办法.</p><p>总而言之，RESTFUL和RPC有以下区别：</p><ol><li>RPC 的客户端和服务器端是紧耦合的，Restful与之相比更灵活</li><li>操作对象不同，RPC主要操作方法和过程，Restful操作资源</li><li>RESTful执行的是对资源的操作,主要是CURD，Restful与之相比起来就显得不是那么的直观</li><li>RPC可以通过长连接减少连接的建立所产生的花费，Restful虽然也可以进行长链接，但是由于请求响应的模型的阻塞机制，导致效率不是很高。</li></ol><h1 id="RPC和Socket"><a href="#RPC和Socket" class="headerlink" title="RPC和Socket"></a>RPC和Socket</h1><p>在计算机通信领域，socket 被翻译为“套接字”，它是计算机之间进行<strong>通信</strong>的<strong>一种约定</strong>或一种方式。通过 socket 这种约定，一台计算机可以接收其他计算机的数据，也可以向其他计算机发送数据<br> 　socket起源于Unix，而Unix&#x2F;Linux基本哲学之一就是“一切皆文件”，都可以用“打开open –&gt; 读写write&#x2F;read –&gt; 关闭close”模式来操作。<br>    <strong>即socket是一种特殊的文件，一些socket函数就是对其进行的操作（读&#x2F;写IO、打开、关闭）。</strong><br> 　Socket()函数返回一个整型的Socket描述符，随后的连接建立、数据传输等操作都是通过该Socket实现的。</p><p><strong>RPC(Remote Procedure Call，远程过程调用)是建立在Socket之上的,出于一种类比的愿望,在一台机器上运行的主程序,可以调用另一台机器上准备好的子程序,就像LPC(本地过程调用).</strong></p><h1 id="为什么要有RPC？"><a href="#为什么要有RPC？" class="headerlink" title="为什么要有RPC？"></a>为什么要有RPC？</h1><ul><li><em>服务化</em>：<ul><li>微服务化，跨平台的服务之间远程调用；</li></ul></li><li><em>分布式系统架构</em>：<ul><li>分布式服务跨机器进行远程调用；</li></ul></li><li><em>服务可重用</em>：<ul><li>开发一个公共能力服务，供多个服务远程调用。</li></ul></li><li><em>系统间交互调用</em>：<ul><li>两台服务器A、B，服务器A上的应用a需要调用服务器B上的应用b提供的方法，而应用a和应用b不在一个内存空间，不能直接调用，此时，需要通过网络传输来表达需要调用的语义及传输调用的数据。</li></ul></li></ul><h1 id="RPC核心概念术语"><a href="#RPC核心概念术语" class="headerlink" title="RPC核心概念术语"></a>RPC核心概念术语</h1><ol><li>client， 客户端 </li><li>server，服务端 </li><li>calls，请求 </li><li>replier，响应 </li><li>services，一个网络服务由一个或者多个远程程序集构成 </li><li>programs，一个远程程序实现一个或多个远程过程 </li><li>procedures，过程、过程的参数、结果在程序协议说明书中定义说明 </li><li>version，为兼容程序协议变更，一个服务端可能支持多个版本的远程程序</li></ol><h1 id="使用场景"><a href="#使用场景" class="headerlink" title="使用场景"></a>使用场景</h1><ol><li><code>大型网站</code>：内部涉及多个子系统，服务、接口较多。</li><li><code>注册发现机制</code>：如Nacos、Dubbo等，一般都有注册中心，服务有多个实例，调用方调用的哪个实例无感知。</li><li>安全性&#96;：不暴露资源。</li><li><code>服务化治理</code>：微服务架构、分布式架构。</li></ol>]]></content>
      
      
      <categories>
          
          <category> RPC </category>
          
      </categories>
      
      
        <tags>
            
            <tag> RPC </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>GRPC</title>
      <link href="/2023/07/03/gRPC/"/>
      <url>/2023/07/03/gRPC/</url>
      
        <content type="html"><![CDATA[<h3 id="GRPC概述"><a href="#GRPC概述" class="headerlink" title="GRPC概述"></a>GRPC概述</h3><blockquote><p>服务和服务之间调用需要使用RPC，<code>gRPC</code>是一款<strong>语言中立</strong>、<strong>平台中立</strong>、开源的<strong>远程过程调用系统</strong>，<code>gRPC</code>客户端和服务端可以在多种环境中运行和交互，例如用<code>java</code>写一个服务端，可以用<code>go</code>语言写客户端调用</p></blockquote><p>数据在进行网络传输的时候，需要进行序列化，序列化协议有很多种，比如<code>xml</code>,<code> json</code>，<code>protobuf</code>等</p><p>gRPC默认使用<code>protocol buffers</code>，这是google开源的一套成熟的结构数据序列化机制。</p><p>在学习gRPC之前，需要先了解<code>protocol buffers</code></p><p><strong>序列化</strong>：将数据结构或对象转换成二进制串的过程。</p><p><strong>反序列化</strong>：将在序列化过程中所产生的二进制串转换成数据结构或对象的过程。</p><h3 id="protobuf"><a href="#protobuf" class="headerlink" title="protobuf"></a>protobuf</h3><p>protobuf是谷歌开源的一种数据格式，适合高性能，对响应速度有要求的数据传输场景。因为profobuf是二进制数据格式，需要编码和解码。数据本身不具有可读性。因此只能反序列化之后得到真正可读的数据。</p><p>优势：</p><ol><li>序列化后体积相比Json和XML很小，适合网络传输</li><li>支持跨平台多语言</li><li>消息格式升级和兼容性还不错</li><li>序列化反序列化速度很快</li></ol><h4 id="安装"><a href="#安装" class="headerlink" title="安装"></a>安装</h4><ul><li><p>第一步：下载通用编译器</p><p>地址：<a href="https://github.com/protocolbuffers/protobuf/releases">https://github.com/protocolbuffers/protobuf/releases</a></p><p>根据不同的操作系统，下载不同的包，我是windows电脑，解压出来是<code>protoc.exe</code></p><p><img src="https://www.mszlu.com/assets/image-20220423001259067.b9d637b9.png" alt="image-20220423001259067"></p></li><li><p>第二步：配置环境变量</p><p><img src="/2023/07/03/gRPC/png;base64,iVBORw0KGgoAAAANSUhEUgAAAakAAAArCAYAAADCI3c8AAAG3UlEQVR4nO3dsW6jSBgH8D+n61PsK4AiF34AeAMsF1Roq+gq0GmlO1OsdI0rNyulMHvS6mSqU0oqF5Z5A/MAFJYFD5F9Al+BwWMz2NiOY+L7/6QUFgN8w5D5YGbiKK+vr2sA+PuffzH8608QEdF9+PnzZ+22Hz9+AAC+fPlSW+bh4QGjb9/xx++/vXlsTf1yszMTEREdwSRFREStxSRFREStdfskFblQDB/ZdQ4OV3ERXeXY9O4yH4ZiwL/OzVJ3UviGArfuJrpJTET/HyckqfyXVVHEn7oEEMG9q1/ce6pPBPdo+yF/eCjL7dddPMax65KXNW5x8XbqIKurGNs9tTHR/Tj5TcqZr7Feb37mQE+RPWWa+DoGwtm9/Ma/Z32OPLlffOwprE37zZ0APemJIrijDtKynbvwtKKTz+AbPSTjVLKtWg9FmQLOG4WvDrBYLzBQG5SNXChiHdYTmPsR+iME5acz2/iUmIjoZJcN95kTrNMxkl61k1L7NhDOrjSM9/7uoz4qBottZ21aDpCsJHUyMVkMUPa7pgUHCVYZgGyGMHYwLHpl8yvGeoBpJUupGCzy5GBdpS6HZPBHCcYvQh0qRXw8hTbGQgK9jzYmui+Xz0mpfdhFJyWOz6t92PDwXOm8xKEiBUovOLjd8DMUT+WGMBaT+YYwlyXbR2bv3DtDQMUbzG6Z8kVDWp8j++xvr4l3G0cEV9HgxUDQa1L+0DU7LpoG0O1+fUe+LYgAXTyqANIlYscS3kpUPHaBZHVZ1x65Ytx5fcrrWMxbZj6MnWtlwPfdar2zGULYwHPdNcngP3noDgd4FIOovWe3MVXauGlMRHSWKy6cUDEYOgh2HrEjuEoPEIYM5ztDQRFcZYROWmxPYYca3Cg/Vlw+5WaYhTGc4QBq7T778eTnLoepyuHK3Q4/6G2Hw9ZzB0H5liirz7F99rYvinjr4jAxWacY65th1aPl5fVaHBp7ynwYmw50ah0pW5TvBXDm+RtYtkoOlz+T1tERL9P8QzRFoutl4qtPpjG8pZXXOx0D3lP+gJQuEccelta6ug1A5GoI7RST/fG/C9r4aExEdJY3SlI6Ohqq4/OmBSeYbn+ZoykCfYyvQudgWkKWiqYIEMPTiifW/K0iWWX5seIQM2HIyTKP7CPanPtF7JQlQ1VFZyzdvl+fJvvsb28YR+O4ZdvzHeWLG9QBFpvO1poqB1dWZr4BRQthp+uyQ1cfuzWlT1GNTe3b0DfXNpomsF+G6IYzZMiwSnTYfVky1TEubia1D1sXNwn3mTrA0Inz+abIRS+RXa+NM9u4UUxEdLLLk1T0DA82pH0ITFhOgNEpj5L6WJjsFt8MTFibjiabhcD467bTqN2n0QnzBNvIGfVp7JQ4mpQ3MSmvh3xi35zMt4l/T+Qq0JZD+b4781gZVgnQfTxl5YAkNrUPW0+wyiJMExt9VUMHIWZRPnQnv79qaB3Ic0MKfxQAsQdtkyR7ARB7mpCsr9nGRHSqy5JU5ELpCRPUkr8ZMfMlU3kHYFpwYnHMP8s7jbLw/nYgcrfDKvmxnvEcYvtkfWSf/WM/icFJEqw41JP5T/CKNzZZfRruc04cjctX6h/Br+tgMx+GK8Y6QqBvjiO2XeZjFDiYV8fD8rcIcd4meoaHzVvLRX8zpKJvA+HTCEH3EWrxeRQCTebNdg6Vzy2V1yzzMQp02H1zs5hjd7hZH6ebodWiihe2MRG9mZOTVNATJvBHHaTHlt+qfdgontZNTOaOcIwnwBYnpUxM0jES4RxTSxhmUfuwESDoDoVzHtlHPPZ6jq6nCYs2gPlidwWYg2m5XfO6mO8vXd6pT8N9TopDRd/WhYUTx8rv13+Kx7oGUQd46Yx2Y11IVsClS8QI0NtZrFEsFlAxeBHOJ7mG51L7NhDHcDa9f/4ZNUN9B4+EwUK4ZpqH7vyEZeIXtzERvRXlPb4FPfONfOhI9mTeGhl8Q8NyuJZMqO+VLOujNd6HPpaPcc8SHcZvQW9IHQylk9Ef1b3Vh6rYxkTt8Ov7nMbEZH1PT6RFfTKsbh0KXcm93bNEH9M7JamPIP+GhOvvQ0RETd3+W9CJiIhqVN6kDk20ERHRx/Dw8HDrEN5EJUndS8WIiKjep0+fbh1CI5yTIiL6H/r8+fOtQ2iEc1JERNRaTFJERNRaTFJERNRaTFJERNRaTFJERNRaTFJERNRaTFJERNRaTFJERNRaTFJERNRaTFJERNRaTFJERNRaTFJERNRaTFJERNRaTFJERNRaTFJERNRaTFJERNRa/KeHRER36h7+0/pOkhp9+36rOIiIiCqU19fX9a2DICIikuGcFBERtRaTFBERtdZ/tyATAYaZiKEAAAAASUVORK5CYII=" alt="image-20220423002031614"></p></li><li><p>第三步：安装go专用的protoc的生成器</p></li></ul><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">go</span> get github.com/golang/protobuf/protoc-gen-<span class="keyword">go</span></span><br></pre></td></tr></table></figure><p>1</p><p>安装后会在<code>GOPATH</code>目录下生成可执行文件，protobuf的编译器插件<code>protoc-gen-go</code>，执行<code>protoc</code>命令会自动调用这个插件</p><blockquote><p>如何使用protobuf呢？</p></blockquote><ol><li>定义了一种源文件，扩展名为 <code>.proto</code>，使用这种源文件，可以定义存储类的内容(消息类型)</li><li>protobuf有自己的编译器 <code>protoc</code>，可以将 <code>.proto</code> 编译成对应语言的文件，就可以进行使用了</li></ol><h4 id="hello-world"><a href="#hello-world" class="headerlink" title="hello world"></a>hello world</h4><blockquote><p>假设，我们现在需要传输用户信息，其中有username和age两个字段</p></blockquote><figure class="highlight protobuf"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 指定的当前proto语法的版本，有2和3</span></span><br><span class="line">syntax = <span class="string">&quot;proto3&quot;</span>;</span><br><span class="line"><span class="comment">//option go_package = &quot;path;name&quot;; ath 表示生成的go文件的存放地址，会自动生成目录的</span></span><br><span class="line"><span class="comment">// name 表示生成的go文件所属的包名</span></span><br><span class="line"><span class="keyword">option</span> go_package=<span class="string">&quot;../service&quot;</span>;</span><br><span class="line"><span class="comment">// 指定等会文件生成出来的package</span></span><br><span class="line"><span class="keyword">package</span> service;</span><br><span class="line"></span><br><span class="line"><span class="keyword">message </span><span class="title class_">User</span> &#123;</span><br><span class="line">  <span class="type">string</span> username = <span class="number">1</span>;</span><br><span class="line">  <span class="type">int32</span> age = <span class="number">2</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>1<br>2<br>3<br>4<br>5<br>6<br>7<br>8<br>9<br>10<br>11<br>12<br>13</p><p><strong>运行protoc命令编译成go中间文件</strong></p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"># 编译user.proto之后输出到service文件夹</span><br><span class="line">protoc --go_out=../service user.proto</span><br></pre></td></tr></table></figure><p>1<br>2</p><p><strong>测试</strong></p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> (</span><br><span class="line"><span class="string">&quot;fmt&quot;</span></span><br><span class="line"><span class="string">&quot;google.golang.org/protobuf/proto&quot;</span></span><br><span class="line"><span class="string">&quot;testProto/service&quot;</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span>  &#123;</span><br><span class="line">user := &amp;service.User&#123;</span><br><span class="line">Username: <span class="string">&quot;mszlu&quot;</span>,</span><br><span class="line">Age: <span class="number">20</span>,</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//转换为protobuf</span></span><br><span class="line">marshal, err := proto.Marshal(user)</span><br><span class="line"><span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line"><span class="built_in">panic</span>(err)</span><br><span class="line">&#125;</span><br><span class="line">newUser := &amp;service.User&#123;&#125;</span><br><span class="line">err = proto.Unmarshal(marshal, newUser)</span><br><span class="line"><span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line"><span class="built_in">panic</span>(err)</span><br><span class="line">&#125;</span><br><span class="line">fmt.Println(newUser.String())</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>1<br>2<br>3<br>4<br>5<br>6<br>7<br>8<br>9<br>10<br>11<br>12<br>13<br>14<br>15<br>16<br>17<br>18<br>19<br>20<br>21<br>22<br>23<br>24<br>25<br>26</p><h4 id="proto文件介绍"><a href="#proto文件介绍" class="headerlink" title="proto文件介绍"></a>proto文件介绍</h4><h5 id="message介绍"><a href="#message介绍" class="headerlink" title="message介绍"></a>message介绍</h5><p><code>message</code>：<code>protobuf</code>中定义一个消息类型是通过关键字<code>message</code>字段指定的。</p><p>消息就是需要传输的数据格式的定义。</p><p>message关键字类似于C++中的class，Java中的class，go中的struct</p><p>例如：</p><figure class="highlight protobuf"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">message </span><span class="title class_">User</span> &#123;</span><br><span class="line">  <span class="type">string</span> username = <span class="number">1</span>;</span><br><span class="line">  <span class="type">int32</span> age = <span class="number">2</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在消息中承载的数据分别对应于每一个字段。</p><p>其中每个字段都有一个名字和一种类型 。</p><h5 id="字段规则"><a href="#字段规则" class="headerlink" title="字段规则"></a>字段规则</h5><ul><li><code>required</code>:消息体中必填字段，不设置会导致编解码异常。（例如位置1）</li><li><code>optional</code>: 消息体中可选字段。（例如位置2）</li><li><code>repeated</code>: 消息体中可重复字段，重复的值的顺序会被保留（例如位置3）在go中重复的会被定义为切片。</li></ul><figure class="highlight protobuf"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">message </span><span class="title class_">User</span> &#123;</span><br><span class="line">  <span class="type">string</span> username = <span class="number">1</span>;</span><br><span class="line">  <span class="type">int32</span> age = <span class="number">2</span>;</span><br><span class="line">  <span class="keyword">optional</span> <span class="type">string</span> password = <span class="number">3</span>;</span><br><span class="line">  <span class="keyword">repeated</span> <span class="type">string</span> address = <span class="number">4</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h5 id="字段映射"><a href="#字段映射" class="headerlink" title="字段映射"></a>字段映射</h5><table><thead><tr><th><strong>.proto Type</strong></th><th><strong>Notes</strong></th><th><strong>C++ Type</strong></th><th><strong>Python Type</strong></th><th><strong>Go Type</strong></th></tr></thead><tbody><tr><td>double</td><td></td><td>double</td><td>float</td><td>float64</td></tr><tr><td>float</td><td></td><td>float</td><td>float</td><td>float32</td></tr><tr><td>int32</td><td>使用变长编码，对于负值的效率很低，如果你的域有 可能有负值，请使用sint64替代</td><td>int32</td><td>int</td><td>int32</td></tr><tr><td>uint32</td><td>使用变长编码</td><td>uint32</td><td>int&#x2F;long</td><td>uint32</td></tr><tr><td>uint64</td><td>使用变长编码</td><td>uint64</td><td>int&#x2F;long</td><td>uint64</td></tr><tr><td>sint32</td><td>使用变长编码，这些编码在负值时比int32高效的多</td><td>int32</td><td>int</td><td>int32</td></tr><tr><td>sint64</td><td>使用变长编码，有符号的整型值。编码时比通常的 int64高效。</td><td>int64</td><td>int&#x2F;long</td><td>int64</td></tr><tr><td>fixed32</td><td>总是4个字节，如果数值总是比总是比228大的话，这 个类型会比uint32高效。</td><td>uint32</td><td>int</td><td>uint32</td></tr><tr><td>fixed64</td><td>总是8个字节，如果数值总是比总是比256大的话，这 个类型会比uint64高效。</td><td>uint64</td><td>int&#x2F;long</td><td>uint64</td></tr><tr><td>sfixed32</td><td>总是4个字节</td><td>int32</td><td>int</td><td>int32</td></tr><tr><td>sfixed32</td><td>总是4个字节</td><td>int32</td><td>int</td><td>int32</td></tr><tr><td>sfixed64</td><td>总是8个字节</td><td>int64</td><td>int&#x2F;long</td><td>int64</td></tr><tr><td>bool</td><td></td><td>bool</td><td>bool</td><td>bool</td></tr><tr><td>string</td><td>一个字符串必须是UTF-8编码或者7-bit ASCII编码的文 本。</td><td>string</td><td>str&#x2F;unicode</td><td>string</td></tr><tr><td>bytes</td><td>可能包含任意顺序的字节数据。</td><td>string</td><td>str</td><td>[]byte</td></tr></tbody></table><h5 id="默认值"><a href="#默认值" class="headerlink" title="默认值"></a>默认值</h5><p>protobuf3 删除了 protobuf2 中用来设置默认值的 default 关键字，取而代之的是protobuf3为各类型定义的默认值，也就是约定的默认值，如下表所示：</p><table><thead><tr><th align="left">类型</th><th align="left">默认值</th></tr></thead><tbody><tr><td align="left">bool</td><td align="left">false</td></tr><tr><td align="left">整型</td><td align="left">0</td></tr><tr><td align="left">string</td><td align="left">空字符串””</td></tr><tr><td align="left">枚举enum</td><td align="left">第一个枚举元素的值，因为Protobuf3强制要求第一个枚举元素的值必须是0，所以枚举的默认值就是0；</td></tr><tr><td align="left">message</td><td align="left">不是null，而是DEFAULT_INSTANCE</td></tr></tbody></table><h5 id="标识号"><a href="#标识号" class="headerlink" title="标识号"></a>标识号</h5><p><code>标识号</code>：在消息体的定义中，每个字段都必须要有一个唯一的标识号，标识号是[0,2^29-1]范围内的一个整数。</p><figure class="highlight protobuf"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">message </span><span class="title class_">Person</span> &#123; </span><br><span class="line"></span><br><span class="line">  <span class="type">string</span> name = <span class="number">1</span>;  <span class="comment">// (位置1)</span></span><br><span class="line">  <span class="type">int32</span> id = <span class="number">2</span>;  </span><br><span class="line">  <span class="keyword">optional</span> <span class="type">string</span> email = <span class="number">3</span>;  </span><br><span class="line">  <span class="keyword">repeated</span> <span class="type">string</span> phones = <span class="number">4</span>; <span class="comment">// (位置4)</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>以Person为例，name&#x3D;1，id&#x3D;2, email&#x3D;3, phones&#x3D;4 中的1-4就是标识号。</p><h5 id="定义多个消息类型"><a href="#定义多个消息类型" class="headerlink" title="定义多个消息类型"></a>定义多个消息类型</h5><p>一个proto文件中可以定义多个消息类型</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">message UserRequest &#123;</span><br><span class="line">  <span class="type">string</span> username = <span class="number">1</span>;</span><br><span class="line">  <span class="type">int32</span> age = <span class="number">2</span>;</span><br><span class="line">  optional <span class="type">string</span> password = <span class="number">3</span>;</span><br><span class="line">  repeated <span class="type">string</span> address = <span class="number">4</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">message UserResponse &#123;</span><br><span class="line">  <span class="type">string</span> username = <span class="number">1</span>;</span><br><span class="line">  <span class="type">int32</span> age = <span class="number">2</span>;</span><br><span class="line">  optional <span class="type">string</span> password = <span class="number">3</span>;</span><br><span class="line">  repeated <span class="type">string</span> address = <span class="number">4</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="嵌套消息"><a href="#嵌套消息" class="headerlink" title="嵌套消息"></a>嵌套消息</h4><p>可以在其他消息类型中定义、使用消息类型，在下面的例子中，Person消息就定义在PersonInfo消息内，如 ：</p><figure class="highlight protobuf"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">message </span><span class="title class_">PersonInfo</span> &#123;</span><br><span class="line">    <span class="keyword">message </span><span class="title class_">Person</span> &#123;</span><br><span class="line">        <span class="type">string</span> name = <span class="number">1</span>;</span><br><span class="line">        <span class="type">int32</span> height = <span class="number">2</span>;</span><br><span class="line">        <span class="keyword">repeated</span> <span class="type">int32</span> weight = <span class="number">3</span>;</span><br><span class="line">    &#125; </span><br><span class="line"><span class="keyword">repeated</span> Person info = <span class="number">1</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>如果你想在它的父消息类型的外部重用这个消息类型，你需要以PersonInfo.Person的形式使用它，如：</p><figure class="highlight protobuf"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">message </span><span class="title class_">PersonMessage</span> &#123;</span><br><span class="line">PersonInfo.Person info = <span class="number">1</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>当然，你也可以将消息嵌套任意多层，如 :</p><figure class="highlight protobuf"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">message </span><span class="title class_">Grandpa</span> &#123; <span class="comment">// Level 0</span></span><br><span class="line">    <span class="keyword">message </span><span class="title class_">Father</span> &#123; <span class="comment">// Level 1</span></span><br><span class="line">        <span class="keyword">message </span><span class="title class_">son</span> &#123; <span class="comment">// Level 2</span></span><br><span class="line">            <span class="type">string</span> name = <span class="number">1</span>;</span><br><span class="line">            <span class="type">int32</span> age = <span class="number">2</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125; </span><br><span class="line">    <span class="keyword">message </span><span class="title class_">Uncle</span> &#123; <span class="comment">// Level 1</span></span><br><span class="line">        <span class="keyword">message </span><span class="title class_">Son</span> &#123; <span class="comment">// Level 2</span></span><br><span class="line">            <span class="type">string</span> name = <span class="number">1</span>;</span><br><span class="line">            <span class="type">int32</span> age = <span class="number">2</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="定义服务-Service"><a href="#定义服务-Service" class="headerlink" title="定义服务(Service)"></a>定义服务(Service)</h4><p>如果想要将消息类型用在RPC系统中，可以在.proto文件中定义一个RPC服务接口，protocol buffer 编译器将会根据所选择的不同语言生成服务接口代码及存根。</p><figure class="highlight protobuf"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">service </span><span class="title class_">SearchService</span> &#123;</span><br><span class="line"><span class="comment">//rpc 服务的函数名 （传入参数）返回（返回参数）</span></span><br><span class="line"><span class="function"><span class="keyword">rpc</span> Search (SearchRequest) <span class="keyword">returns</span> (SearchResponse)</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>上述代表表示，定义了一个RPC服务，该方法接收SearchRequest返回SearchResponse</p><h3 id="gRPC实例"><a href="#gRPC实例" class="headerlink" title="gRPC实例"></a>gRPC实例</h3><h4 id="服务端"><a href="#服务端" class="headerlink" title="服务端"></a>服务端</h4><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 这个就是protobuf的中间文件</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 指定的当前proto语法的版本，有2和3</span></span><br><span class="line">syntax = <span class="string">&quot;proto3&quot;</span>;</span><br><span class="line">option go_package=<span class="string">&quot;../service&quot;</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 指定等会文件生成出来的package</span></span><br><span class="line"><span class="keyword">package</span> service;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 定义request model</span></span><br><span class="line">message ProductRequest&#123;</span><br><span class="line"><span class="type">int32</span> prod_id = <span class="number">1</span>; <span class="comment">// 1代表顺序</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 定义response model</span></span><br><span class="line">message ProductResponse&#123;</span><br><span class="line"><span class="type">int32</span> prod_stock = <span class="number">1</span>; <span class="comment">// 1代表顺序</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 定义服务主体</span></span><br><span class="line">service ProdService&#123;</span><br><span class="line">    <span class="comment">// 定义方法</span></span><br><span class="line">    rpc GetProductStock(ProductRequest) returns(ProductResponse);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>生成：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">protoc --go_out=plugins=grpc:./ .\product.proto</span><br></pre></td></tr></table></figure><p>服务端：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> <span class="string">&quot;google.golang.org/grpc&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span>  &#123;</span><br><span class="line">server := grpc.NewServer()</span><br><span class="line">service.RegisterProdServiceServer(server,service.ProductService)</span><br><span class="line"></span><br><span class="line">listener, err := net.Listen(<span class="string">&quot;tcp&quot;</span>, <span class="string">&quot;:8002&quot;</span>)</span><br><span class="line"><span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">log.Fatal(<span class="string">&quot;服务监听端口失败&quot;</span>, err)</span><br><span class="line">&#125;</span><br><span class="line">_ = server.Serve(listener)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="客户端"><a href="#客户端" class="headerlink" title="客户端"></a>客户端</h4><p>新建client目录，把上述生成的product.pb.go copy过来</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span>  &#123;</span><br><span class="line"><span class="comment">// 1. 新建连接，端口是服务端开放的8002端口</span></span><br><span class="line"><span class="comment">// 没有证书会报错</span></span><br><span class="line">conn, err := grpc.Dial(<span class="string">&quot;:8002&quot;</span>, grpc.WithTransportCredentials(insecure.NewCredentials()))</span><br><span class="line"><span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">log.Fatal(err)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 退出时关闭链接</span></span><br><span class="line"><span class="keyword">defer</span> conn.Close()</span><br><span class="line"></span><br><span class="line"><span class="comment">// 2. 调用Product.pb.go中的NewProdServiceClient方法</span></span><br><span class="line">productServiceClient := service.NewProdServiceClient(conn)</span><br><span class="line"></span><br><span class="line"><span class="comment">// 3. 直接像调用本地方法一样调用GetProductStock方法</span></span><br><span class="line">resp, err := productServiceClient.GetProductStock(context.Background(), &amp;service.ProductRequest&#123;ProdId: <span class="number">233</span>&#125;)</span><br><span class="line"><span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">log.Fatal(<span class="string">&quot;调用gRPC方法错误: &quot;</span>, err)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">fmt.Println(<span class="string">&quot;调用gRPC方法成功，ProdStock = &quot;</span>, resp.ProdStock)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>代码放在这里了。</p><p><a href="https://github.com/thewisecirno/GPRC_Test">https://github.com/thewisecirno/GPRC_Test</a></p><h3 id="安全认证"><a href="#安全认证" class="headerlink" title="安全认证"></a>安全认证</h3><h4 id="生成自签证书"><a href="#生成自签证书" class="headerlink" title="生成自签证书"></a>生成自签证书</h4><blockquote><p>生产环境可以购买证书或者使用一些平台发放的免费证书</p></blockquote><ul><li><p>安装openssl</p><p>网站下载：<a href="http://slproweb.com/products/Win32OpenSSL.html">http://slproweb.com/products/Win32OpenSSL.html</a></p><p>（mac电脑 自行搜索安装）</p></li><li><p>生成私钥文件</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">## 需要输入密码</span></span><br><span class="line">openssl genrsa -des3 -out ca.key 2048</span><br></pre></td></tr></table></figure></li><li><p>创建证书请求</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">openssl req -new -key ca.key -out ca.csr</span><br></pre></td></tr></table></figure></li><li><p>生成ca.crt</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">openssl x509 -req -days 365 -<span class="keyword">in</span> ca.csr -signkey ca.key -out ca.crt</span><br></pre></td></tr></table></figure></li></ul><p>找到openssl.cnf 文件</p><ol><li><p>打开copy_extensions &#x3D; copy</p></li><li><p>打开 req_extensions &#x3D; v3_req</p></li><li><p>找到[ v3_req ],添加 subjectAltName &#x3D; @alt_names</p></li><li><p>添加新的标签 [ alt_names ] , 和标签字段</p><figure class="highlight ini"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="section">[ alt_names ]</span></span><br><span class="line"></span><br><span class="line"><span class="attr">DNS.1</span> = *.mszlu.com</span><br></pre></td></tr></table></figure><p>生成证书私钥server.key</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">openssl genpkey -algorithm RSA -out server.key</span><br></pre></td></tr></table></figure></li><li><p>通过私钥server.key生成证书请求文件server.csr</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">openssl req -new -nodes -key server.key -out server.csr -days 3650 -config ./openssl.cnf -extensions v3_req</span><br></pre></td></tr></table></figure></li><li><p>生成SAN证书</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">openssl x509 -req -days 365 -<span class="keyword">in</span> server.csr -out server.pem -CA ca.crt -CAkey ca.key -CAcreateserial -extfile ./openssl.cnf -extensions v3_req</span><br></pre></td></tr></table></figure></li></ol><ul><li><strong>key：</strong> 服务器上的私钥文件，用于对发送给客户端数据的加密，以及对从客户端接收到数据的解密。</li><li><strong>csr：</strong> 证书签名请求文件，用于提交给证书颁发机构（CA）对证书签名。</li><li><strong>crt：</strong> 由证书颁发机构（CA）签名后的证书，或者是开发者自签名的证书，包含证书持有人的信息，持有人的公钥，以及签署者的签名等信息。</li><li><strong>pem：</strong> 是基于Base64编码的证书格式，扩展名包括PEM、CRT和CER。</li></ul><p>什么是 SAN？</p><p>SAN（Subject Alternative Name）是 SSL 标准 x509 中定义的一个扩展。使用了 SAN 字段的 SSL 证书，可以扩展此证书支持的域名，使得一个证书可以支持多个不同域名的解析。</p><h4 id="服务端应用证书"><a href="#服务端应用证书" class="headerlink" title="服务端应用证书"></a>服务端应用证书</h4><p>将<code>server.key</code>和<code>server.pem</code> copy到程序中</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span>  &#123;</span><br><span class="line"></span><br><span class="line"><span class="comment">//添加证书</span></span><br><span class="line">file, err2 := credentials.NewServerTLSFromFile(<span class="string">&quot;keys/mszlu.pem&quot;</span>, <span class="string">&quot;keys/mszlu.key&quot;</span>)</span><br><span class="line"><span class="keyword">if</span> err2 != <span class="literal">nil</span> &#123;</span><br><span class="line">log.Fatal(<span class="string">&quot;证书生成错误&quot;</span>,err2)</span><br><span class="line">&#125;</span><br><span class="line">rpcServer := grpc.NewServer(grpc.Creds(file))</span><br><span class="line"></span><br><span class="line">service.RegisterProdServiceServer(rpcServer,service.ProductService)</span><br><span class="line"></span><br><span class="line">listener ,err := net.Listen(<span class="string">&quot;tcp&quot;</span>,<span class="string">&quot;:8002&quot;</span>)</span><br><span class="line"><span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">log.Fatal(<span class="string">&quot;启动监听出错&quot;</span>,err)</span><br><span class="line">&#125;</span><br><span class="line">err = rpcServer.Serve(listener)</span><br><span class="line"><span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">log.Fatal(<span class="string">&quot;启动服务出错&quot;</span>,err)</span><br><span class="line">&#125;</span><br><span class="line">fmt.Println(<span class="string">&quot;启动grpc服务端成功&quot;</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="客户端认证"><a href="#客户端认证" class="headerlink" title="客户端认证"></a>客户端认证</h4><p>公钥copy到客户端</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span>  &#123;</span><br><span class="line">file, err2 := credentials.NewClientTLSFromFile(<span class="string">&quot;client/keys/mszlu.pem&quot;</span>, <span class="string">&quot;*.mszlu.com&quot;</span>)</span><br><span class="line"><span class="keyword">if</span> err2 != <span class="literal">nil</span> &#123;</span><br><span class="line">log.Fatal(<span class="string">&quot;证书错误&quot;</span>,err2)</span><br><span class="line">&#125;</span><br><span class="line">conn, err := grpc.Dial(<span class="string">&quot;:8002&quot;</span>, grpc.WithTransportCredentials(file))</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">log.Fatal(<span class="string">&quot;服务端出错，连接不上&quot;</span>,err)</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">defer</span> conn.Close()</span><br><span class="line"></span><br><span class="line">prodClient := service.NewProdServiceClient(conn)</span><br><span class="line"></span><br><span class="line">request := &amp;service.ProductRequest&#123;</span><br><span class="line">ProdId: <span class="number">123</span>,</span><br><span class="line">&#125;</span><br><span class="line">stockResponse, err := prodClient.GetProductStock(context.Background(), request)</span><br><span class="line"><span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">log.Fatal(<span class="string">&quot;查询库存出错&quot;</span>,err)</span><br><span class="line">&#125;</span><br><span class="line">fmt.Println(<span class="string">&quot;查询成功&quot;</span>,stockResponse.ProdStock)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="单向认证"><a href="#单向认证" class="headerlink" title="单向认证"></a>单向认证</h4><p>上述认证方式为单向认证：</p><p><img src="https://www.mszlu.com/assets/1586953-20210625171059706-1447106002-16509094111532.8283e9e7.png" alt="img"></p><p>中间人攻击</p><h4 id="双向认证"><a href="#双向认证" class="headerlink" title="双向认证"></a>双向认证</h4><p><img src="https://www.mszlu.com/assets/1586953-20210625211235069-195172761-16509094417774.1dfd9a90.png" alt="img"></p><p>上面的server.pem和server.key 是服务端的 公钥和私钥。</p><p>如果双向认证，客户端也需要生成对应的公钥和私钥。</p>]]></content>
      
      
      <categories>
          
          <category> RPC </category>
          
          <category> golang </category>
          
      </categories>
      
      
        <tags>
            
            <tag> golang </tag>
            
            <tag> RPC </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>网关</title>
      <link href="/2023/07/03/%E7%BD%91%E5%85%B3/"/>
      <url>/2023/07/03/%E7%BD%91%E5%85%B3/</url>
      
        <content type="html"><![CDATA[<h1 id="网关"><a href="#网关" class="headerlink" title="网关"></a>网关</h1><h2 id="一、什么是网关"><a href="#一、什么是网关" class="headerlink" title="一、什么是网关"></a>一、什么是网关</h2><p>网关(Gateway)又称网间连接器、协议转换器。网关在传输层上以实现网络互连，是最复杂的网络互连设备，仅用于两个高层协议不同的网络互连。</p><h2 id="二、如何来理解网关"><a href="#二、如何来理解网关" class="headerlink" title="二、如何来理解网关"></a>二、如何来理解网关</h2><p>大家都知道，从一个房间走到另一个房间，必然要经过<strong>一扇门</strong>。同样，从一个网络向另一个网络发送信息，也必须经过一道“关口”，这道关口就是网关。顾名思义，网关(Gateway)就是一个网络连接到另一个网络的“<strong>关口</strong>”。</p><p>按照不同的分类标准，网关也有很多种。TCP&#x2F;IP协议里的网关是最常用的，在这里我们所讲的“网关”均指TCP&#x2F;IP协议下的网关。</p><h2 id="三、网关的ip地址"><a href="#三、网关的ip地址" class="headerlink" title="三、网关的ip地址"></a>三、网关的ip地址</h2><p><strong>那么网关到底是什么呢？</strong></p><p>网关实质上是一个网络通向其他网络的IP地址，网关在网段内的可用<strong>ip中选一个</strong>，不过，一般用的是<strong>第1个和最后一个</strong>。</p><p><strong>例如</strong></p><p>比如有网络A和网络B，</p><p><strong>网络A：</strong> 的IP地址范围为“192.168.1.1~192. 168.1.254”，子网掩255.255.255.0；</p><p>如果需要与其它网段通信，那么它的网关可以设置为192.168.1.1，当然也可以设置为<strong>网段内</strong>其它的一个ip地址。</p><p><strong>网络B：</strong> 的IP地址范为“192.168.2.1~192.168.2.254”，子网掩码255.255.255.0。</p><p>如果需要与其它网段通信，那么它的网关可以设置为192.168.2.1，当然也可以设置为<strong>网段内</strong>其它的一个ip地址。</p><h2 id="四、网关是如何实现通信？"><a href="#四、网关是如何实现通信？" class="headerlink" title="四、网关是如何实现通信？"></a>四、网关是如何实现通信？</h2><p>在没有<strong>路由器</strong>的情况下，不同的两个网络之间是<strong>不能</strong>进行TCP&#x2F;IP通信的，即使是两个网络连接在同一台交换机(或集线器)上，TCP&#x2F;IP协议也会根据子网掩码(255.255.255.0)判定两个网络中的主机处在不同的网络里。而要实现这两个网络之间的通信，则<strong>必须通过网关</strong>。</p><p>如果<strong>网络A</strong>中的主机发现<strong>数据包</strong>的目的主机<strong>不在</strong>本地网络中，就把数据包转发给它<strong>自己的网关</strong>，再由网关转发给网络B的网关，网络B的网关再转发给网络B的某个主机(如附图所示)。网络B向网络A转发数据包的过程。</p><p>所以说，只有设置好网关的<strong>IP地址</strong>，TCP&#x2F;IP协议才能实现不同网络之间的相互通信。</p><h2 id="五、什么是默认网关？"><a href="#五、什么是默认网关？" class="headerlink" title="五、什么是默认网关？"></a>五、什么是默认网关？</h2><p>如果搞清了什么是网关，默认网关也就好理解了。就好像一个房间可以有多扇门一样，一台主机可以有多个网关。<strong>默认网关</strong>的意思是一台主机如果找不到可用的网关，就把数据包发给默认<strong>指定的网关</strong>，由这个网关来处理数据包。现在<strong>主机</strong>使用的网关，一般指的是默认网关。</p>]]></content>
      
      
      <categories>
          
          <category> 计算机网络 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 计算机网络 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>icpc夏令营</title>
      <link href="/2023/07/03/icpc%E5%A4%8F%E4%BB%A4%E8%90%A5/"/>
      <url>/2023/07/03/icpc%E5%A4%8F%E4%BB%A4%E8%90%A5/</url>
      
        <content type="html"><![CDATA[<h1 id="Day1"><a href="#Day1" class="headerlink" title="Day1"></a>Day1</h1><p>虽然感觉讲的太基础了，但是还是稍微记一下笔记吧</p><h2 id="基本计数原理"><a href="#基本计数原理" class="headerlink" title="基本计数原理"></a>基本计数原理</h2><ul><li>加法原理</li></ul><p>设A和B是有限集合S的两个互不相交的子集，且AB&#x3D;S，则|S|&#x3D;|A|+|B|。</p><ul><li>乘法原理</li></ul><p> 设A和B是有限集合，|A|&#x3D;p，|B|&#x3D;q，则: |A X B|&#x3D;p X q。</p><h2 id="求和"><a href="#求和" class="headerlink" title="求和"></a>求和</h2><ul><li><p>对于区间$[1, 2k-1]$或$[1, 2k]$，根据等差级数公式，所有奇数的和是$ 1+3+…+(2k-1)&#x3D; \frac {(1+2k-1)k}{2}&#x3D;k^2 $</p></li><li><p>C语言整数除法是舍去小数部分取整，所以，区间[1, n]中所有奇数的和是$(\frac {n+1}{2})^2 $</p></li><li><p>在[a, b]范围内的奇数的和是  $ (\frac {b+1}{2})^2-(\frac {a}{2})^2$</p></li></ul><h2 id="Fibonacci数列"><a href="#Fibonacci数列" class="headerlink" title="Fibonacci数列"></a>Fibonacci数列</h2><ul><li>所有的正整数都可以表示为Fibonacci数列中的数字的和；而且，对于每个正整数，存在若干个不同的集合，每个集合由Fibonacci数列中的数字组成，集合中的数字的和等于该正整数。例如：13可以表示为集合{13}，{5, 8}或{2, 3, 8}中数字的和，17可以表示为集合{1, 3, 13}或{1, 3, 5, 8}中的数字的和。</li></ul><h3 id="定理（Zeckendorf定理，齐肯多夫定理）"><a href="#定理（Zeckendorf定理，齐肯多夫定理）" class="headerlink" title="定理（Zeckendorf定理，齐肯多夫定理）"></a>定理（Zeckendorf定理，齐肯多夫定理）</h3><p>任何正整数都可以表示成若干个不连续的Fibonacci数（不包括第一个Fibonacci数）的和。</p><ul><li>而对于正整数m，这样的和的表达式$m&#x3D; f(n1)+ f(n2)+f(n3)+…+f(nt)$也被称为m的齐肯多夫表示法，由齐肯多夫定理的证明，可以由贪心算法，即通过每次选取小于等于m的最大的Fibonacci数，得到m的齐肯多夫表示法。</li></ul><h1 id="Day2"><a href="#Day2" class="headerlink" title="Day2"></a>Day2</h1><h2 id="最大公因数"><a href="#最大公因数" class="headerlink" title="最大公因数"></a>最大公因数</h2><p>我们把两个数a和b的最大公因数叫做$ gcd(a，b)$.</p><p>b整除a或者a被b整除，记作$a|b$,此时我们吧b叫做a的因数，把a叫做b的倍数，且有性质：<br>$gcd(a,b) &#x3D; gcd(a,b-a)$</p><p>$gcd(a,b) &#x3D; gcd(b,b%a)$</p><h2 id="欧几里得算法"><a href="#欧几里得算法" class="headerlink" title="欧几里得算法"></a><strong>欧几里得算法</strong></h2><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">int</span> <span class="title">gcd</span><span class="params">(<span class="type">int</span> a,<span class="type">int</span> b)</span></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> b==<span class="number">0</span>?a:<span class="built_in">gcd</span>(b,a%b);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="裴蜀定理-拓展欧几里得"><a href="#裴蜀定理-拓展欧几里得" class="headerlink" title="裴蜀定理 拓展欧几里得"></a>裴蜀定理 拓展欧几里得</h3><p>若a，b是整数，且$gcd(a,b)&#x3D;d$，那么对于任意的整数x，y，$ax+by$都一定是d的倍数，特别地，一定存在整数x，y，使$ax+by&#x3D;d$成立</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">int</span> <span class="title">exgcd</span><span class="params">(<span class="type">int</span> a,<span class="type">int</span> b,<span class="type">int</span>&amp; x,<span class="type">int</span>&amp; y)</span></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(b==<span class="number">0</span>)&#123;</span><br><span class="line">        x =<span class="number">1</span>,y=<span class="number">0</span>;</span><br><span class="line">        <span class="keyword">return</span> a;</span><br><span class="line">    &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">        <span class="type">int</span> d=<span class="built_in">exgcd</span>(b,a%b,y,x);</span><br><span class="line">        y=y-a/b*x;</span><br><span class="line">        <span class="keyword">return</span> d;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> ACM算法 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>Git</title>
      <link href="/2023/07/02/Git%E5%85%A5%E9%97%A8/"/>
      <url>/2023/07/02/Git%E5%85%A5%E9%97%A8/</url>
      
        <content type="html"><![CDATA[<h1 id="Git-工作流程"><a href="#Git-工作流程" class="headerlink" title="Git 工作流程"></a>Git 工作流程</h1><p>本章节我们将为大家介绍 Git 的工作流程。</p><p>一般工作流程如下：</p><ul><li>克隆 Git 资源作为工作目录。</li><li>在克隆的资源上添加或修改文件。</li><li>如果其他人修改了，你可以更新资源。</li><li>在提交前查看修改。</li><li>提交修改。</li><li>在修改完成后，如果发现错误，可以撤回提交并再次修改并提交。</li></ul><p>下图展示了 Git 的工作流程：</p><p><img src="https://www.runoob.com/wp-content/uploads/2015/02/git-process.png" alt="img"></p><h1 id="Git-工作区、暂存区和版本库"><a href="#Git-工作区、暂存区和版本库" class="headerlink" title="Git 工作区、暂存区和版本库"></a>Git 工作区、暂存区和版本库</h1><h2 id="基本概念"><a href="#基本概念" class="headerlink" title="基本概念"></a>基本概念</h2><p>我们先来理解下 Git 工作区、暂存区和版本库概念：</p><ul><li><strong>工作区：</strong>就是你在电脑里能看到的目录。</li><li><strong>暂存区：</strong>英文叫 stage 或 index。一般存放在 <strong>.git</strong> 目录下的 index 文件（.git&#x2F;index）中，所以我们把暂存区有时也叫作索引（index）。</li><li><strong>版本库：</strong>工作区有一个隐藏目录 <strong>.git</strong>，这个不算工作区，而是 Git 的版本库。</li></ul><p>下面这个图展示了工作区、版本库中的暂存区和版本库之间的关系：</p><p><img src="https://www.runoob.com/wp-content/uploads/2015/02/1352126739_7909.jpg" alt="img"></p><ul><li>图中左侧为工作区，右侧为版本库。在版本库中标记为 “index” 的区域是暂存区（stage&#x2F;index），标记为 “master” 的是 master 分支所代表的目录树。</li><li>图中我们可以看出此时 “HEAD” 实际是指向 master 分支的一个”游标”。所以图示的命令中出现 HEAD 的地方可以用 master 来替换。</li><li>图中的 objects 标识的区域为 Git 的对象库，实际位于 “.git&#x2F;objects” 目录下，里面包含了创建的各种对象及内容。</li><li>当对工作区修改（或新增）的文件执行 <strong>git add</strong> 命令时，暂存区的目录树被更新，同时工作区修改（或新增）的文件内容被写入到对象库中的一个新的对象中，而该对象的ID被记录在暂存区的文件索引中。</li><li>当执行提交操作（git commit）时，暂存区的目录树写到版本库（对象库）中，master 分支会做相应的更新。即 master 指向的目录树就是提交时暂存区的目录树。</li><li>当执行 <strong>git reset HEAD</strong> 命令时，暂存区的目录树会被重写，被 master 分支指向的目录树所替换，但是工作区不受影响。</li><li>当执行 <strong>git rm –cached <file></file></strong> 命令时，会直接从暂存区删除文件，工作区则不做出改变。</li><li>当执行 <strong>git checkout .</strong> 或者 <strong>git checkout – <file></file></strong> 命令时，会用暂存区全部或指定的文件替换工作区的文件。这个操作很危险，会清除工作区中未添加到暂存区中的改动。</li><li>当执行 <strong>git checkout HEAD .</strong> 或者 <strong>git checkout HEAD <file></file></strong> 命令时，会用 HEAD 指向的 master 分支中的全部或者部分文件替换暂存区和以及工作区中的文件。这个命令也是极具危险性的，因为不但会清除工作区中未提交的改动，也会清除暂存区中未提交的改动。</li></ul><h1 id="Git-创建仓库"><a href="#Git-创建仓库" class="headerlink" title="Git 创建仓库"></a>Git 创建仓库</h1><p>本章节我们将为大家介绍如何创建一个 Git 仓库。</p><p>你可以使用一个已经存在的目录作为 Git 仓库。</p><hr><h2 id="git-init"><a href="#git-init" class="headerlink" title="git init"></a>git init</h2><p>Git 使用 <strong>git init</strong> 命令来初始化一个 Git 仓库，Git 的很多命令都需要在 Git 的仓库中运行，所以 <strong>git init</strong> 是使用 Git 的第一个命令。</p><p>在执行完成 <strong>git init</strong> 命令后，Git 仓库会生成一个 .git 目录，该目录包含了资源的所有元数据，其他的项目目录保持不变。</p><h3 id="使用方法"><a href="#使用方法" class="headerlink" title="使用方法"></a>使用方法</h3><p>使用当前目录作为 Git 仓库，我们只需使它初始化。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git init</span><br></pre></td></tr></table></figure><p>该命令执行完后会在当前目录生成一个 .git 目录。</p><p>使用我们指定目录作为Git仓库。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git init newrepo</span><br></pre></td></tr></table></figure><p>初始化后，会在 newrepo 目录下会出现一个名为 .git 的目录，所有 Git 需要的数据和资源都存放在这个目录中。</p><p>如果当前目录下有几个文件想要纳入版本控制，需要先用 git add 命令告诉 Git 开始对这些文件进行跟踪，然后提交：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">$ git add *.c</span><br><span class="line">$ git add README</span><br><span class="line">$ git commit -m &#x27;初始化项目版本&#x27;</span><br></pre></td></tr></table></figure><p>以上命令将目录下以 .c 结尾及 README 文件提交到仓库中。</p><blockquote><p><strong>注：</strong> 在 Linux 系统中，commit 信息使用单引号 **’**，Windows 系统，commit 信息使用双引号 **”**。</p><p>所以在 git bash 中 <strong>git commit -m ‘提交说明’</strong> 这样是可以的，在 Windows 命令行中就要使用双引号 **git commit -m “提交说明”**。</p></blockquote><hr><h2 id="git-clone"><a href="#git-clone" class="headerlink" title="git clone"></a>git clone</h2><p>我们使用 <strong>git clone</strong> 从现有 Git 仓库中拷贝项目（类似 <strong>svn checkout</strong>）。</p><p>克隆仓库的命令格式为：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git clone &lt;repo&gt;</span><br></pre></td></tr></table></figure><p>如果我们需要克隆到指定的目录，可以使用以下命令格式：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git clone &lt;repo&gt; &lt;directory&gt;</span><br></pre></td></tr></table></figure><p><strong>参数说明：</strong></p><ul><li>**repo:**Git 仓库。</li><li>**directory:**本地目录。</li></ul><p>比如，要克隆 Ruby 语言的 Git 代码仓库 Grit，可以用下面的命令：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ git clone git://github.com/schacon/grit.git</span><br></pre></td></tr></table></figure><p>执行该命令后，会在当前目录下创建一个名为grit的目录，其中包含一个 .git 的目录，用于保存下载下来的所有版本记录。</p><p>如果要自己定义要新建的项目目录名称，可以在上面的命令末尾指定新的名字：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ git clone git://github.com/schacon/grit.git mygrit</span><br></pre></td></tr></table></figure><h2 id="配置"><a href="#配置" class="headerlink" title="配置"></a>配置</h2><p>git 的设置使用 <strong>git config</strong> 命令。</p><p>显示当前的 git 配置信息：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">$ git config --list</span><br><span class="line">credential.helper=osxkeychain</span><br><span class="line">core.repositoryformatversion=0</span><br><span class="line">core.filemode=true</span><br><span class="line">core.bare=false</span><br><span class="line">core.logallrefupdates=true</span><br><span class="line">core.ignorecase=true</span><br><span class="line">core.precomposeunicode=true</span><br></pre></td></tr></table></figure><p>编辑 git 配置文件:</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ git config -e    # 针对当前仓库 </span><br></pre></td></tr></table></figure><p>或者：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ git config -e --global   # 针对系统上所有仓库</span><br></pre></td></tr></table></figure><p>设置提交代码时的用户信息：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">$ git config --global user.name &quot;runoob&quot;</span><br><span class="line">$ git config --global user.email test@runoob.com</span><br></pre></td></tr></table></figure><p>如果去掉 <strong>–global</strong> 参数只对当前仓库有效。</p><h1 id="Git-基本操作"><a href="#Git-基本操作" class="headerlink" title="Git 基本操作"></a>Git 基本操作</h1><p>Git 的工作就是创建和保存你项目的快照及与之后的快照进行对比。</p><p>本章将对有关创建与提交你的项目快照的命令作介绍。</p><p>Git 常用的是以下 6 个命令：<strong>git clone</strong>、<strong>git push</strong>、<strong>git add</strong> 、<strong>git commit</strong>、<strong>git checkout</strong>、<strong>git pull</strong>，后面我们会详细介绍。</p><p><img src="https://www.runoob.com/wp-content/uploads/2015/02/git-command.jpg" alt="img"></p><p><strong>说明：</strong></p><ul><li>workspace：工作区</li><li>staging area：暂存区&#x2F;缓存区</li><li>local repository：版本库或本地仓库</li><li>remote repository：远程仓库</li></ul><p>一个简单的操作步骤：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">$ git init    </span><br><span class="line">$ git add .    </span><br><span class="line">$ git commit  </span><br></pre></td></tr></table></figure><ul><li>git init - 初始化仓库。</li><li>git add . - 添加文件到暂存区。</li><li>git commit - 将暂存区内容添加到仓库中。</li></ul><h3 id="创建仓库命令"><a href="#创建仓库命令" class="headerlink" title="创建仓库命令"></a>创建仓库命令</h3><p>下表列出了 git 创建仓库的命令：</p><table><thead><tr><th align="left">命令</th><th align="left">说明</th></tr></thead><tbody><tr><td align="left"><code>git init</code></td><td align="left">初始化仓库</td></tr><tr><td align="left"><code>git clone</code></td><td align="left">拷贝一份远程仓库，也就是下载一个项目。</td></tr></tbody></table><hr><h2 id="提交与修改"><a href="#提交与修改" class="headerlink" title="提交与修改"></a>提交与修改</h2><p>Git 的工作就是创建和保存你的项目的快照及与之后的快照进行对比。</p><p>下表列出了有关创建与提交你的项目的快照的命令：</p><table><thead><tr><th align="left">命令</th><th align="left">说明</th></tr></thead><tbody><tr><td align="left"><code>git add</code></td><td align="left">添加文件到暂存区</td></tr><tr><td align="left"><code>git status</code></td><td align="left">查看仓库当前的状态，显示有变更的文件。</td></tr><tr><td align="left"><code>git diff</code></td><td align="left">比较文件的不同，即暂存区和工作区的差异。</td></tr><tr><td align="left"><code>git commit</code></td><td align="left">提交暂存区到本地仓库。</td></tr><tr><td align="left"><code>git reset</code></td><td align="left">回退版本。</td></tr><tr><td align="left"><code>git rm</code></td><td align="left">将文件从暂存区和工作区中删除。</td></tr><tr><td align="left"><code>git mv</code></td><td align="left">移动或重命名工作区文件。</td></tr></tbody></table><h3 id="提交日志"><a href="#提交日志" class="headerlink" title="提交日志"></a>提交日志</h3><table><thead><tr><th align="left">命令</th><th align="left">说明</th></tr></thead><tbody><tr><td align="left"><code>git log</code></td><td align="left">查看历史提交记录</td></tr><tr><td align="left"><code>git blame &lt;file&gt;</code></td><td align="left">以列表形式查看指定文件的历史修改记录</td></tr></tbody></table><h3 id="远程操作"><a href="#远程操作" class="headerlink" title="远程操作"></a>远程操作</h3><table><thead><tr><th align="left">命令</th><th align="left">说明</th></tr></thead><tbody><tr><td align="left"><code>git remote</code></td><td align="left">远程仓库操作</td></tr><tr><td align="left"><code>git fetch</code></td><td align="left">从远程获取代码库</td></tr><tr><td align="left"><code>git pull</code></td><td align="left">下载远程代码并合并</td></tr><tr><td align="left"><code>git push</code></td><td align="left">上传远程代码并合并</td></tr></tbody></table><h1 id="Git-分支管理"><a href="#Git-分支管理" class="headerlink" title="Git 分支管理"></a>Git 分支管理</h1><p>几乎每一种版本控制系统都以某种形式支持分支，一个分支代表一条独立的开发线。</p><p>使用分支意味着你可以从开发主线上分离开来，然后在不影响主线的同时继续工作。</p><p><img src="https://static.runoob.com/images/svg/git-brance.svg" alt="img"></p><p>Git 分支实际上是指向更改快照的指针。</p><p>有人把 Git 的分支模型称为<strong>必杀技特性</strong>，而正是因为它，将 <strong>Git</strong> 从版本控制系统家族里区分出来。</p><p>创建分支命令：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git branch (branchname)</span><br></pre></td></tr></table></figure><p>切换分支命令:</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git checkout (branchname)</span><br></pre></td></tr></table></figure><p>当你切换分支的时候，Git 会用该分支的最后提交的快照替换你的工作目录的内容， 所以多个分支不需要多个目录。</p><p>合并分支命令:</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git merge </span><br></pre></td></tr></table></figure><p>你可以多次合并到统一分支， 也可以选择在合并之后直接删除被并入的分支。</p><p>开始前我们先创建一个测试目录：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">$ mkdir gitdemo</span><br><span class="line">$ cd gitdemo/</span><br><span class="line">$ git init</span><br><span class="line">Initialized empty Git repository...</span><br><span class="line">$ touch README</span><br><span class="line">$ git add README</span><br><span class="line">$ git commit -m &#x27;第一次版本提交&#x27;</span><br><span class="line">[master (root-commit) 3b58100] 第一次版本提交</span><br><span class="line"> 1 file changed, 0 insertions(+), 0 deletions(-)</span><br><span class="line"> create mode 100644 README</span><br></pre></td></tr></table></figure><hr><h2 id="Git-分支管理-1"><a href="#Git-分支管理-1" class="headerlink" title="Git 分支管理"></a>Git 分支管理</h2><h3 id="列出分支"><a href="#列出分支" class="headerlink" title="列出分支"></a>列出分支</h3><p>列出分支基本命令：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git branch</span><br></pre></td></tr></table></figure><p>没有参数时，<strong>git branch</strong> 会列出你在本地的分支。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">$ git branch</span><br><span class="line">* master</span><br></pre></td></tr></table></figure><p>此例的意思就是，我们有一个叫做 <strong>master</strong> 的分支，并且该分支是当前分支。</p><p>当你执行 <strong>git init</strong> 的时候，默认情况下 Git 就会为你创建 <strong>master</strong> 分支。</p><p>如果我们要手动创建一个分支。执行 <strong>git branch (branchname)</strong> 即可。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">$ git branch testing</span><br><span class="line">$ git branch</span><br><span class="line">* master</span><br><span class="line">  testing</span><br></pre></td></tr></table></figure><p>现在我们可以看到，有了一个新分支 <strong>testing</strong>。</p><p>当你以此方式在上次提交更新之后创建了新分支，如果后来又有更新提交， 然后又切换到了 <strong>testing</strong> 分支，Git 将还原你的工作目录到你创建分支时候的样子。</p><p>接下来我们将演示如何切换分支，我们用 git checkout (branch) 切换到我们要修改的分支。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">$ ls</span><br><span class="line">README</span><br><span class="line">$ echo &#x27;runoob.com&#x27; &gt; test.txt</span><br><span class="line">$ git add .</span><br><span class="line">$ git commit -m &#x27;add test.txt&#x27;</span><br><span class="line">[master 3e92c19] add test.txt</span><br><span class="line"> 1 file changed, 1 insertion(+)</span><br><span class="line"> create mode 100644 test.txt</span><br><span class="line">$ ls</span><br><span class="line">README        test.txt</span><br><span class="line">$ git checkout testing</span><br><span class="line">Switched to branch &#x27;testing&#x27;</span><br><span class="line">$ ls</span><br><span class="line">README</span><br></pre></td></tr></table></figure><p>当我们切换到 <strong>testing</strong> 分支的时候，我们添加的新文件 test.txt 被移除了。切换回 <strong>master</strong> 分支的时候，它们又重新出现了。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">$ git checkout master</span><br><span class="line">Switched to branch &#x27;master&#x27;</span><br><span class="line">$ ls</span><br><span class="line">README        test.txt</span><br></pre></td></tr></table></figure><p>我们也可以使用 git checkout -b (branchname) 命令来创建新分支并立即切换到该分支下，从而在该分支中操作。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">$ git checkout -b newtest</span><br><span class="line">Switched to a new branch &#x27;newtest&#x27;</span><br><span class="line">$ git rm test.txt </span><br><span class="line">rm &#x27;test.txt&#x27;</span><br><span class="line">$ ls</span><br><span class="line">README</span><br><span class="line">$ touch runoob.php</span><br><span class="line">$ git add .</span><br><span class="line">$ git commit -am &#x27;removed test.txt、add runoob.php&#x27;</span><br><span class="line">[newtest c1501a2] removed test.txt、add runoob.php</span><br><span class="line"> 2 files changed, 1 deletion(-)</span><br><span class="line"> create mode 100644 runoob.php</span><br><span class="line"> delete mode 100644 test.txt</span><br><span class="line">$ ls</span><br><span class="line">README        runoob.php</span><br><span class="line">$ git checkout master</span><br><span class="line">Switched to branch &#x27;master&#x27;</span><br><span class="line">$ ls</span><br><span class="line">README        test.txt</span><br></pre></td></tr></table></figure><p>如你所见，我们创建了一个分支，在该分支上移除了一些文件 test.txt，并添加了 runoob.php 文件，然后切换回我们的主分支，删除的 test.txt 文件又回来了，且新增加的 runoob.php 不存在主分支中。</p><p>使用分支将工作切分开来，从而让我们能够在不同开发环境中做事，并来回切换。</p><h3 id="删除分支"><a href="#删除分支" class="headerlink" title="删除分支"></a>删除分支</h3><p>删除分支命令：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git branch -d (branchname)</span><br></pre></td></tr></table></figure><p>例如我们要删除 testing 分支：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">$ git branch</span><br><span class="line">* master</span><br><span class="line">  testing</span><br><span class="line">$ git branch -d testing</span><br><span class="line">Deleted branch testing (was 85fc7e7).</span><br><span class="line">$ git branch</span><br><span class="line">* master</span><br></pre></td></tr></table></figure><h3 id="分支合并"><a href="#分支合并" class="headerlink" title="分支合并"></a>分支合并</h3><p>一旦某分支有了独立内容，你终究会希望将它合并回到你的主分支。 你可以使用以下命令将任何分支合并到当前分支中去：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">git merge</span><br><span class="line">$ git branch</span><br><span class="line">* master</span><br><span class="line">  newtest</span><br><span class="line">$ ls</span><br><span class="line">README        test.txt</span><br><span class="line">$ git merge newtest</span><br><span class="line">Updating 3e92c19..c1501a2</span><br><span class="line">Fast-forward</span><br><span class="line"> runoob.php | 0</span><br><span class="line"> test.txt   | 1 -</span><br><span class="line"> 2 files changed, 1 deletion(-)</span><br><span class="line"> create mode 100644 runoob.php</span><br><span class="line"> delete mode 100644 test.txt</span><br><span class="line">$ ls</span><br><span class="line">README        runoob.php</span><br></pre></td></tr></table></figure><p>以上实例中我们将 newtest 分支合并到主分支去，test.txt 文件被删除。</p><p>合并完后就可以删除分支:</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">$ git branch -d newtest</span><br><span class="line">Deleted branch newtest (was c1501a2).</span><br></pre></td></tr></table></figure><p>删除后， 就只剩下 master 分支了：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">$ git branch</span><br><span class="line">* master</span><br></pre></td></tr></table></figure><h3 id="合并冲突"><a href="#合并冲突" class="headerlink" title="合并冲突"></a>合并冲突</h3><p>合并并不仅仅是简单的文件添加、移除的操作，Git 也会合并修改。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">$ git branch</span><br><span class="line">* master</span><br><span class="line">$ cat runoob.php</span><br></pre></td></tr></table></figure><p>首先，我们创建一个叫做 change_site 的分支，切换过去，我们将 runoob.php 内容改为:</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">&lt;?php</span><br><span class="line">echo &#x27;runoob&#x27;;</span><br><span class="line">?&gt;</span><br></pre></td></tr></table></figure><p>创建 change_site 分支：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">$ git checkout -b change_site</span><br><span class="line">Switched to a new branch &#x27;change_site&#x27;</span><br><span class="line">$ vim runoob.php</span><br><span class="line">$ head -3 runoob.php</span><br><span class="line">&lt;?php</span><br><span class="line">echo &#x27;runoob&#x27;;</span><br><span class="line">?&gt;</span><br><span class="line">$ git commit -am &#x27;changed the runoob.php&#x27;</span><br><span class="line">[change_site 7774248] changed the runoob.php</span><br><span class="line"> 1 file changed, 3 insertions(+)</span><br><span class="line"> </span><br></pre></td></tr></table></figure><p>将修改的内容提交到 change_site 分支中。 现在，假如切换回 master 分支我们可以看内容恢复到我们修改前的(空文件，没有代码)，我们再次修改 runoob.php 文件。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">$ git checkout master</span><br><span class="line">Switched to branch &#x27;master&#x27;</span><br><span class="line">$ cat runoob.php</span><br><span class="line">$ vim runoob.php    # 修改内容如下</span><br><span class="line">$ cat runoob.php</span><br><span class="line">&lt;?php</span><br><span class="line">echo 1;</span><br><span class="line">?&gt;</span><br><span class="line">$ git diff</span><br><span class="line">diff --git a/runoob.php b/runoob.php</span><br><span class="line">index e69de29..ac60739 100644</span><br><span class="line">--- a/runoob.php</span><br><span class="line">+++ b/runoob.php</span><br><span class="line">@@ -0,0 +1,3 @@</span><br><span class="line">+&lt;?php</span><br><span class="line">+echo 1;</span><br><span class="line">+?&gt;</span><br><span class="line">$ git commit -am &#x27;修改代码&#x27;</span><br><span class="line">[master c68142b] 修改代码</span><br><span class="line"> 1 file changed, 3 insertions(+)</span><br></pre></td></tr></table></figure><p>现在这些改变已经记录到我的 “master” 分支了。接下来我们将 “change_site” 分支合并过来。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">$ git merge change_site</span><br><span class="line">Auto-merging runoob.php</span><br><span class="line">CONFLICT (content): Merge conflict in runoob.php</span><br><span class="line">Automatic merge failed; fix conflicts and then commit the result.</span><br><span class="line"></span><br><span class="line">$ cat runoob.php     # 打开文件，看到冲突内容</span><br><span class="line">&lt;?php</span><br><span class="line">&lt;&lt;&lt;&lt;&lt;&lt;&lt; HEAD</span><br><span class="line">echo 1;</span><br><span class="line">=======</span><br><span class="line">echo &#x27;runoob&#x27;;</span><br><span class="line">&gt;&gt;&gt;&gt;&gt;&gt;&gt; change_site</span><br><span class="line">?&gt;</span><br></pre></td></tr></table></figure><p>我们将前一个分支合并到 master 分支，一个合并冲突就出现了，接下来我们需要手动去修改它。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">$ vim runoob.php </span><br><span class="line">$ cat runoob.php</span><br><span class="line">&lt;?php</span><br><span class="line">echo 1;</span><br><span class="line">echo &#x27;runoob&#x27;;</span><br><span class="line">?&gt;</span><br><span class="line">$ git diff</span><br><span class="line">diff --cc runoob.php</span><br><span class="line">index ac60739,b63d7d7..0000000</span><br><span class="line">--- a/runoob.php</span><br><span class="line">+++ b/runoob.php</span><br><span class="line">@@@ -1,3 -1,3 +1,4 @@@</span><br><span class="line">  &lt;?php</span><br><span class="line"> +echo 1;</span><br><span class="line">+ echo &#x27;runoob&#x27;;</span><br><span class="line">  ?&gt;</span><br></pre></td></tr></table></figure><p>在 Git 中，我们可以用 git add 要告诉 Git 文件冲突已经解决</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">$ git status -s</span><br><span class="line">UU runoob.php</span><br><span class="line">$ git add runoob.php</span><br><span class="line">$ git status -s</span><br><span class="line">M  runoob.php</span><br><span class="line">$ git commit</span><br><span class="line">[master 88afe0e] Merge branch &#x27;change_site&#x27;</span><br></pre></td></tr></table></figure><p>现在我们成功解决了合并中的冲突，并提交了结果。</p><h1 id="Git-查看提交历史"><a href="#Git-查看提交历史" class="headerlink" title="Git 查看提交历史"></a>Git 查看提交历史</h1><p> Git 提交历史一般常用两个命令：</p><ul><li><p><strong>git log</strong> - 查看历史提交记录。</p></li><li><p><strong>git blame <file></file></strong> - 以列表形式查看指定文件的历史修改记录。</p></li></ul><h2 id="git-log"><a href="#git-log" class="headerlink" title="git log"></a>git log</h2><p>在使用 Git 提交了若干更新之后，又或者克隆了某个项目，想回顾下提交历史，我们可以使用 <strong>git log</strong> 命令查看。</p><p><strong>git log</strong> 命令用于查看 Git 仓库中提交历史记录。</p><p><strong>git log</strong> 显示了从最新提交到最早提交的所有提交信息，包括提交的哈希值、作者、提交日期和提交消息等。</p><p><strong>git log</strong> 命令的基本语法：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git log [选项] [分支名/提交哈希]</span><br></pre></td></tr></table></figure><p>常用的选项包括：</p><ul><li><p><code>-p</code>：显示提交的补丁（具体更改内容）。</p></li><li><p><code>--oneline</code>：以简洁的一行格式显示提交信息。</p></li></ul><ul><li><code>--graph</code>：以图形化方式显示分支和合并历史。</li><li><code>--decorate</code>：显示分支和标签指向的提交。</li><li><code>--author=&lt;作者&gt;</code>：只显示特定作者的提交。</li><li><code>--since=&lt;时间&gt;</code>：只显示指定时间之后的提交。</li><li><code>--until=&lt;时间&gt;</code>：只显示指定时间之前的提交。</li><li><code>--grep=&lt;模式&gt;</code>：只显示包含指定模式的提交消息。</li><li><code>--no-merges</code>：不显示合并提交。</li><li><code>--stat</code>：显示简略统计信息，包括修改的文件和行数。</li><li><code>--abbrev-commit</code>：使用短提交哈希值。</li><li><code>--pretty=&lt;格式&gt;</code>：使用自定义的提交信息显示格式。</li></ul><p>针对我们前一章节的操作，使用 <strong>git log</strong> 命令列出历史提交记录如下：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">$ git log</span><br><span class="line">commit d5e9fc2c811e0ca2b2d28506ef7dc14171a207d9 (HEAD -&gt; master)</span><br><span class="line">Merge: c68142b 7774248</span><br><span class="line">Author: runoob &lt;test@runoob.com&gt;</span><br><span class="line">Date:   Fri May 3 15:55:58 2019 +0800</span><br><span class="line"></span><br><span class="line">    Merge branch &#x27;change_site&#x27;</span><br><span class="line"></span><br><span class="line">commit c68142b562c260c3071754623b08e2657b4c6d5b</span><br><span class="line">Author: runoob &lt;test@runoob.com&gt;</span><br><span class="line">Date:   Fri May 3 15:52:12 2019 +0800</span><br><span class="line"></span><br><span class="line">    修改代码</span><br><span class="line"></span><br><span class="line">commit 777424832e714cf65d3be79b50a4717aea51ab69 (change_site)</span><br><span class="line">Author: runoob &lt;test@runoob.com&gt;</span><br><span class="line">Date:   Fri May 3 15:49:26 2019 +0800</span><br><span class="line"></span><br><span class="line">    changed the runoob.php</span><br><span class="line"></span><br><span class="line">commit c1501a244676ff55e7cccac1ecac0e18cbf6cb00</span><br><span class="line">Author: runoob &lt;test@runoob.com&gt;</span><br><span class="line">Date:   Fri May 3 15:35:32 2019 +0800</span><br></pre></td></tr></table></figure><p>我们可以用 –oneline 选项来查看历史记录的简洁的版本。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">$ git log --oneline</span><br><span class="line">$ git log --oneline</span><br><span class="line">d5e9fc2 (HEAD -&gt; master) Merge branch &#x27;change_site&#x27;</span><br><span class="line">c68142b 修改代码</span><br><span class="line">7774248 (change_site) changed the runoob.php</span><br><span class="line">c1501a2 removed test.txt、add runoob.php</span><br><span class="line">3e92c19 add test.txt</span><br><span class="line">3b58100 第一次版本提交</span><br></pre></td></tr></table></figure><p>这告诉我们的是，此项目的开发历史。</p><p>我们还可以用 –graph 选项，查看历史中什么时候出现了分支、合并。以下为相同的命令，开启了拓扑图选项：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">*   d5e9fc2 (HEAD -&gt; master) Merge branch &#x27;change_site&#x27;</span><br><span class="line">|\  </span><br><span class="line">| * 7774248 (change_site) changed the runoob.php</span><br><span class="line">* | c68142b 修改代码</span><br><span class="line">|/  </span><br><span class="line">* c1501a2 removed test.txt、add runoob.php</span><br><span class="line">* 3e92c19 add test.txt</span><br><span class="line">* 3b58100 第一次版本提交</span><br></pre></td></tr></table></figure><p>现在我们可以更清楚明了地看到何时工作分叉、又何时归并。</p><p>你也可以用 <strong>–reverse</strong> 参数来逆向显示所有日志。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">$ git log --reverse --oneline</span><br><span class="line">3b58100 第一次版本提交</span><br><span class="line">3e92c19 add test.txt</span><br><span class="line">c1501a2 removed test.txt、add runoob.php</span><br><span class="line">7774248 (change_site) changed the runoob.php</span><br><span class="line">c68142b 修改代码</span><br><span class="line">d5e9fc2 (HEAD -&gt; master) Merge branch &#x27;change_site&#x27;</span><br></pre></td></tr></table></figure><p>如果只想查找指定用户的提交日志可以使用命令：git log –author , 例如，比方说我们要找 Git 源码中 Linus 提交的部分：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">$ git log --author=Linus --oneline -5</span><br><span class="line">81b50f3 Move &#x27;builtin-*&#x27; into a &#x27;builtin/&#x27; subdirectory</span><br><span class="line">3bb7256 make &quot;index-pack&quot; a built-in</span><br><span class="line">377d027 make &quot;git pack-redundant&quot; a built-in</span><br><span class="line">b532581 make &quot;git unpack-file&quot; a built-in</span><br><span class="line">112dd51 make &quot;mktag&quot; a built-in</span><br></pre></td></tr></table></figure><p>如果你要指定日期，可以执行几个选项：–since 和 –before，但是你也可以用 –until 和 –after。</p><p>例如，如果我要看 Git 项目中三周前且在四月十八日之后的所有提交，我可以执行这个（我还用了 –no-merges 选项以隐藏合并提交）：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">$ git log --oneline --before=&#123;3.weeks.ago&#125; --after=&#123;2010-04-18&#125; --no-merges</span><br><span class="line">5469e2d Git 1.7.1-rc2</span><br><span class="line">d43427d Documentation/remote-helpers: Fix typos and improve language</span><br><span class="line">272a36b Fixup: Second argument may be any arbitrary string</span><br><span class="line">b6c8d2d Documentation/remote-helpers: Add invocation section</span><br><span class="line">5ce4f4e Documentation/urls: Rewrite to accomodate transport::address</span><br><span class="line">00b84e9 Documentation/remote-helpers: Rewrite description</span><br><span class="line">03aa87e Documentation: Describe other situations where -z affects git diff</span><br><span class="line">77bc694 rebase-interactive: silence warning when no commits rewritten</span><br><span class="line">636db2c t3301: add tests to use --format=&quot;%N&quot;</span><br></pre></td></tr></table></figure><p>更多 <strong>git log</strong> 命令可查看 <a href="http://git-scm.com/docs/git-log">http://git-scm.com/docs/git-log</a> 或使用 <strong>git log –help</strong> 命令查看帮助信息。</p><h2 id="git-blame"><a href="#git-blame" class="headerlink" title="git blame"></a>git blame</h2><p><strong>git blame</strong> 命令用于逐行显示指定文件的每一行代码是由谁在什么时候引入或修改的。</p><p>strong&gt;git blame 可以追踪文件中每一行的变更历史，包括作者、提交哈希、提交日期和提交消息等信息。</p><p>如果要查看指定文件的修改记录可以使用 git blame 命令，格式如下：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git blame [选项] &lt;文件路径&gt;</span><br></pre></td></tr></table></figure><p>常用的选项包括：</p><ul><li><code>-L &lt;起始行号&gt;,&lt;结束行号&gt;</code>：只显示指定行号范围内的代码注释。</li></ul><ul><li><code>-C</code>：对于重命名或拷贝的代码行，也进行代码行溯源。</li><li><code>-M</code>：对于移动的代码行，也进行代码行溯源。</li><li><code>-C -C</code> 或 <code>-M -M</code>：对于较多改动的代码行，进行更进一步的溯源。</li><li><code>--show-stats</code>：显示包含每个作者的行数统计信息。</li></ul><p>显示文件每一行的代码注释和相关信息：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git blame &lt;文件路径&gt;</span><br></pre></td></tr></table></figure><p>只显示指定行号范围内的代码注释：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git blame -L &lt;起始行号&gt;,&lt;结束行号&gt; &lt;文件路径&gt;</span><br></pre></td></tr></table></figure><p>对于重命名或拷贝的代码行进行溯源：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git blame -C &lt;文件路径&gt;</span><br></pre></td></tr></table></figure><p>对于移动的代码行进行溯源：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git blame -M &lt;文件路径&gt;</span><br></pre></td></tr></table></figure><p>显示行数统计信息：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git blame --show-stats &lt;文件路径&gt;</span><br></pre></td></tr></table></figure><p>git blame 命令是以列表形式显示修改记录，如下实例：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">$ git blame README </span><br><span class="line">^d2097aa (tianqixin 2020-08-25 14:59:25 +0800 1) # Runoob Git 测试</span><br><span class="line">db9315b0 (runoob    2020-08-25 16:00:23 +0800 2) # 菜鸟教程 </span><br></pre></td></tr></table></figure><p>更多内容可以使用 <strong>git blame –help</strong> 查看完整的帮助文档，了解更多选项和使用方式。</p><h1 id="Git-标签"><a href="#Git-标签" class="headerlink" title="Git 标签"></a>Git 标签</h1><p>如果你达到一个重要的阶段，并希望永远记住那个特别的提交快照，你可以使用 git tag 给它打上标签。</p><p>比如说，我们想为我们的 runoob 项目发布一个”1.0”版本。 我们可以用 git tag -a v1.0 命令给最新一次提交打上（HEAD）”v1.0”的标签。</p><p>-a 选项意为”创建一个带注解的标签”。 不用 -a 选项也可以执行的，但它不会记录这标签是啥时候打的，谁打的，也不会让你添加个标签的注解。 我推荐一直创建带注解的标签。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ git tag -a v1.0 </span><br></pre></td></tr></table></figure><p>当你执行 git tag -a 命令时，Git 会打开你的编辑器，让你写一句标签注解，就像你给提交写注解一样。</p><p>现在，注意当我们执行 git log –decorate 时，我们可以看到我们的标签了：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">*   d5e9fc2 (HEAD -&gt; master) Merge branch &#x27;change_site&#x27;</span><br><span class="line">|\  </span><br><span class="line">| * 7774248 (change_site) changed the runoob.php</span><br><span class="line">* | c68142b 修改代码</span><br><span class="line">|/  </span><br><span class="line">* c1501a2 removed test.txt、add runoob.php</span><br><span class="line">* 3e92c19 add test.txt</span><br><span class="line">* 3b58100 第一次版本提交</span><br></pre></td></tr></table></figure><p>如果我们忘了给某个提交打标签，又将它发布了，我们可以给它追加标签。</p><p>例如，假设我们发布了提交 85fc7e7(上面实例最后一行)，但是那时候忘了给它打标签。 我们现在也可以：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">$ git tag -a v0.9 85fc7e7</span><br><span class="line">$ git log --oneline --decorate --graph</span><br><span class="line">*   d5e9fc2 (HEAD -&gt; master) Merge branch &#x27;change_site&#x27;</span><br><span class="line">|\  </span><br><span class="line">| * 7774248 (change_site) changed the runoob.php</span><br><span class="line">* | c68142b 修改代码</span><br><span class="line">|/  </span><br><span class="line">* c1501a2 removed test.txt、add runoob.php</span><br><span class="line">* 3e92c19 add test.txt</span><br><span class="line">* 3b58100 (tag: v0.9) 第一次版本提交</span><br></pre></td></tr></table></figure><p>如果我们要查看所有标签可以使用以下命令：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">$ git tag</span><br><span class="line">v0.9</span><br><span class="line">v1.0</span><br></pre></td></tr></table></figure><p>指定标签信息命令：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git tag -a &lt;tagname&gt; -m &quot;runoob.com标签&quot;</span><br></pre></td></tr></table></figure><p>PGP签名标签命令：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git tag -s &lt;tagname&gt; -m &quot;runoob.com标签&quot;</span><br></pre></td></tr></table></figure><h1 id="Git-远程仓库-Github-remote"><a href="#Git-远程仓库-Github-remote" class="headerlink" title="Git 远程仓库(Github)remote"></a>Git 远程仓库(Github)remote</h1><p>Git 并不像 SVN 那样有个中心服务器。</p><p>目前我们使用到的 Git 命令都是在本地执行，如果你想通过 Git 分享你的代码或者与其他开发人员合作。 你就需要将数据放到一台其他开发人员能够连接的服务器上。</p><p>本例使用了 Github 作为远程仓库，你可以先阅读我们的 <a href="https://www.runoob.com/w3cnote/git-guide.html">Github 简明教程。</a></p><p><img src="https://www.runoob.com/wp-content/uploads/2015/03/Git-push-command.jpeg" alt="img"></p><hr><h2 id="添加远程库"><a href="#添加远程库" class="headerlink" title="添加远程库"></a>添加远程库</h2><p>要添加一个新的远程仓库，可以指定一个简单的名字，以便将来引用,命令格式如下：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git remote add [shortname] [url]</span><br></pre></td></tr></table></figure><p>本例以 Github 为例作为远程仓库，如果你没有 Github 可以在官网 <a href="https://github.com/%E6%B3%A8%E5%86%8C%E3%80%82">https://github.com/注册。</a></p><p>由于你的本地 Git 仓库和 GitHub 仓库之间的传输是通过SSH加密的，所以我们需要配置验证信息：</p><p>使用以下命令生成 SSH Key：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ ssh-keygen -t rsa -C &quot;youremail@example.com&quot;</span><br></pre></td></tr></table></figure><p>后面的 <strong><a href="mailto:&#121;&#x6f;&#117;&#114;&#x5f;&#x65;&#x6d;&#97;&#x69;&#108;&#x40;&#x79;&#111;&#x75;&#114;&#101;&#x6d;&#97;&#x69;&#x6c;&#46;&#x63;&#x6f;&#x6d;">&#121;&#x6f;&#117;&#114;&#x5f;&#x65;&#x6d;&#97;&#x69;&#108;&#x40;&#x79;&#111;&#x75;&#114;&#101;&#x6d;&#97;&#x69;&#x6c;&#46;&#x63;&#x6f;&#x6d;</a></strong> 改为你在 Github 上注册的邮箱，之后会要求确认路径和输入密码，我们这使用默认的一路回车就行。</p><p>成功的话会在 <strong>~&#x2F;</strong> 下生成 <strong>.ssh</strong> 文件夹，进去，打开 <strong>id_rsa.pub</strong>，复制里面的 <strong>key</strong>。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">$ ssh-keygen -t rsa -C &quot;429240967@qq.com&quot;</span><br><span class="line">Generating public/private rsa key pair.</span><br><span class="line">Enter file in which to save the key (/Users/tianqixin/.ssh/id_rsa): </span><br><span class="line">Enter passphrase (empty for no passphrase):    # 直接回车</span><br><span class="line">Enter same passphrase again:                   # 直接回车</span><br><span class="line">Your identification has been saved in /Users/tianqixin/.ssh/id_rsa.</span><br><span class="line">Your public key has been saved in /Users/tianqixin/.ssh/id_rsa.pub.</span><br><span class="line">The key fingerprint is:</span><br><span class="line">SHA256:MDKVidPTDXIQoJwoqUmI4LBAsg5XByBlrOEzkxrwARI 429240967@qq.com</span><br><span class="line">The key&#x27;s randomart image is:</span><br><span class="line">+---[RSA 3072]----+</span><br><span class="line">|E*+.+=**oo       |</span><br><span class="line">|%Oo+oo=o. .      |</span><br><span class="line">|%**.o.o.         |</span><br><span class="line">|OO.  o o         |</span><br><span class="line">|+o+     S        |</span><br><span class="line">|.                |</span><br><span class="line">|                 |</span><br><span class="line">|                 |</span><br><span class="line">|                 |</span><br><span class="line">+----[SHA256]-----+</span><br></pre></td></tr></table></figure><p>回到 github 上，进入 Account &#x3D;&gt; Settings（账户配置）。</p><p><img src="https://www.runoob.com/wp-content/uploads/2015/03/48840BF0-992F-4CCC-A388-15CB74819D88.jpg" alt="img"></p><p>左边选择 <strong>SSH and GPG keys</strong>，然后点击 <strong>New SSH key</strong> 按钮,title 设置标题，可以随便填，粘贴在你电脑上生成的 key。</p><p><img src="https://www.runoob.com/wp-content/uploads/2015/03/B0589847-A498-4415-8700-252BDE1B20C0.jpg" alt="img"></p><p><img src="https://www.runoob.com/wp-content/uploads/2015/03/106AD534-A38A-47F3-88A3-B7BE3F2FEEF1.jpg" alt="img"></p><p>添加成功后界面如下所示</p><p><img src="https://www.runoob.com/wp-content/uploads/2015/03/EC8F8872-091A-4CAB-90F2-616F34F350A9.jpg" alt="img"></p><p>为了验证是否成功，输入以下命令：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">$ ssh -T git@github.com</span><br><span class="line">The authenticity of host &#x27;github.com (52.74.223.119)&#x27; can&#x27;t be established.</span><br><span class="line">RSA key fingerprint is SHA256:nThbg6kXUpJWGl7E1IGOCspRomTxdCARLviKw6E5SY8.</span><br><span class="line">Are you sure you want to continue connecting (yes/no/[fingerprint])? yes                   # 输入 yes</span><br><span class="line">Warning: Permanently added &#x27;github.com,52.74.223.119&#x27; (RSA) to the list of known hosts.</span><br><span class="line">Hi tianqixin! You&#x27;ve successfully authenticated, but GitHub does not provide shell access. # 成功信息</span><br></pre></td></tr></table></figure><p>以下命令说明我们已成功连上 Github。</p><p>之后登录后点击” New repository “ 如下图所示：</p><p><img src="https://www.runoob.com/wp-content/uploads/2015/03/github1.jpg" alt="img"></p><p>之后在在Repository name 填入 runoob-git-test(远程仓库名) ，其他保持默认设置，点击”Create repository”按钮，就成功地创建了一个新的Git仓库：</p><p><img src="https://www.runoob.com/wp-content/uploads/2015/03/299CF000-7B6E-4BEC-B8C2-D9AEB053307B.jpg" alt="img"></p><p>创建成功后，显示如下信息：</p><p><img src="https://www.runoob.com/wp-content/uploads/2015/03/1BCB4379-1A25-4C77-BB82-92B3E7185435.jpg" alt="img"></p><p>以上信息告诉我们可以从这个仓库克隆出新的仓库，也可以把本地仓库的内容推送到GitHub仓库。</p><p>现在，我们根据 GitHub 的提示，在本地的仓库下运行命令：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">$ mkdir runoob-git-test                     # 创建测试目录</span><br><span class="line">$ cd runoob-git-test/                       # 进入测试目录</span><br><span class="line">$ echo &quot;# 菜鸟教程 Git 测试&quot; &gt;&gt; README.md     # 创建 README.md 文件并写入内容</span><br><span class="line">$ ls                                        # 查看目录下的文件</span><br><span class="line">README</span><br><span class="line">$ git init                                  # 初始化</span><br><span class="line">$ git add README.md                         # 添加文件</span><br><span class="line">$ git commit -m &quot;添加 README.md 文件&quot;        # 提交并备注信息</span><br><span class="line">[master (root-commit) 0205aab] 添加 README.md 文件</span><br><span class="line"> 1 file changed, 1 insertion(+)</span><br><span class="line"> create mode 100644 README.md</span><br><span class="line"></span><br><span class="line"># 提交到 Github</span><br><span class="line">$ git remote add origin git@github.com:tianqixin/runoob-git-test.git</span><br><span class="line">$ git push -u origin master</span><br></pre></td></tr></table></figure><p>以下命令请根据你在Github成功创建新仓库的地方复制，而不是根据我提供的命令，因为我们的Github用户名不一样，仓库名也不一样。</p><p>接下来我们返回 Github 创建的仓库，就可以看到文件已上传到 Github上：</p><p><img src="https://www.runoob.com/wp-content/uploads/2015/03/53CA927D-F36F-4A00-AFB2-5EAED05B535E.jpg" alt="img"></p><hr><h2 id="查看当前的远程库"><a href="#查看当前的远程库" class="headerlink" title="查看当前的远程库"></a>查看当前的远程库</h2><p>要查看当前配置有哪些远程仓库，可以用命令：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git remote</span><br></pre></td></tr></table></figure><h3 id="实例"><a href="#实例" class="headerlink" title="实例"></a>实例</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">$ git remote</span><br><span class="line">origin</span><br><span class="line">$ git remote -v</span><br><span class="line">origin    git@github.com:tianqixin/runoob-git-test.git (fetch)</span><br><span class="line">origin    git@github.com:tianqixin/runoob-git-test.git (push)</span><br></pre></td></tr></table></figure><p>执行时加上 -v 参数，你还可以看到每个别名的实际链接地址。</p><hr><h2 id="提取远程仓库"><a href="#提取远程仓库" class="headerlink" title="提取远程仓库"></a>提取远程仓库</h2><p>Git 有两个命令用来提取远程仓库的更新。</p><p>1、从远程仓库下载新分支与数据：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git fetch</span><br></pre></td></tr></table></figure><p>该命令执行完后需要执行 git merge 远程分支到你所在的分支。</p><p>2、从远端仓库提取数据并尝试合并到当前分支：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git merge</span><br></pre></td></tr></table></figure><p>该命令就是在执行 <strong>git fetch</strong> 之后紧接着执行 <strong>git merge</strong> 远程分支到你所在的任意分支。</p><p><img src="https://www.runoob.com/wp-content/uploads/2015/03/main-qimg-00a6b5a8ec82400657444504c4d4d1a7.png" alt="img"></p><p>假设你配置好了一个远程仓库，并且你想要提取更新的数据，你可以首先执行 <strong>git fetch [alias]</strong> 告诉 Git 去获取它有你没有的数据，然后你可以执行 <strong>git merge [alias]&#x2F;[branch]</strong> 以将服务器上的任何更新（假设有人这时候推送到服务器了）合并到你的当前分支。</p><p>接下来我们在 Github 上点击” README.md” 并在线修改它:</p><p><img src="https://www.runoob.com/wp-content/uploads/2015/03/C5A6670F-202D-4F2C-8A63-07CEA37BB67A.jpg" alt="img"></p><p>然后我们在本地更新修改。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">$ git fetch origin</span><br><span class="line">remote: Counting objects: 3, done.</span><br><span class="line">remote: Compressing objects: 100% (2/2), done.</span><br><span class="line">remote: Total 3 (delta 0), reused 0 (delta 0), pack-reused 0</span><br><span class="line">Unpacking objects: 100% (3/3), done.</span><br><span class="line">From github.com:tianqixin/runoob-git-test</span><br><span class="line">   0205aab..febd8ed  master     -&gt; origin/master</span><br></pre></td></tr></table></figure><p>以上信息”0205aab..febd8ed master -&gt; origin&#x2F;master” 说明 master 分支已被更新，我们可以使用以下命令将更新同步到本地：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">$ git merge origin/master</span><br><span class="line">Updating 0205aab..febd8ed</span><br><span class="line">Fast-forward</span><br><span class="line"> README.md | 1 +</span><br><span class="line"> 1 file changed, 1 insertion(+)</span><br></pre></td></tr></table></figure><p>查看 README.md 文件内容：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">$ cat README.md </span><br><span class="line"># 菜鸟教程 Git 测试</span><br><span class="line">## 第一次修改内容</span><br></pre></td></tr></table></figure><hr><h2 id="推送到远程仓库"><a href="#推送到远程仓库" class="headerlink" title="推送到远程仓库"></a>推送到远程仓库</h2><p>推送你的新分支与数据到某个远端仓库命令:</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git push [alias] [branch]</span><br></pre></td></tr></table></figure><p>以上命令将你的 [branch] 分支推送成为 [alias] 远程仓库上的 [branch] 分支，实例如下。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">$ touch runoob-test.txt      # 添加文件</span><br><span class="line">$ git add runoob-test.txt </span><br><span class="line">$ git commit -m &quot;添加到远程&quot;</span><br><span class="line">master 69e702d] 添加到远程</span><br><span class="line"> 1 file changed, 0 insertions(+), 0 deletions(-)</span><br><span class="line"> create mode 100644 runoob-test.txt</span><br><span class="line"></span><br><span class="line">$ git push origin master    # 推送到 Github</span><br></pre></td></tr></table></figure><p>重新回到我们的 Github 仓库，可以看到文件已经提交上来了：</p><p><img src="https://www.runoob.com/wp-content/uploads/2015/03/79A84530-7DC0-4D25-9F83-8776433A4C32.jpg" alt="img"></p><hr><h2 id="删除远程仓库"><a href="#删除远程仓库" class="headerlink" title="删除远程仓库"></a>删除远程仓库</h2><p>删除远程仓库你可以使用命令：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git remote rm [别名]</span><br></pre></td></tr></table></figure><h3 id="实例-1"><a href="#实例-1" class="headerlink" title="实例"></a>实例</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">$ git remote -v</span><br><span class="line">origin    git@github.com:tianqixin/runoob-git-test.git (fetch)</span><br><span class="line">origin    git@github.com:tianqixin/runoob-git-test.git (push)</span><br><span class="line"></span><br><span class="line"># 添加仓库 origin2</span><br><span class="line">$ git remote add origin2 git@github.com:tianqixin/runoob-git-test.git</span><br><span class="line"></span><br><span class="line">$ git remote -v</span><br><span class="line">origin    git@github.com:tianqixin/runoob-git-test.git (fetch)</span><br><span class="line">origin    git@github.com:tianqixin/runoob-git-test.git (push)</span><br><span class="line">origin2    git@github.com:tianqixin/runoob-git-test.git (fetch)</span><br><span class="line">origin2    git@github.com:tianqixin/runoob-git-test.git (push)</span><br><span class="line"></span><br><span class="line"># 删除仓库 origin2</span><br><span class="line">$ git remote rm origin2</span><br><span class="line">$ git remote -v</span><br><span class="line">origin    git@github.com:tianqixin/runoob-git-test.git (fetch)</span><br><span class="line">origin    git@github.com:tianqixin/runoob-git-test.git (push)</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> Git </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Git </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Gorm</title>
      <link href="/2023/07/02/Gorm/"/>
      <url>/2023/07/02/Gorm/</url>
      
        <content type="html"><![CDATA[<h1 id="Grom建立连接和表的基本操作"><a href="#Grom建立连接和表的基本操作" class="headerlink" title="Grom建立连接和表的基本操作"></a>Grom建立连接和表的基本操作</h1><h2 id="安装Gorm"><a href="#安装Gorm" class="headerlink" title="安装Gorm"></a>安装Gorm</h2><p>安装gorm工具和mysql驱动：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">go</span> get -u gorm.io/gorm</span><br><span class="line"><span class="keyword">go</span> get -u gorm.io/driver/sqlite</span><br></pre></td></tr></table></figure><h2 id="连接数据库"><a href="#连接数据库" class="headerlink" title="连接数据库"></a>连接数据库</h2><ul><li>使用mysql.Open()启动数据库</li></ul><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> (</span><br><span class="line"><span class="string">&quot;fmt&quot;</span></span><br><span class="line"><span class="string">&quot;gorm.io/driver/mysql&quot;</span></span><br><span class="line"><span class="string">&quot;gorm.io/gorm&quot;</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">dsn := <span class="string">&quot;root:qq31415926535--@tcp(localhost:3306)/test?charset=utf8mb4&amp;parseTime=True&amp;loc=Local&quot;</span></span><br><span class="line">db, _ := gorm.Open(mysql.Open(dsn), &amp;gorm.Config&#123;&#125;)</span><br><span class="line">fmt.Println(db)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>MySQL 驱动程序提供了 <a href="https://github.com/go-gorm/mysql">一些高级配置</a> 可以在初始化过程中使用，例如：</li></ul><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">db, err := gorm.Open(mysql.New(mysql.Config&#123;</span><br><span class="line">  DSN: <span class="string">&quot;gorm:gorm@tcp(127.0.0.1:3306)/gorm?charset=utf8&amp;parseTime=True&amp;loc=Local&quot;</span>, <span class="comment">// DSN data source name</span></span><br><span class="line">  DefaultStringSize: <span class="number">256</span>, <span class="comment">// string 类型字段的默认长度</span></span><br><span class="line">  DisableDatetimePrecision: <span class="literal">true</span>, <span class="comment">// 禁用 datetime 精度，MySQL 5.6 之前的数据库不支持</span></span><br><span class="line">  DontSupportRenameIndex: <span class="literal">true</span>, <span class="comment">// 重命名索引时采用删除并新建的方式，MySQL 5.7 之前的数据库和 MariaDB 不支持重命名索引</span></span><br><span class="line">  DontSupportRenameColumn: <span class="literal">true</span>, <span class="comment">// 用 `change` 重命名列，MySQL 8 之前的数据库和 MariaDB 不支持重命名列</span></span><br><span class="line">  SkipInitializeWithVersion: <span class="literal">false</span>, <span class="comment">// 根据当前 MySQL 版本自动配置</span></span><br><span class="line">&#125;), &amp;gorm.Config&#123;&#125;)</span><br></pre></td></tr></table></figure><p>在实际开发中，我们通常采用这种形式连接到mysql，在mysql，gorm的Config配置中详细配置。</p><ul><li>gorm.Config配置</li></ul><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> Config <span class="keyword">struct</span> &#123;</span><br><span class="line">  SkipDefaultTransaction   <span class="type">bool</span><span class="comment">//跳过默认事务，一般配置为false</span></span><br><span class="line">  NamingStrategy           schema.Namer<span class="comment">//命名策略</span></span><br><span class="line">  Logger                   logger.Interface</span><br><span class="line">  NowFunc                  <span class="function"><span class="keyword">func</span><span class="params">()</span></span> time.Time</span><br><span class="line">  DryRun                   <span class="type">bool</span></span><br><span class="line">  PrepareStmt              <span class="type">bool</span></span><br><span class="line">  DisableNestedTransaction <span class="type">bool</span></span><br><span class="line">  AllowGlobalUpdate        <span class="type">bool</span></span><br><span class="line">  DisableAutomaticPing     <span class="type">bool</span></span><br><span class="line">  DisableForeignKeyConstraintWhenMigrating <span class="type">bool</span><span class="comment">//创立这个表的时候是否要建立外键约束</span></span><br><span class="line">    <span class="comment">//逻辑外键（在代码里自动体现外键关系）</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>GORM 允许用户通过覆盖默认的<code>NamingStrategy</code>来更改命名约定，这需要实现接口 <code>Namer</code></p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> Namer <span class="keyword">interface</span> &#123;</span><br><span class="line">    TableName(table <span class="type">string</span>) <span class="type">string</span></span><br><span class="line">    SchemaName(table <span class="type">string</span>) <span class="type">string</span></span><br><span class="line">    ColumnName(table, column <span class="type">string</span>) <span class="type">string</span></span><br><span class="line">    JoinTableName(table <span class="type">string</span>) <span class="type">string</span></span><br><span class="line">    RelationshipFKName(Relationship) <span class="type">string</span></span><br><span class="line">    CheckerName(table, column <span class="type">string</span>) <span class="type">string</span></span><br><span class="line">    IndexName(table, column <span class="type">string</span>) <span class="type">string</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>默认 <code>NamingStrategy</code> 也提供了几个选项，如：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">db, err := gorm.Open(sqlite.Open(<span class="string">&quot;gorm.db&quot;</span>), &amp;gorm.Config&#123;</span><br><span class="line">  NamingStrategy: schema.NamingStrategy&#123;</span><br><span class="line">    TablePrefix: <span class="string">&quot;t_&quot;</span>,   <span class="comment">//表名前缀</span></span><br><span class="line">    SingularTable: <span class="literal">true</span>, <span class="comment">//使用单数表名</span></span><br><span class="line">    NoLowerCase: <span class="literal">true</span>, </span><br><span class="line">    NameReplacer: strings.NewReplacer(<span class="string">&quot;CID&quot;</span>, <span class="string">&quot;Cid&quot;</span>), </span><br><span class="line">  &#125;,</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure><h3 id="连接池"><a href="#连接池" class="headerlink" title="连接池"></a>连接池</h3><p>GORM 使用 <a href="https://pkg.go.dev/database/sql">database&#x2F;sql</a> 来维护连接池</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">sqlDB, err := db.DB()</span><br><span class="line">sqlDB.SetMaxIdleConns(<span class="number">10</span>)</span><br><span class="line"><span class="comment">//连接池中最大空闲连接数</span></span><br><span class="line"></span><br><span class="line">sqlDB.SetMaxOpenConns(<span class="number">100</span>)</span><br><span class="line"><span class="comment">//连接池中最多容纳的链接数目</span></span><br><span class="line"></span><br><span class="line">sqlDB.SetConnMaxLifetime(time.Hour)</span><br><span class="line"><span class="comment">//连接池连接的最大可复用时间</span></span><br></pre></td></tr></table></figure><h2 id="各种操作"><a href="#各种操作" class="headerlink" title="各种操作"></a>各种操作</h2><p>AutoMigrate 用于自动迁移您的 schema，保持您的 schema 是最新的。</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="keyword">type</span> User1 <span class="keyword">struct</span> &#123;</span><br><span class="line">Name <span class="type">string</span></span><br><span class="line">&#125;</span><br><span class="line">err := db.AutoMigrate(&amp;User1&#123;&#125;)</span><br><span class="line"><span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line"><span class="keyword">return</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">fmt.Println(db)</span><br></pre></td></tr></table></figure><p>GORM 提供了 Migrator 接口，该接口为每个数据库提供了统一的 API 接口，可用来为您的数据库构建独立迁移,源码：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> Migrator <span class="keyword">interface</span> &#123;</span><br><span class="line">  <span class="comment">// AutoMigrate</span></span><br><span class="line">  AutoMigrate(dst ...<span class="keyword">interface</span>&#123;&#125;) <span class="type">error</span></span><br><span class="line"></span><br><span class="line">  <span class="comment">// Database</span></span><br><span class="line">  CurrentDatabase() <span class="type">string</span></span><br><span class="line">  FullDataTypeOf(*schema.Field) clause.Expr</span><br><span class="line"></span><br><span class="line">  <span class="comment">// Tables</span></span><br><span class="line">  CreateTable(dst ...<span class="keyword">interface</span>&#123;&#125;) <span class="type">error</span></span><br><span class="line">  DropTable(dst ...<span class="keyword">interface</span>&#123;&#125;) <span class="type">error</span></span><br><span class="line">  HasTable(dst <span class="keyword">interface</span>&#123;&#125;) <span class="type">bool</span></span><br><span class="line">  RenameTable(oldName, newName <span class="keyword">interface</span>&#123;&#125;) <span class="type">error</span></span><br><span class="line">  GetTables() (tableList []<span class="type">string</span>, err <span class="type">error</span>)</span><br><span class="line"></span><br><span class="line">  <span class="comment">// Columns</span></span><br><span class="line">  AddColumn(dst <span class="keyword">interface</span>&#123;&#125;, field <span class="type">string</span>) <span class="type">error</span></span><br><span class="line">  DropColumn(dst <span class="keyword">interface</span>&#123;&#125;, field <span class="type">string</span>) <span class="type">error</span></span><br><span class="line">  AlterColumn(dst <span class="keyword">interface</span>&#123;&#125;, field <span class="type">string</span>) <span class="type">error</span></span><br><span class="line">  MigrateColumn(dst <span class="keyword">interface</span>&#123;&#125;, field *schema.Field, columnType ColumnType) <span class="type">error</span></span><br><span class="line">  HasColumn(dst <span class="keyword">interface</span>&#123;&#125;, field <span class="type">string</span>) <span class="type">bool</span></span><br><span class="line">  RenameColumn(dst <span class="keyword">interface</span>&#123;&#125;, oldName, field <span class="type">string</span>) <span class="type">error</span></span><br><span class="line">  ColumnTypes(dst <span class="keyword">interface</span>&#123;&#125;) ([]ColumnType, <span class="type">error</span>)</span><br><span class="line"></span><br><span class="line">  <span class="comment">// Views</span></span><br><span class="line">  CreateView(name <span class="type">string</span>, option ViewOption) <span class="type">error</span></span><br><span class="line">  DropView(name <span class="type">string</span>) <span class="type">error</span></span><br><span class="line"></span><br><span class="line">  <span class="comment">// Constraints</span></span><br><span class="line">  CreateConstraint(dst <span class="keyword">interface</span>&#123;&#125;, name <span class="type">string</span>) <span class="type">error</span></span><br><span class="line">  DropConstraint(dst <span class="keyword">interface</span>&#123;&#125;, name <span class="type">string</span>) <span class="type">error</span></span><br><span class="line">  HasConstraint(dst <span class="keyword">interface</span>&#123;&#125;, name <span class="type">string</span>) <span class="type">bool</span></span><br><span class="line"></span><br><span class="line">  <span class="comment">// Indexes</span></span><br><span class="line">  CreateIndex(dst <span class="keyword">interface</span>&#123;&#125;, name <span class="type">string</span>) <span class="type">error</span></span><br><span class="line">  DropIndex(dst <span class="keyword">interface</span>&#123;&#125;, name <span class="type">string</span>) <span class="type">error</span></span><br><span class="line">  HasIndex(dst <span class="keyword">interface</span>&#123;&#125;, name <span class="type">string</span>) <span class="type">bool</span></span><br><span class="line">  RenameIndex(dst <span class="keyword">interface</span>&#123;&#125;, oldName, newName <span class="type">string</span>) <span class="type">error</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>对应可以使用不同的操作。</p><h3 id="表"><a href="#表" class="headerlink" title="表"></a>表</h3><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 为 `User` 创建表</span></span><br><span class="line">db.Migrator().CreateTable(&amp;User&#123;&#125;)</span><br><span class="line"></span><br><span class="line"><span class="comment">// 将 &quot;ENGINE=InnoDB&quot; 添加到创建 `User` 的 SQL 里去</span></span><br><span class="line">db.Set(<span class="string">&quot;gorm:table_options&quot;</span>, <span class="string">&quot;ENGINE=InnoDB&quot;</span>).Migrator().CreateTable(&amp;User&#123;&#125;)</span><br><span class="line"></span><br><span class="line"><span class="comment">// 检查 `User` 对应的表是否存在</span></span><br><span class="line">db.Migrator().HasTable(&amp;User&#123;&#125;)</span><br><span class="line">db.Migrator().HasTable(<span class="string">&quot;users&quot;</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment">// 如果存在表则删除（删除时会忽略、删除外键约束)</span></span><br><span class="line">db.Migrator().DropTable(&amp;User&#123;&#125;)</span><br><span class="line">db.Migrator().DropTable(<span class="string">&quot;users&quot;</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment">// 重命名表</span></span><br><span class="line">db.Migrator().RenameTable(&amp;User&#123;&#125;, &amp;UserInfo&#123;&#125;)</span><br><span class="line">db.Migrator().RenameTable(<span class="string">&quot;users&quot;</span>, <span class="string">&quot;user_infos&quot;</span>)</span><br></pre></td></tr></table></figure><h3 id="列"><a href="#列" class="headerlink" title="列"></a>列</h3><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> User <span class="keyword">struct</span> &#123;</span><br><span class="line">  Name <span class="type">string</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 添加 name 字段</span></span><br><span class="line">db.Migrator().AddColumn(&amp;User&#123;&#125;, <span class="string">&quot;Name&quot;</span>)</span><br><span class="line"><span class="comment">// 删除 name 字段</span></span><br><span class="line">db.Migrator().DropColumn(&amp;User&#123;&#125;, <span class="string">&quot;Name&quot;</span>)</span><br><span class="line"><span class="comment">// 修改 name 字段</span></span><br><span class="line">db.Migrator().AlterColumn(&amp;User&#123;&#125;, <span class="string">&quot;Name&quot;</span>)</span><br><span class="line"><span class="comment">// 检查 name 字段是否存在</span></span><br><span class="line">db.Migrator().HasColumn(&amp;User&#123;&#125;, <span class="string">&quot;Name&quot;</span>)</span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> User <span class="keyword">struct</span> &#123;</span><br><span class="line">  Name    <span class="type">string</span></span><br><span class="line">  NewName <span class="type">string</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 字段重命名</span></span><br><span class="line">db.Migrator().RenameColumn(&amp;User&#123;&#125;, <span class="string">&quot;Name&quot;</span>, <span class="string">&quot;NewName&quot;</span>)</span><br><span class="line">db.Migrator().RenameColumn(&amp;User&#123;&#125;, <span class="string">&quot;name&quot;</span>, <span class="string">&quot;new_name&quot;</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment">// 字段类型</span></span><br><span class="line">db.Migrator().ColumnTypes(&amp;User&#123;&#125;) ([]gorm.ColumnType, <span class="type">error</span>)</span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> ColumnType <span class="keyword">interface</span> &#123;</span><br><span class="line">    Name() <span class="type">string</span></span><br><span class="line">    DatabaseTypeName() <span class="type">string</span>                 <span class="comment">// varchar</span></span><br><span class="line">    ColumnType() (columnType <span class="type">string</span>, ok <span class="type">bool</span>) <span class="comment">// varchar(64)</span></span><br><span class="line">    PrimaryKey() (isPrimaryKey <span class="type">bool</span>, ok <span class="type">bool</span>)</span><br><span class="line">    AutoIncrement() (isAutoIncrement <span class="type">bool</span>, ok <span class="type">bool</span>)</span><br><span class="line">    Length() (length <span class="type">int64</span>, ok <span class="type">bool</span>)</span><br><span class="line">    DecimalSize() (precision <span class="type">int64</span>, scale <span class="type">int64</span>, ok <span class="type">bool</span>)</span><br><span class="line">    Nullable() (nullable <span class="type">bool</span>, ok <span class="type">bool</span>)</span><br><span class="line">    Unique() (unique <span class="type">bool</span>, ok <span class="type">bool</span>)</span><br><span class="line">    ScanType() reflect.Type</span><br><span class="line">    Comment() (value <span class="type">string</span>, ok <span class="type">bool</span>)</span><br><span class="line">    DefaultValue() (value <span class="type">string</span>, ok <span class="type">bool</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>另外还有Views Constraints Indexes，后面再添加</p><h1 id="模型"><a href="#模型" class="headerlink" title="模型"></a>模型</h1><h2 id="定义"><a href="#定义" class="headerlink" title="定义"></a>定义</h2><p>模型是标准的 struct，由 Go 的基本数据类型、实现了 <a href="https://pkg.go.dev/database/sql/?tab=doc#Scanner">Scanner</a> 和 <a href="https://pkg.go.dev/database/sql/driver#Valuer">Valuer</a> 接口的自定义类型及其指针或别名组成，</p><p>通俗来讲就是一个结构体，携带了gorm规定的标签或者实现了gorm的接口</p><p>例如：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> User <span class="keyword">struct</span> &#123;</span><br><span class="line">  ID           <span class="type">uint</span></span><br><span class="line">  Name         <span class="type">string</span></span><br><span class="line">  Email        *<span class="type">string</span></span><br><span class="line">  Age          <span class="type">uint8</span></span><br><span class="line">  Birthday     *time.Time</span><br><span class="line">  MemberNumber sql.NullString</span><br><span class="line">  ActivatedAt  sql.NullTime</span><br><span class="line">  CreatedAt    time.Time</span><br><span class="line">  UpdatedAt    time.Time</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="约定"><a href="#约定" class="headerlink" title="约定"></a>约定</h2><p>GORM 倾向于约定优于配置 默认情况下，GORM 使用 <code>ID</code> 作为主键，使用结构体名的 <code>蛇形复数</code> 作为表名，字段名的 <code>蛇形</code> 作为列名，并使用 <code>CreatedAt</code>、<code>UpdatedAt</code> 字段追踪创建、更新时间</p><p>如果您遵循 GORM 的约定，您就可以少写的配置、代码。 如果约定不符合您的实际要求，<a href="https://gorm.io/zh_CN/docs/conventions.html">GORM 允许你配置它们</a></p><h2 id="gorm-Model"><a href="#gorm-Model" class="headerlink" title="gorm.Model"></a>gorm.Model</h2><p>GORM 定义一个 <code>gorm.Model</code> 结构体，其包括字段 <code>ID</code>、<code>CreatedAt</code>、<code>UpdatedAt</code>、<code>DeletedAt</code></p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// gorm.Model 的定义</span></span><br><span class="line"><span class="keyword">type</span> Model <span class="keyword">struct</span> &#123;</span><br><span class="line">  ID        <span class="type">uint</span>           <span class="string">`gorm:&quot;primaryKey&quot;`</span></span><br><span class="line">  CreatedAt time.Time</span><br><span class="line">  UpdatedAt time.Time</span><br><span class="line">  DeletedAt gorm.DeletedAt <span class="string">`gorm:&quot;index&quot;`</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// src/main.go</span></span><br><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> (</span><br><span class="line"><span class="string">&quot;gorm.io/driver/mysql&quot;</span></span><br><span class="line"><span class="string">&quot;gorm.io/gorm&quot;</span></span><br><span class="line"><span class="string">&quot;gorm.io/gorm/schema&quot;</span></span><br><span class="line"><span class="string">&quot;time&quot;</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> GlobalDb *gorm.DB</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">dsn := <span class="string">&quot;root:qq31415926535--@tcp(localhost:3306)/test&quot;</span></span><br><span class="line">db, _ := gorm.Open(mysql.New(mysql.Config&#123;</span><br><span class="line">DSN: dsn,</span><br><span class="line">&#125;), &amp;gorm.Config&#123;</span><br><span class="line">SkipDefaultTransaction: <span class="literal">false</span>,</span><br><span class="line">NamingStrategy: schema.NamingStrategy&#123;</span><br><span class="line">TablePrefix:   <span class="string">&quot;t_&quot;</span>,</span><br><span class="line">SingularTable: <span class="literal">true</span>,</span><br><span class="line">&#125;,</span><br><span class="line">DisableForeignKeyConstraintWhenMigrating: <span class="literal">true</span>,</span><br><span class="line">&#125;)</span><br><span class="line"></span><br><span class="line">sqlDb, _ := db.DB()</span><br><span class="line">sqlDb.SetMaxIdleConns(<span class="number">10</span>)</span><br><span class="line">sqlDb.SetMaxOpenConns(<span class="number">100</span>)</span><br><span class="line">sqlDb.SetConnMaxLifetime(time.Hour)</span><br><span class="line">GlobalDb = db</span><br><span class="line"></span><br><span class="line">TestUserCreated1()</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//src/model.go</span></span><br><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> (</span><br><span class="line"><span class="string">&quot;database/sql&quot;</span></span><br><span class="line"><span class="string">&quot;gorm.io/gorm&quot;</span></span><br><span class="line"><span class="string">&quot;time&quot;</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> TestUser <span class="keyword">struct</span> &#123;</span><br><span class="line">gorm.Model</span><br><span class="line">Name         <span class="type">string</span></span><br><span class="line">Email        *<span class="type">string</span></span><br><span class="line">Age          <span class="type">uint8</span></span><br><span class="line">Birthday     *time.Time</span><br><span class="line">MemberNumber sql.NullString</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">TestUserCreated1</span><span class="params">()</span></span> &#123;</span><br><span class="line">err := GlobalDb.AutoMigrate(&amp;TestUser&#123;&#125;)</span><br><span class="line"><span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line"><span class="keyword">return</span></span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>执行后会生成名为t_test_user的表，表的各字段如下</p><p><img src="/2023/07/02/Gorm/GormModel.png" alt="gorm"></p><h2 id="字段标签"><a href="#字段标签" class="headerlink" title="字段标签"></a>字段标签</h2><p>声明 model 时，tag 是可选的，GORM 支持以下 tag： tag 名大小写不敏感，但建议使用 <code>camelCase</code> 风格</p><table><thead><tr><th align="left">标签名</th><th align="left">说明</th></tr></thead><tbody><tr><td align="left">column</td><td align="left">指定 db 列名</td></tr><tr><td align="left">type</td><td align="left">列数据类型，推荐使用兼容性好的通用类型，例如：所有数据库都支持 bool、int、uint、float、string、time、bytes 并且可以和其他标签一起使用，例如：<code>not null</code>、<code>size</code>, <code>autoIncrement</code>… 像 <code>varbinary(8)</code> 这样指定数据库数据类型也是支持的。在使用指定数据库数据类型时，它需要是完整的数据库数据类型，如：<code>MEDIUMINT UNSIGNED not NULL AUTO_INCREMENT</code></td></tr><tr><td align="left">serializer</td><td align="left">指定将数据序列化或反序列化到数据库中的序列化器, 例如: <code>serializer:json/gob/unixtime</code></td></tr><tr><td align="left">size</td><td align="left">定义列数据类型的大小或长度，例如 <code>size: 256</code></td></tr><tr><td align="left">primaryKey</td><td align="left">将列定义为主键</td></tr><tr><td align="left">unique</td><td align="left">将列定义为唯一键</td></tr><tr><td align="left">default</td><td align="left">定义列的默认值</td></tr><tr><td align="left">precision</td><td align="left">指定列的精度</td></tr><tr><td align="left">scale</td><td align="left">指定列大小</td></tr><tr><td align="left">not null</td><td align="left">指定列为 NOT NULL</td></tr><tr><td align="left">autoIncrement</td><td align="left">指定列为自动增长</td></tr><tr><td align="left">autoIncrementIncrement</td><td align="left">自动步长，控制连续记录之间的间隔</td></tr><tr><td align="left">embedded</td><td align="left">嵌套字段</td></tr><tr><td align="left">embeddedPrefix</td><td align="left">嵌入字段的列名前缀</td></tr><tr><td align="left">autoCreateTime</td><td align="left">创建时追踪当前时间，对于 <code>int</code> 字段，它会追踪时间戳秒数，您可以使用 <code>nano</code>&#x2F;<code>milli</code> 来追踪纳秒、毫秒时间戳，例如：<code>autoCreateTime:nano</code></td></tr><tr><td align="left">autoUpdateTime</td><td align="left">创建&#x2F;更新时追踪当前时间，对于 <code>int</code> 字段，它会追踪时间戳秒数，您可以使用 <code>nano</code>&#x2F;<code>milli</code> 来追踪纳秒、毫秒时间戳，例如：<code>autoUpdateTime:milli</code></td></tr><tr><td align="left">index</td><td align="left">根据参数创建索引，多个字段使用相同的名称则创建复合索引，查看 <a href="https://gorm.io/zh_CN/docs/indexes.html">索引</a> 获取详情</td></tr><tr><td align="left">uniqueIndex</td><td align="left">与 <code>index</code> 相同，但创建的是唯一索引</td></tr><tr><td align="left">check</td><td align="left">创建检查约束，例如 <code>check:age &gt; 13</code>，查看 <a href="https://gorm.io/zh_CN/docs/constraints.html">约束</a> 获取详情</td></tr><tr><td align="left">&lt;-</td><td align="left">设置字段写入的权限， <code>&lt;-:create</code> 只创建、<code>&lt;-:update</code> 只更新、<code>&lt;-:false</code> 无写入权限、<code>&lt;-</code> 创建和更新权限</td></tr><tr><td align="left">-&gt;</td><td align="left">设置字段读的权限，<code>-&gt;:false</code> 无读权限</td></tr><tr><td align="left">-</td><td align="left">忽略该字段，<code>-</code> 表示无读写，<code>-:migration</code> 表示无迁移权限，<code>-:all</code> 表示无读写迁移权限</td></tr><tr><td align="left">comment</td><td align="left">迁移时为字段添加注释</td></tr></tbody></table><h1 id="Gorm增删改查"><a href="#Gorm增删改查" class="headerlink" title="Gorm增删改查"></a>Gorm增删改查</h1><h2 id="增"><a href="#增" class="headerlink" title="增"></a>增</h2><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//src//testCreated.go</span></span><br><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> (</span><br><span class="line"><span class="string">&quot;database/sql&quot;</span></span><br><span class="line"><span class="string">&quot;fmt&quot;</span></span><br><span class="line"><span class="string">&quot;gorm.io/gorm&quot;</span></span><br><span class="line"><span class="string">&quot;time&quot;</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">TestCreate</span><span class="params">()</span></span> &#123;</span><br><span class="line">tx := GlobalDb.Create(&amp;TestUser&#123;</span><br><span class="line">Model: gorm.Model&#123;</span><br><span class="line">CreatedAt: time.Time&#123;&#125;,</span><br><span class="line">UpdatedAt: time.Time&#123;&#125;,</span><br><span class="line">DeletedAt: gorm.DeletedAt&#123;&#125;,</span><br><span class="line">&#125;,</span><br><span class="line">Name:         <span class="string">&quot;xiaomei&quot;</span>,</span><br><span class="line">Email:        <span class="literal">nil</span>,</span><br><span class="line">Age:          <span class="number">18</span>,</span><br><span class="line">Birthday:     <span class="literal">nil</span>,</span><br><span class="line">MemberNumber: sql.NullString&#123;&#125;,</span><br><span class="line">&#125;)</span><br><span class="line">fmt.Println(tx.Error, <span class="string">&quot; &quot;</span>, tx.RowsAffected)</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>多行一次性增加，筛选字段增加</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> (</span><br><span class="line"><span class="string">&quot;database/sql&quot;</span></span><br><span class="line"><span class="string">&quot;fmt&quot;</span></span><br><span class="line"><span class="string">&quot;gorm.io/gorm&quot;</span></span><br><span class="line"><span class="string">&quot;time&quot;</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">TestCreate</span><span class="params">()</span></span> &#123;</span><br><span class="line">str1 := <span class="string">&quot;3123141&quot;</span></span><br><span class="line">str2 := <span class="string">&quot;312awda141&quot;</span></span><br><span class="line"><span class="comment">//Select选择字段添加，其余的忽略，</span></span><br><span class="line"><span class="comment">//与此相对的还有Omit，仅省略Omit内的字段，其余的照常添加</span></span><br><span class="line">tx := GlobalDb.Select(<span class="string">&quot;Name&quot;</span>).Create(&amp;[]TestUser&#123;</span><br><span class="line">&#123;Model: gorm.Model&#123;</span><br><span class="line">CreatedAt: time.Time&#123;&#125;,</span><br><span class="line">UpdatedAt: time.Time&#123;&#125;,</span><br><span class="line">DeletedAt: gorm.DeletedAt&#123;&#125;,</span><br><span class="line">&#125;,</span><br><span class="line">Name:         <span class="string">&quot;John&quot;</span>,</span><br><span class="line">Email:        &amp;str1,</span><br><span class="line">Age:          <span class="number">18</span>,</span><br><span class="line">Birthday:     <span class="literal">nil</span>,</span><br><span class="line">MemberNumber: sql.NullString&#123;&#125;,</span><br><span class="line">&#125;,</span><br><span class="line">&#123;</span><br><span class="line">Model:        gorm.Model&#123;&#125;,</span><br><span class="line">Name:         <span class="string">&quot;Tom&quot;</span>,</span><br><span class="line">Email:        &amp;str2,</span><br><span class="line">Age:          <span class="number">0</span>,</span><br><span class="line">Birthday:     <span class="literal">nil</span>,</span><br><span class="line">MemberNumber: sql.NullString&#123;&#125;,</span><br><span class="line">&#125;,</span><br><span class="line">&#125;,</span><br><span class="line">)</span><br><span class="line">fmt.Println(tx.Error, <span class="string">&quot; &quot;</span>, tx.RowsAffected)</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><h2 id="查询"><a href="#查询" class="headerlink" title="查询"></a>查询</h2><h3 id="检索单个对象"><a href="#检索单个对象" class="headerlink" title="检索单个对象"></a>检索单个对象</h3><p>GORM 提供了 <code>First</code>、<code>Take</code>、<code>Last</code> 方法，以便从数据库中检索单个对象。当查询数据库时它添加了 <code>LIMIT 1</code> 条件，且没有找到记录时，它会返回 <code>ErrRecordNotFound</code> 错误</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 获取第一条记录（主键升序）</span></span><br><span class="line">db.First(&amp;user)</span><br><span class="line"><span class="comment">// SELECT * FROM users ORDER BY id LIMIT 1;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 获取一条记录，没有指定排序字段</span></span><br><span class="line">db.Take(&amp;user)</span><br><span class="line"><span class="comment">// SELECT * FROM users LIMIT 1;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 获取最后一条记录（主键降序）</span></span><br><span class="line">db.Last(&amp;user)</span><br><span class="line"><span class="comment">// SELECT * FROM users ORDER BY id DESC LIMIT 1;</span></span><br><span class="line"></span><br><span class="line">result := db.First(&amp;user)</span><br><span class="line">result.RowsAffected <span class="comment">// 返回找到的记录数</span></span><br><span class="line">result.Error        <span class="comment">// returns error or nil</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 检查 ErrRecordNotFound 错误</span></span><br><span class="line">errors.Is(result.Error, gorm.ErrRecordNotFound)</span><br></pre></td></tr></table></figure><h3 id="根据主键检索"><a href="#根据主键检索" class="headerlink" title="根据主键检索"></a>根据主键检索</h3><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">db.First(&amp;user, <span class="number">10</span>)</span><br><span class="line"><span class="comment">// SELECT * FROM users WHERE id = 10;</span></span><br><span class="line"></span><br><span class="line">db.First(&amp;user, <span class="string">&quot;10&quot;</span>)</span><br><span class="line"><span class="comment">// SELECT * FROM users WHERE id = 10;</span></span><br><span class="line">   </span><br><span class="line">db.Find(&amp;users, []<span class="type">int</span>&#123;<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>&#125;)</span><br><span class="line"><span class="comment">// SELECT * FROM users WHERE id IN (1,2,3);</span></span><br></pre></td></tr></table></figure><p>如果主键是一个字符串，那么查询将会表示如下</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">db.First(&amp;user, <span class="string">&quot;id = ?&quot;</span>, <span class="string">&quot;1b74413f-f3b8-409f-ac47-e8c062e3472a&quot;</span>)</span><br><span class="line"><span class="comment">// SELECT * FROM users WHERE id = &quot;1b74413f-f3b8-409f-ac47-e8c062e3472a&quot;;</span></span><br><span class="line"></span><br></pre></td></tr></table></figure><p>当目标对象有一个主键值时，将使用主键构建查询条件，例如：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> user = User&#123;ID: <span class="number">10</span>&#125;</span><br><span class="line">db.First(&amp;user)</span><br><span class="line"><span class="comment">// SELECT * FROM users WHERE id = 10;</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> result User</span><br><span class="line">db.Model(User&#123;ID: <span class="number">10</span>&#125;).First(&amp;result)</span><br><span class="line"><span class="comment">// SELECT * FROM users WHERE id = 10;</span></span><br><span class="line"></span><br></pre></td></tr></table></figure><h3 id="检索全部对象"><a href="#检索全部对象" class="headerlink" title="检索全部对象"></a>检索全部对象</h3><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Get all records</span></span><br><span class="line">result := db.Find(&amp;users)</span><br><span class="line"><span class="comment">// SELECT * FROM users;</span></span><br><span class="line"></span><br><span class="line">result.RowsAffected <span class="comment">// returns found records count, equals `len(users)`</span></span><br><span class="line">result.Error        <span class="comment">// returns error</span></span><br></pre></td></tr></table></figure><h3 id="条件"><a href="#条件" class="headerlink" title="条件"></a>条件</h3><h4 id="string条件"><a href="#string条件" class="headerlink" title="string条件"></a>string条件</h4><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Get first matched record</span></span><br><span class="line">db.Where(<span class="string">&quot;name = ?&quot;</span>, <span class="string">&quot;jinzhu&quot;</span>).First(&amp;user)</span><br><span class="line"><span class="comment">// SELECT * FROM users WHERE name = &#x27;jinzhu&#x27; ORDER BY id LIMIT 1;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// Get all matched records</span></span><br><span class="line">db.Where(<span class="string">&quot;name &lt;&gt; ?&quot;</span>, <span class="string">&quot;jinzhu&quot;</span>).Find(&amp;users)</span><br><span class="line"><span class="comment">// SELECT * FROM users WHERE name &lt;&gt; &#x27;jinzhu&#x27;;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// IN</span></span><br><span class="line">db.Where(<span class="string">&quot;name IN ?&quot;</span>, []<span class="type">string</span>&#123;<span class="string">&quot;jinzhu&quot;</span>, <span class="string">&quot;jinzhu 2&quot;</span>&#125;).Find(&amp;users)</span><br><span class="line"><span class="comment">// SELECT * FROM users WHERE name IN (&#x27;jinzhu&#x27;,&#x27;jinzhu 2&#x27;);</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// LIKE</span></span><br><span class="line">db.Where(<span class="string">&quot;name LIKE ?&quot;</span>, <span class="string">&quot;%jin%&quot;</span>).Find(&amp;users)</span><br><span class="line"><span class="comment">// SELECT * FROM users WHERE name LIKE &#x27;%jin%&#x27;;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// AND</span></span><br><span class="line">db.Where(<span class="string">&quot;name = ? AND age &gt;= ?&quot;</span>, <span class="string">&quot;jinzhu&quot;</span>, <span class="string">&quot;22&quot;</span>).Find(&amp;users)</span><br><span class="line"><span class="comment">// SELECT * FROM users WHERE name = &#x27;jinzhu&#x27; AND age &gt;= 22;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// Time</span></span><br><span class="line">db.Where(<span class="string">&quot;updated_at &gt; ?&quot;</span>, lastWeek).Find(&amp;users)</span><br><span class="line"><span class="comment">// SELECT * FROM users WHERE updated_at &gt; &#x27;2000-01-01 00:00:00&#x27;;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// BETWEEN</span></span><br><span class="line">db.Where(<span class="string">&quot;created_at BETWEEN ? AND ?&quot;</span>, lastWeek, today).Find(&amp;users)</span><br><span class="line"><span class="comment">// SELECT * FROM users WHERE created_at BETWEEN &#x27;2000-01-01 00:00:00&#x27; AND &#x27;2000-01-08 00:00:00&#x27;;</span></span><br><span class="line"></span><br></pre></td></tr></table></figure><h4 id="Struct-amp-Map-条件"><a href="#Struct-amp-Map-条件" class="headerlink" title="Struct &amp; Map 条件"></a>Struct &amp; Map 条件</h4><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Struct</span></span><br><span class="line">db.Where(&amp;User&#123;Name: <span class="string">&quot;jinzhu&quot;</span>, Age: <span class="number">20</span>&#125;).First(&amp;user)</span><br><span class="line"><span class="comment">// SELECT * FROM users WHERE name = &quot;jinzhu&quot; AND age = 20 ORDER BY id LIMIT 1;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// Map</span></span><br><span class="line">db.Where(<span class="keyword">map</span>[<span class="type">string</span>]<span class="keyword">interface</span>&#123;&#125;&#123;<span class="string">&quot;name&quot;</span>: <span class="string">&quot;jinzhu&quot;</span>, <span class="string">&quot;age&quot;</span>: <span class="number">20</span>&#125;).Find(&amp;users)</span><br><span class="line"><span class="comment">// SELECT * FROM users WHERE name = &quot;jinzhu&quot; AND age = 20;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// Slice of primary keys</span></span><br><span class="line">db.Where([]<span class="type">int64</span>&#123;<span class="number">20</span>, <span class="number">21</span>, <span class="number">22</span>&#125;).Find(&amp;users)</span><br><span class="line"><span class="comment">// SELECT * FROM users WHERE id IN (20, 21, 22);</span></span><br></pre></td></tr></table></figure><h4 id="指定结构体查询字段"><a href="#指定结构体查询字段" class="headerlink" title="指定结构体查询字段"></a>指定结构体查询字段</h4><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">db.Where(&amp;User&#123;Name: <span class="string">&quot;jinzhu&quot;</span>&#125;, <span class="string">&quot;name&quot;</span>, <span class="string">&quot;Age&quot;</span>).Find(&amp;users)</span><br><span class="line"><span class="comment">// SELECT * FROM users WHERE name = &quot;jinzhu&quot; AND age = 0;</span></span><br><span class="line"></span><br><span class="line">db.Where(&amp;User&#123;Name: <span class="string">&quot;jinzhu&quot;</span>&#125;, <span class="string">&quot;Age&quot;</span>).Find(&amp;users)</span><br><span class="line"><span class="comment">// SELECT * FROM users WHERE age = 0;</span></span><br></pre></td></tr></table></figure><h4 id="内联条件"><a href="#内联条件" class="headerlink" title="内联条件"></a>内联条件</h4><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Get by primary key if it were a non-integer type</span></span><br><span class="line">db.First(&amp;user, <span class="string">&quot;id = ?&quot;</span>, <span class="string">&quot;string_primary_key&quot;</span>)</span><br><span class="line"><span class="comment">// SELECT * FROM users WHERE id = &#x27;string_primary_key&#x27;;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// Plain SQL</span></span><br><span class="line">db.Find(&amp;user, <span class="string">&quot;name = ?&quot;</span>, <span class="string">&quot;jinzhu&quot;</span>)</span><br><span class="line"><span class="comment">// SELECT * FROM users WHERE name = &quot;jinzhu&quot;;</span></span><br><span class="line"></span><br><span class="line">db.Find(&amp;users, <span class="string">&quot;name &lt;&gt; ? AND age &gt; ?&quot;</span>, <span class="string">&quot;jinzhu&quot;</span>, <span class="number">20</span>)</span><br><span class="line"><span class="comment">// SELECT * FROM users WHERE name &lt;&gt; &quot;jinzhu&quot; AND age &gt; 20;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// Struct</span></span><br><span class="line">db.Find(&amp;users, User&#123;Age: <span class="number">20</span>&#125;)</span><br><span class="line"><span class="comment">// SELECT * FROM users WHERE age = 20;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// Map</span></span><br><span class="line">db.Find(&amp;users, <span class="keyword">map</span>[<span class="type">string</span>]<span class="keyword">interface</span>&#123;&#125;&#123;<span class="string">&quot;age&quot;</span>: <span class="number">20</span>&#125;)</span><br><span class="line"><span class="comment">// SELECT * FROM users WHERE age = 20;</span></span><br></pre></td></tr></table></figure><h4 id="Not-条件"><a href="#Not-条件" class="headerlink" title="Not 条件"></a>Not 条件</h4><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">db.Not(<span class="string">&quot;name = ?&quot;</span>, <span class="string">&quot;jinzhu&quot;</span>).First(&amp;user)</span><br><span class="line"><span class="comment">// SELECT * FROM users WHERE NOT name = &quot;jinzhu&quot; ORDER BY id LIMIT 1;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// Not In</span></span><br><span class="line">db.Not(<span class="keyword">map</span>[<span class="type">string</span>]<span class="keyword">interface</span>&#123;&#125;&#123;<span class="string">&quot;name&quot;</span>: []<span class="type">string</span>&#123;<span class="string">&quot;jinzhu&quot;</span>, <span class="string">&quot;jinzhu 2&quot;</span>&#125;&#125;).Find(&amp;users)</span><br><span class="line"><span class="comment">// SELECT * FROM users WHERE name NOT IN (&quot;jinzhu&quot;, &quot;jinzhu 2&quot;);</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// Struct</span></span><br><span class="line">db.Not(User&#123;Name: <span class="string">&quot;jinzhu&quot;</span>, Age: <span class="number">18</span>&#125;).First(&amp;user)</span><br><span class="line"><span class="comment">// SELECT * FROM users WHERE name &lt;&gt; &quot;jinzhu&quot; AND age &lt;&gt; 18 ORDER BY id LIMIT 1;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// Not In slice of primary keys</span></span><br><span class="line">db.Not([]<span class="type">int64</span>&#123;<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>&#125;).First(&amp;user)</span><br><span class="line"><span class="comment">// SELECT * FROM users WHERE id NOT IN (1,2,3) ORDER BY id LIMIT 1;</span></span><br></pre></td></tr></table></figure><h4 id="Or条件"><a href="#Or条件" class="headerlink" title="Or条件"></a>Or条件</h4><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">db.Where(<span class="string">&quot;role = ?&quot;</span>, <span class="string">&quot;admin&quot;</span>).Or(<span class="string">&quot;role = ?&quot;</span>, <span class="string">&quot;super_admin&quot;</span>).Find(&amp;users)</span><br><span class="line"><span class="comment">// SELECT * FROM users WHERE role = &#x27;admin&#x27; OR role = &#x27;super_admin&#x27;;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// Struct</span></span><br><span class="line">db.Where(<span class="string">&quot;name = &#x27;jinzhu&#x27;&quot;</span>).Or(User&#123;Name: <span class="string">&quot;jinzhu 2&quot;</span>, Age: <span class="number">18</span>&#125;).Find(&amp;users)</span><br><span class="line"><span class="comment">// SELECT * FROM users WHERE name = &#x27;jinzhu&#x27; OR (name = &#x27;jinzhu 2&#x27; AND age = 18);</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// Map</span></span><br><span class="line">db.Where(<span class="string">&quot;name = &#x27;jinzhu&#x27;&quot;</span>).Or(<span class="keyword">map</span>[<span class="type">string</span>]<span class="keyword">interface</span>&#123;&#125;&#123;<span class="string">&quot;name&quot;</span>: <span class="string">&quot;jinzhu 2&quot;</span>, <span class="string">&quot;age&quot;</span>: <span class="number">18</span>&#125;).Find(&amp;users)</span><br><span class="line"><span class="comment">// SELECT * FROM users WHERE name = &#x27;jinzhu&#x27; OR (name = &#x27;jinzhu 2&#x27; AND age = 18);</span></span><br></pre></td></tr></table></figure><h3 id="选择特定字段"><a href="#选择特定字段" class="headerlink" title="选择特定字段"></a>选择特定字段</h3><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">db.Select(<span class="string">&quot;name&quot;</span>, <span class="string">&quot;age&quot;</span>).Find(&amp;users)</span><br><span class="line"><span class="comment">// SELECT name, age FROM users;</span></span><br><span class="line"></span><br><span class="line">db.Select([]<span class="type">string</span>&#123;<span class="string">&quot;name&quot;</span>, <span class="string">&quot;age&quot;</span>&#125;).Find(&amp;users)</span><br><span class="line"><span class="comment">// SELECT name, age FROM users;</span></span><br><span class="line"></span><br><span class="line">db.Table(<span class="string">&quot;users&quot;</span>).Select(<span class="string">&quot;COALESCE(age,?)&quot;</span>, <span class="number">42</span>).Rows()</span><br><span class="line"><span class="comment">// SELECT COALESCE(age,&#x27;42&#x27;) FROM users;</span></span><br></pre></td></tr></table></figure><h3 id="排序"><a href="#排序" class="headerlink" title="排序"></a>排序</h3><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">db.Order(<span class="string">&quot;age desc, name&quot;</span>).Find(&amp;users)</span><br><span class="line"><span class="comment">// SELECT * FROM users ORDER BY age desc, name;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// Multiple orders</span></span><br><span class="line">db.Order(<span class="string">&quot;age desc&quot;</span>).Order(<span class="string">&quot;name&quot;</span>).Find(&amp;users)</span><br><span class="line"><span class="comment">// SELECT * FROM users ORDER BY age desc, name;</span></span><br><span class="line"></span><br><span class="line">db.Clauses(clause.OrderBy&#123;</span><br><span class="line">  Expression: clause.Expr&#123;SQL: <span class="string">&quot;FIELD(id,?)&quot;</span>, Vars: []<span class="keyword">interface</span>&#123;&#125;&#123;[]<span class="type">int</span>&#123;<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>&#125;&#125;, WithoutParentheses: <span class="literal">true</span>&#125;,</span><br><span class="line">&#125;).Find(&amp;User&#123;&#125;)</span><br><span class="line"><span class="comment">// SELECT * FROM users ORDER BY FIELD(id,1,2,3)</span></span><br></pre></td></tr></table></figure><h3 id="Limit-amp-Offset"><a href="#Limit-amp-Offset" class="headerlink" title="Limit &amp; Offset"></a>Limit &amp; Offset</h3><p>分页查询</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">db.Limit(<span class="number">3</span>).Find(&amp;users)</span><br><span class="line"><span class="comment">// SELECT * FROM users LIMIT 3;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// Cancel limit condition with -1</span></span><br><span class="line">db.Limit(<span class="number">10</span>).Find(&amp;users1).Limit(<span class="number">-1</span>).Find(&amp;users2)</span><br><span class="line"><span class="comment">// SELECT * FROM users LIMIT 10; (users1)</span></span><br><span class="line"><span class="comment">// SELECT * FROM users; (users2)</span></span><br><span class="line"></span><br><span class="line">db.Offset(<span class="number">3</span>).Find(&amp;users)</span><br><span class="line"><span class="comment">// SELECT * FROM users OFFSET 3;</span></span><br><span class="line">   </span><br><span class="line">db.Limit(<span class="number">10</span>).Offset(<span class="number">5</span>).Find(&amp;users)</span><br><span class="line"><span class="comment">// SELECT * FROM users OFFSET 5 LIMIT 10;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// Cancel offset condition with -1</span></span><br><span class="line">db.Offset(<span class="number">10</span>).Find(&amp;users1).Offset(<span class="number">-1</span>).Find(&amp;users2)</span><br><span class="line"><span class="comment">// SELECT * FROM users OFFSET 10; (users1)</span></span><br><span class="line"><span class="comment">// SELECT * FROM users; (users2)</span></span><br></pre></td></tr></table></figure><h3 id="Group-By-amp-Having"><a href="#Group-By-amp-Having" class="headerlink" title="Group By &amp; Having"></a>Group By &amp; Having</h3><p>分组查询</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> result <span class="keyword">struct</span> &#123;</span><br><span class="line">  Date  time.Time</span><br><span class="line">  Total <span class="type">int</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">db.Model(&amp;User&#123;&#125;).Select(<span class="string">&quot;name, sum(age) as total&quot;</span>).Where(<span class="string">&quot;name LIKE ?&quot;</span>, <span class="string">&quot;group%&quot;</span>).Group(<span class="string">&quot;name&quot;</span>).First(&amp;result)</span><br><span class="line"><span class="comment">// SELECT name, sum(age) as total FROM `users` WHERE name LIKE &quot;group%&quot; GROUP BY `name` LIMIT 1</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">db.Model(&amp;User&#123;&#125;).Select(<span class="string">&quot;name, sum(age) as total&quot;</span>).Group(<span class="string">&quot;name&quot;</span>).Having(<span class="string">&quot;name = ?&quot;</span>, <span class="string">&quot;group&quot;</span>).Find(&amp;result)</span><br><span class="line"><span class="comment">// SELECT name, sum(age) as total FROM `users` GROUP BY `name` HAVING name = &quot;group&quot;</span></span><br><span class="line"></span><br><span class="line">rows, err := db.Table(<span class="string">&quot;orders&quot;</span>).Select(<span class="string">&quot;date(created_at) as date, sum(amount) as total&quot;</span>).Group(<span class="string">&quot;date(created_at)&quot;</span>).Rows()</span><br><span class="line"><span class="keyword">defer</span> rows.Close()</span><br><span class="line"><span class="keyword">for</span> rows.Next() &#123;</span><br><span class="line">  ...</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">rows, err := db.Table(<span class="string">&quot;orders&quot;</span>).Select(<span class="string">&quot;date(created_at) as date, sum(amount) as total&quot;</span>).Group(<span class="string">&quot;date(created_at)&quot;</span>).Having(<span class="string">&quot;sum(amount) &gt; ?&quot;</span>, <span class="number">100</span>).Rows()</span><br><span class="line"><span class="keyword">defer</span> rows.Close()</span><br><span class="line"><span class="keyword">for</span> rows.Next() &#123;</span><br><span class="line">  ...</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> Result <span class="keyword">struct</span> &#123;</span><br><span class="line">  Date  time.Time</span><br><span class="line">  Total <span class="type">int64</span></span><br><span class="line">&#125;</span><br><span class="line">db.Table(<span class="string">&quot;orders&quot;</span>).Select(<span class="string">&quot;date(created_at) as date, sum(amount) as total&quot;</span>).Group(<span class="string">&quot;date(created_at)&quot;</span>).Having(<span class="string">&quot;sum(amount) &gt; ?&quot;</span>, <span class="number">100</span>).Scan(&amp;results)</span><br><span class="line"></span><br></pre></td></tr></table></figure><h3 id="Distinct"><a href="#Distinct" class="headerlink" title="Distinct"></a>Distinct</h3><p>去除重复字段</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">db.Distinct(<span class="string">&quot;name&quot;</span>, <span class="string">&quot;age&quot;</span>).Order(<span class="string">&quot;name, age desc&quot;</span>).Find(&amp;results)</span><br></pre></td></tr></table></figure><h3 id="Joins"><a href="#Joins" class="headerlink" title="Joins"></a>Joins</h3><p>连接查询</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> result <span class="keyword">struct</span> &#123;</span><br><span class="line">  Name  <span class="type">string</span></span><br><span class="line">  Email <span class="type">string</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">db.Model(&amp;User&#123;&#125;).Select(<span class="string">&quot;users.name, emails.email&quot;</span>).Joins(<span class="string">&quot;left join emails on emails.user_id = users.id&quot;</span>).Scan(&amp;result&#123;&#125;)</span><br><span class="line"><span class="comment">// SELECT users.name, emails.email FROM `users` left join emails on emails.user_id = users.id</span></span><br><span class="line"></span><br><span class="line">rows, err := db.Table(<span class="string">&quot;users&quot;</span>).Select(<span class="string">&quot;users.name, emails.email&quot;</span>).Joins(<span class="string">&quot;left join emails on emails.user_id = users.id&quot;</span>).Rows()</span><br><span class="line"><span class="keyword">for</span> rows.Next() &#123;</span><br><span class="line">  ...</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">db.Table(<span class="string">&quot;users&quot;</span>).Select(<span class="string">&quot;users.name, emails.email&quot;</span>).Joins(<span class="string">&quot;left join emails on emails.user_id = users.id&quot;</span>).Scan(&amp;results)</span><br><span class="line"></span><br><span class="line"><span class="comment">// multiple joins with parameter</span></span><br><span class="line">db.Joins(<span class="string">&quot;JOIN emails ON emails.user_id = users.id AND emails.email = ?&quot;</span>, <span class="string">&quot;jinzhu@example.org&quot;</span>).Joins(<span class="string">&quot;JOIN credit_cards ON credit_cards.user_id = users.id&quot;</span>).Where(<span class="string">&quot;credit_cards.number = ?&quot;</span>, <span class="string">&quot;411111111111&quot;</span>).Find(&amp;user)</span><br><span class="line"></span><br></pre></td></tr></table></figure><h3 id="高级查询"><a href="#高级查询" class="headerlink" title="高级查询"></a>高级查询</h3><h4 id="智能选择字段"><a href="#智能选择字段" class="headerlink" title="智能选择字段"></a>智能选择字段</h4><p>GORM 允许通过 <a href="https://gorm.io/zh_CN/docs/query.html"><code>Select</code></a> 方法选择特定的字段，如果您在应用程序中经常使用此功能，你也可以定义一个较小的结构体，以实现调用 API 时自动选择特定的字段:</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> <span class="string">&quot;fmt&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> UserInfo <span class="keyword">struct</span> &#123;</span><br><span class="line">Name <span class="type">string</span></span><br><span class="line">Age  <span class="type">string</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> TestUser <span class="keyword">struct</span> &#123;</span><br><span class="line">gorm.Model</span><br><span class="line">Name         <span class="type">string</span></span><br><span class="line">Email        *<span class="type">string</span></span><br><span class="line">Age          <span class="type">uint8</span></span><br><span class="line">Birthday     *time.Time</span><br><span class="line">MemberNumber sql.NullString</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">TestFind1</span><span class="params">()</span></span> &#123;</span><br><span class="line"><span class="keyword">var</span> u UserInfo</span><br><span class="line">tx := GlobalDb.Model(&amp;TestUser&#123;&#125;).Where(<span class="string">&quot;name = ?&quot;</span>, <span class="string">&quot;John&quot;</span>).First(&amp;u)</span><br><span class="line">fmt.Println(u)</span><br><span class="line">fmt.Println(tx.Error, tx.RowsAffected)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//此时输出</span></span><br><span class="line"><span class="comment">//&#123;John 20&#125;</span></span><br><span class="line"><span class="comment">//&lt;nil&gt; 1</span></span><br><span class="line"></span><br></pre></td></tr></table></figure><h4 id="子查询"><a href="#子查询" class="headerlink" title="子查询"></a>子查询</h4><p>与原来的SQL语句基本上一模一样，套用到go里面就是代码里面套代码</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">db.Where(<span class="string">&quot;amount &gt; (?)&quot;</span>, db.Table(<span class="string">&quot;orders&quot;</span>).Select(<span class="string">&quot;AVG(amount)&quot;</span>)).Find(&amp;orders)</span><br><span class="line"><span class="comment">// SELECT * FROM &quot;orders&quot; WHERE amount &gt; (SELECT AVG(amount) FROM &quot;orders&quot;);</span></span><br><span class="line"></span><br><span class="line">subQuery := db.Select(<span class="string">&quot;AVG(age)&quot;</span>).Where(<span class="string">&quot;name LIKE ?&quot;</span>, <span class="string">&quot;name%&quot;</span>).Table(<span class="string">&quot;users&quot;</span>)</span><br><span class="line">db.Select(<span class="string">&quot;AVG(age) as avgage&quot;</span>).Group(<span class="string">&quot;name&quot;</span>).Having(<span class="string">&quot;AVG(age) &gt; (?)&quot;</span>, subQuery).Find(&amp;results)</span><br><span class="line"><span class="comment">// SELECT AVG(age) as avgage FROM `users` GROUP BY `name` HAVING AVG(age) &gt; (SELECT AVG(age) FROM `users` WHERE name LIKE &quot;name%&quot;)</span></span><br></pre></td></tr></table></figure><h5 id="From-子查询"><a href="#From-子查询" class="headerlink" title="From 子查询"></a>From 子查询</h5><p>子查询可以嵌套在查询中，GORM 允许在使用 <code>*gorm.DB</code> 对象作为参数时生成子查询</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">db.Where(<span class="string">&quot;amount &gt; (?)&quot;</span>, db.Table(<span class="string">&quot;orders&quot;</span>).Select(<span class="string">&quot;AVG(amount)&quot;</span>)).Find(&amp;orders)</span><br><span class="line"><span class="comment">// SELECT * FROM &quot;orders&quot; WHERE amount &gt; (SELECT AVG(amount) FROM &quot;orders&quot;);</span></span><br><span class="line"></span><br><span class="line">subQuery := db.Select(<span class="string">&quot;AVG(age)&quot;</span>).Where(<span class="string">&quot;name LIKE ?&quot;</span>, <span class="string">&quot;name%&quot;</span>).Table(<span class="string">&quot;users&quot;</span>)</span><br><span class="line">db.Select(<span class="string">&quot;AVG(age) as avgage&quot;</span>).Group(<span class="string">&quot;name&quot;</span>).Having(<span class="string">&quot;AVG(age) &gt; (?)&quot;</span>, subQuery).Find(&amp;results)</span><br><span class="line"><span class="comment">// SELECT AVG(age) as avgage FROM `users` GROUP BY `name` HAVING AVG(age) &gt; (SELECT AVG(age) FROM `users` WHERE name LIKE &quot;name%&quot;)</span></span><br></pre></td></tr></table></figure><h4 id="Group-条件"><a href="#Group-条件" class="headerlink" title="Group 条件"></a>Group 条件</h4><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">db.Where(</span><br><span class="line">    db.Where(<span class="string">&quot;pizza = ?&quot;</span>, <span class="string">&quot;pepperoni&quot;</span>).Where(db.Where(<span class="string">&quot;size = ?&quot;</span>, <span class="string">&quot;small&quot;</span>).Or(<span class="string">&quot;size = ?&quot;</span>, <span class="string">&quot;medium&quot;</span>)),</span><br><span class="line">).Or(</span><br><span class="line">    db.Where(<span class="string">&quot;pizza = ?&quot;</span>, <span class="string">&quot;hawaiian&quot;</span>).Where(<span class="string">&quot;size = ?&quot;</span>, <span class="string">&quot;xlarge&quot;</span>),</span><br><span class="line">).Find(&amp;Pizza&#123;&#125;).Statement</span><br><span class="line"></span><br><span class="line"><span class="comment">// SELECT * FROM `pizzas` WHERE (pizza = &quot;pepperoni&quot; AND (size = &quot;small&quot; OR size = &quot;medium&quot;)) OR (pizza = &quot;hawaiian&quot; AND size = &quot;xlarge&quot;)</span></span><br></pre></td></tr></table></figure><h2 id="更新"><a href="#更新" class="headerlink" title="更新"></a>更新</h2><p>MAP零值参与更新，结构体零值不参与更新</p><h3 id="保存所有字段"><a href="#保存所有字段" class="headerlink" title="保存所有字段"></a>保存所有字段</h3><p><code>Save</code> 会保存所有的字段，即使字段是零值</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">db.First(&amp;user)</span><br><span class="line"></span><br><span class="line">user.Name = <span class="string">&quot;jinzhu 2&quot;</span></span><br><span class="line">user.Age = <span class="number">100</span></span><br><span class="line">db.Save(&amp;user)</span><br><span class="line"><span class="comment">// UPDATE users SET name=&#x27;jinzhu 2&#x27;, age=100, birthday=&#x27;2016-01-01&#x27;, updated_at = &#x27;2013-11-17 21:34:10&#x27; WHERE id=111;</span></span><br></pre></td></tr></table></figure><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">db.Save(&amp;User&#123;Name: <span class="string">&quot;jinzhu&quot;</span>, Age: <span class="number">100</span>&#125;)</span><br><span class="line"><span class="comment">// INSERT INTO `users` (`name`,`age`,`birthday`,`update_at`) VALUES (&quot;jinzhu&quot;,100,&quot;0000-00-00 00:00:00&quot;,&quot;0000-00-00 00:00:00&quot;)</span></span><br><span class="line"></span><br><span class="line">db.Save(&amp;User&#123;ID: <span class="number">1</span>, Name: <span class="string">&quot;jinzhu&quot;</span>, Age: <span class="number">100</span>&#125;)</span><br><span class="line"><span class="comment">// UPDATE `users` SET `name`=&quot;jinzhu&quot;,`age`=100,`birthday`=&quot;0000-00-00 00:00:00&quot;,`update_at`=&quot;0000-00-00 00:00:00&quot; WHERE `id` = 1</span></span><br></pre></td></tr></table></figure><h3 id="更新单个列"><a href="#更新单个列" class="headerlink" title="更新单个列"></a>更新单个列</h3><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Update with conditions</span></span><br><span class="line">db.Model(&amp;User&#123;&#125;).Where(<span class="string">&quot;active = ?&quot;</span>, <span class="literal">true</span>).Update(<span class="string">&quot;name&quot;</span>, <span class="string">&quot;hello&quot;</span>)</span><br><span class="line"><span class="comment">// UPDATE users SET name=&#x27;hello&#x27;, updated_at=&#x27;2013-11-17 21:34:10&#x27; WHERE active=true;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// User&#x27;s ID is `111`:</span></span><br><span class="line">db.Model(&amp;user).Update(<span class="string">&quot;name&quot;</span>, <span class="string">&quot;hello&quot;</span>)</span><br><span class="line"><span class="comment">// UPDATE users SET name=&#x27;hello&#x27;, updated_at=&#x27;2013-11-17 21:34:10&#x27; WHERE id=111;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// Update with conditions and model value</span></span><br><span class="line">db.Model(&amp;user).Where(<span class="string">&quot;active = ?&quot;</span>, <span class="literal">true</span>).Update(<span class="string">&quot;name&quot;</span>, <span class="string">&quot;hello&quot;</span>)</span><br><span class="line"><span class="comment">// UPDATE users SET name=&#x27;hello&#x27;, updated_at=&#x27;2013-11-17 21:34:10&#x27; WHERE id=111 AND active=true;</span></span><br></pre></td></tr></table></figure><h3 id="更新多列"><a href="#更新多列" class="headerlink" title="更新多列"></a>更新多列</h3><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Update attributes with `struct`, will only update non-zero fields</span></span><br><span class="line">db.Model(&amp;user).Updates(User&#123;Name: <span class="string">&quot;hello&quot;</span>, Age: <span class="number">18</span>, Active: <span class="literal">false</span>&#125;)</span><br><span class="line"><span class="comment">// UPDATE users SET name=&#x27;hello&#x27;, age=18, updated_at = &#x27;2013-11-17 21:34:10&#x27; WHERE id = 111;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// Update attributes with `map`</span></span><br><span class="line">db.Model(&amp;user).Updates(<span class="keyword">map</span>[<span class="type">string</span>]<span class="keyword">interface</span>&#123;&#125;&#123;<span class="string">&quot;name&quot;</span>: <span class="string">&quot;hello&quot;</span>, <span class="string">&quot;age&quot;</span>: <span class="number">18</span>, <span class="string">&quot;active&quot;</span>: <span class="literal">false</span>&#125;)</span><br><span class="line"><span class="comment">// UPDATE users SET name=&#x27;hello&#x27;, age=18, active=false, updated_at=&#x27;2013-11-17 21:34:10&#x27; WHERE id=111;</span></span><br></pre></td></tr></table></figure><h3 id="更新选定字段"><a href="#更新选定字段" class="headerlink" title="更新选定字段"></a>更新选定字段</h3><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Select with Map</span></span><br><span class="line"><span class="comment">// User&#x27;s ID is `111`:</span></span><br><span class="line">db.Model(&amp;user).Select(<span class="string">&quot;name&quot;</span>).Updates(<span class="keyword">map</span>[<span class="type">string</span>]<span class="keyword">interface</span>&#123;&#125;&#123;<span class="string">&quot;name&quot;</span>: <span class="string">&quot;hello&quot;</span>, <span class="string">&quot;age&quot;</span>: <span class="number">18</span>, <span class="string">&quot;active&quot;</span>: <span class="literal">false</span>&#125;)</span><br><span class="line"><span class="comment">// UPDATE users SET name=&#x27;hello&#x27; WHERE id=111;</span></span><br><span class="line"></span><br><span class="line">db.Model(&amp;user).Omit(<span class="string">&quot;name&quot;</span>).Updates(<span class="keyword">map</span>[<span class="type">string</span>]<span class="keyword">interface</span>&#123;&#125;&#123;<span class="string">&quot;name&quot;</span>: <span class="string">&quot;hello&quot;</span>, <span class="string">&quot;age&quot;</span>: <span class="number">18</span>, <span class="string">&quot;active&quot;</span>: <span class="literal">false</span>&#125;)</span><br><span class="line"><span class="comment">// UPDATE users SET age=18, active=false, updated_at=&#x27;2013-11-17 21:34:10&#x27; WHERE id=111;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// Select with Struct (select zero value fields)</span></span><br><span class="line">db.Model(&amp;user).Select(<span class="string">&quot;Name&quot;</span>, <span class="string">&quot;Age&quot;</span>).Updates(User&#123;Name: <span class="string">&quot;new_name&quot;</span>, Age: <span class="number">0</span>&#125;)</span><br><span class="line"><span class="comment">// UPDATE users SET name=&#x27;new_name&#x27;, age=0 WHERE id=111;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// Select all fields (select all fields include zero value fields)</span></span><br><span class="line">db.Model(&amp;user).Select(<span class="string">&quot;*&quot;</span>).Updates(User&#123;Name: <span class="string">&quot;jinzhu&quot;</span>, Role: <span class="string">&quot;admin&quot;</span>, Age: <span class="number">0</span>&#125;)</span><br><span class="line"></span><br><span class="line"><span class="comment">// Select all fields but omit Role (select all fields include zero value fields)</span></span><br><span class="line">db.Model(&amp;user).Select(<span class="string">&quot;*&quot;</span>).Omit(<span class="string">&quot;Role&quot;</span>).Updates(User&#123;Name: <span class="string">&quot;jinzhu&quot;</span>, Role: <span class="string">&quot;admin&quot;</span>, Age: <span class="number">0</span>&#125;)</span><br></pre></td></tr></table></figure><h2 id="删除"><a href="#删除" class="headerlink" title="删除"></a>删除</h2><h3 id="删除一条记录"><a href="#删除一条记录" class="headerlink" title="删除一条记录"></a>删除一条记录</h3><p>删除一条记录时，删除对象需要指定主键，否则会触发 <a href="https://gorm.io/zh_CN/docs/delete.html#batch_delete">批量删除</a>，例如：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Email 的 ID 是 `10`</span></span><br><span class="line">db.Delete(&amp;email)</span><br><span class="line"><span class="comment">// DELETE from emails where id = 10;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 带额外条件的删除</span></span><br><span class="line">db.Where(<span class="string">&quot;name = ?&quot;</span>, <span class="string">&quot;jinzhu&quot;</span>).Delete(&amp;email)</span><br><span class="line"><span class="comment">// DELETE from emails where id = 10 AND name = &quot;jinzhu&quot;;</span></span><br></pre></td></tr></table></figure><h3 id="根据主键删除"><a href="#根据主键删除" class="headerlink" title="根据主键删除"></a>根据主键删除</h3><p>GORM 允许通过主键(可以是复合主键)和内联条件来删除对象，它可以使用数字（如以下例子。也可以使用字符串——译者注）。查看 <a href="https://gorm.io/zh_CN/docs/query.html#inline_conditions">查询-内联条件（Query Inline Conditions）</a> 了解详情。</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">db.Delete(&amp;User&#123;&#125;, <span class="number">10</span>)</span><br><span class="line"><span class="comment">// DELETE FROM users WHERE id = 10;</span></span><br><span class="line"></span><br><span class="line">db.Delete(&amp;User&#123;&#125;, <span class="string">&quot;10&quot;</span>)</span><br><span class="line"><span class="comment">// DELETE FROM users WHERE id = 10;</span></span><br><span class="line"></span><br><span class="line">db.Delete(&amp;users, []<span class="type">int</span>&#123;<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>&#125;)</span><br><span class="line"><span class="comment">// DELETE FROM users WHERE id IN (1,2,3);</span></span><br><span class="line"></span><br></pre></td></tr></table></figure><h3 id="批量删除"><a href="#批量删除" class="headerlink" title="批量删除"></a>批量删除</h3><p>如果指定的值不包括主属性，那么 GORM 会执行批量删除，它将删除所有匹配的记录</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">db.Where(<span class="string">&quot;email LIKE ?&quot;</span>, <span class="string">&quot;%jinzhu%&quot;</span>).Delete(&amp;Email&#123;&#125;)</span><br><span class="line"><span class="comment">// DELETE from emails where email LIKE &quot;%jinzhu%&quot;;</span></span><br><span class="line"></span><br><span class="line">db.Delete(&amp;Email&#123;&#125;, <span class="string">&quot;email LIKE ?&quot;</span>, <span class="string">&quot;%jinzhu%&quot;</span>)</span><br><span class="line"><span class="comment">// DELETE from emails where email LIKE &quot;%jinzhu%&quot;;</span></span><br></pre></td></tr></table></figure><p>可以将一个主键切片传递给<code>Delete</code> 方法，以便更高效的删除数据量大的记录</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> users = []User&#123;&#123;ID: <span class="number">1</span>&#125;, &#123;ID: <span class="number">2</span>&#125;, &#123;ID: <span class="number">3</span>&#125;&#125;</span><br><span class="line">db.Delete(&amp;users)</span><br><span class="line"><span class="comment">// DELETE FROM users WHERE id IN (1,2,3);</span></span><br><span class="line"></span><br><span class="line">db.Delete(&amp;users, <span class="string">&quot;name LIKE ?&quot;</span>, <span class="string">&quot;%jinzhu%&quot;</span>)</span><br><span class="line"><span class="comment">// DELETE FROM users WHERE name LIKE &quot;%jinzhu%&quot; AND id IN (1,2,3); </span></span><br></pre></td></tr></table></figure><h4 id="阻止全局删除"><a href="#阻止全局删除" class="headerlink" title="阻止全局删除"></a>阻止全局删除</h4><p>当你试图执行不带任何条件的批量删除时，GORM将不会运行并返回<code>ErrMissingWhereClause</code> 错误</p><p>如果一定要这么做，你必须添加一些条件，或者使用原生SQL，或者开启<code>AllowGlobalUpdate</code> 模式，如下例</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">db.Delete(&amp;User&#123;&#125;).Error <span class="comment">// gorm.ErrMissingWhereClause</span></span><br><span class="line"></span><br><span class="line">db.Delete(&amp;[]User&#123;&#123;Name: <span class="string">&quot;jinzhu1&quot;</span>&#125;, &#123;Name: <span class="string">&quot;jinzhu2&quot;</span>&#125;&#125;).Error <span class="comment">// gorm.ErrMissingWhereClause</span></span><br><span class="line"></span><br><span class="line">db.Where(<span class="string">&quot;1 = 1&quot;</span>).Delete(&amp;User&#123;&#125;)</span><br><span class="line"><span class="comment">// DELETE FROM `users` WHERE 1=1</span></span><br><span class="line"></span><br><span class="line">db.Exec(<span class="string">&quot;DELETE FROM users&quot;</span>)</span><br><span class="line"><span class="comment">// DELETE FROM users</span></span><br><span class="line"></span><br><span class="line">db.Session(&amp;gorm.Session&#123;AllowGlobalUpdate: <span class="literal">true</span>&#125;).Delete(&amp;User&#123;&#125;)</span><br><span class="line"><span class="comment">// DELETE FROM users</span></span><br></pre></td></tr></table></figure><h3 id="返回删除行的数据"><a href="#返回删除行的数据" class="headerlink" title="返回删除行的数据"></a>返回删除行的数据</h3><p>返回被删除的数据，仅当数据库支持回写功能时才能正常运行，如下例：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 回写所有的列</span></span><br><span class="line"><span class="keyword">var</span> users []User</span><br><span class="line">DB.Clauses(clause.Returning&#123;&#125;).Where(<span class="string">&quot;role = ?&quot;</span>, <span class="string">&quot;admin&quot;</span>).Delete(&amp;users)</span><br><span class="line"><span class="comment">// DELETE FROM `users` WHERE role = &quot;admin&quot; RETURNING *</span></span><br><span class="line"><span class="comment">// users =&gt; []User&#123;&#123;ID: 1, Name: &quot;jinzhu&quot;, Role: &quot;admin&quot;, Salary: 100&#125;, &#123;ID: 2, Name: &quot;jinzhu.2&quot;, Role: &quot;admin&quot;, Salary: 1000&#125;&#125;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 回写指定的列</span></span><br><span class="line">DB.Clauses(clause.Returning&#123;Columns: []clause.Column&#123;&#123;Name: <span class="string">&quot;name&quot;</span>&#125;, &#123;Name: <span class="string">&quot;salary&quot;</span>&#125;&#125;&#125;).Where(<span class="string">&quot;role = ?&quot;</span>, <span class="string">&quot;admin&quot;</span>).Delete(&amp;users)</span><br><span class="line"><span class="comment">// DELETE FROM `users` WHERE role = &quot;admin&quot; RETURNING `name`, `salary`</span></span><br><span class="line"><span class="comment">// users =&gt; []User&#123;&#123;ID: 0, Name: &quot;jinzhu&quot;, Role: &quot;&quot;, Salary: 100&#125;, &#123;ID: 0, Name: &quot;jinzhu.2&quot;, Role: &quot;&quot;, Salary: 1000&#125;&#125;</span></span><br></pre></td></tr></table></figure><h3 id="软删除"><a href="#软删除" class="headerlink" title="软删除"></a>软删除</h3><p>如果你的模型包含了 <code>gorm.DeletedAt</code>字段（该字段也被包含在<code>gorm.Model</code>中），那么该模型将会自动获得软删除的能力！</p><p>当调用<code>Delete</code>时，GORM并不会从数据库中删除该记录，而是将该记录的<code>DeleteAt</code>设置为当前时间，而后的一般查询方法将无法查找到此条记录。</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// user&#x27;s ID is `111`</span></span><br><span class="line">db.Delete(&amp;user)</span><br><span class="line"><span class="comment">// UPDATE users SET deleted_at=&quot;2013-10-29 10:23&quot; WHERE id = 111;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// Batch Delete</span></span><br><span class="line">db.Where(<span class="string">&quot;age = ?&quot;</span>, <span class="number">20</span>).Delete(&amp;User&#123;&#125;)</span><br><span class="line"><span class="comment">// UPDATE users SET deleted_at=&quot;2013-10-29 10:23&quot; WHERE age = 20;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// Soft deleted records will be ignored when querying</span></span><br><span class="line">db.Where(<span class="string">&quot;age = 20&quot;</span>).Find(&amp;user)</span><br><span class="line"><span class="comment">// SELECT * FROM users WHERE age = 20 AND deleted_at IS NULL;</span></span><br></pre></td></tr></table></figure><p>如果你并不想嵌套<code>gorm.Model</code>，你也可以像下方例子那样开启软删除特性：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> User <span class="keyword">struct</span> &#123;</span><br><span class="line">  ID      <span class="type">int</span></span><br><span class="line">  Deleted gorm.DeletedAt</span><br><span class="line">  Name    <span class="type">string</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="查找被软删除的记录"><a href="#查找被软删除的记录" class="headerlink" title="查找被软删除的记录"></a>查找被软删除的记录</h4><p>你可以使用<code>Unscoped</code>来查询到被软删除的记录</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">db.Unscoped().Where(<span class="string">&quot;age = 20&quot;</span>).Find(&amp;users)</span><br><span class="line"><span class="comment">// SELECT * FROM users WHERE age = 20;</span></span><br></pre></td></tr></table></figure><h4 id="永久删除"><a href="#永久删除" class="headerlink" title="永久删除"></a>永久删除</h4><p>你可以使用 <code>Unscoped</code>来永久删除匹配的记录</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">db.Unscoped().Delete(&amp;order)// DELETE FROM orders WHERE id=10;</span><br></pre></td></tr></table></figure><h2 id="SQL-构建器"><a href="#SQL-构建器" class="headerlink" title="SQL 构建器"></a>SQL 构建器</h2><h3 id="原生-SQL"><a href="#原生-SQL" class="headerlink" title="原生 SQL"></a>原生 SQL</h3><p>原生查询 SQL 和 <code>Scan</code></p><p>使用原声SQL的时候只能使用Scan的形式去扫描它</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">type Result struct &#123;</span><br><span class="line">  ID   int</span><br><span class="line">  Name string</span><br><span class="line">  Age  int</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">var result Result</span><br><span class="line">db.Raw(&quot;SELECT id, name, age FROM users WHERE id = ?&quot;, 3).Scan(&amp;result)</span><br><span class="line"></span><br><span class="line">db.Raw(&quot;SELECT id, name, age FROM users WHERE name = ?&quot;, &quot;jinzhu&quot;).Scan(&amp;result)</span><br><span class="line"></span><br><span class="line">var age int</span><br><span class="line">db.Raw(&quot;SELECT SUM(age) FROM users WHERE role = ?&quot;, &quot;admin&quot;).Scan(&amp;age)</span><br><span class="line"></span><br><span class="line">var users []User</span><br><span class="line">db.Raw(&quot;UPDATE users SET name = ? WHERE age = ? RETURNING id, name&quot;, &quot;jinzhu&quot;, 20).Scan(&amp;users)</span><br><span class="line"></span><br></pre></td></tr></table></figure><h1 id="关联"><a href="#关联" class="headerlink" title="关联"></a>关联</h1><h2 id="Belongs-To"><a href="#Belongs-To" class="headerlink" title="Belongs To"></a>Belongs To</h2><p><code>belongs to</code> 会与另一个模型建立了一对一的连接。 这种模型的每一个实例都“属于”另一个模型的一个实例。</p><p>例如，您的应用包含 user 和 company，并且每个 user 能且只能被分配给一个 company。下面的类型就表示这种关系。 注意，在 <code>User</code> 对象中，有一个和 <code>Company</code> 一样的 <code>CompanyID</code>。 默认情况下， <code>CompanyID</code> 被隐含地用来在 <code>User</code> 和 <code>Company</code> 之间创建一个外键关系， 因此必须包含在 <code>User</code> 结构体中才能填充 <code>Company</code> 内部结构体。</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// `User` 属于 `Company`，`CompanyID` 是外键</span></span><br><span class="line"><span class="keyword">type</span> User <span class="keyword">struct</span> &#123;</span><br><span class="line">  gorm.Model</span><br><span class="line">  Name      <span class="type">string</span></span><br><span class="line">  CompanyID <span class="type">int</span></span><br><span class="line">  Company   Company</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> Company <span class="keyword">struct</span> &#123;</span><br><span class="line">  ID   <span class="type">int</span></span><br><span class="line">  Name <span class="type">string</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="重写外键"><a href="#重写外键" class="headerlink" title="重写外键"></a>重写外键</h3><p>要定义一个 belongs to 关系，数据库的表中必须存在外键。默认情况下，外键的名字，使用拥有者的类型名称加上表的主键的字段名字</p><p>例如，定义一个User实体属于Company实体，那么外键的名字一般使用CompanyID。</p><p>GORM同时提供自定义外键名字的方式，如下例所示。</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> User <span class="keyword">struct</span> &#123;</span><br><span class="line">  gorm.Model</span><br><span class="line">  Name         <span class="type">string</span></span><br><span class="line">  CompanyRefer <span class="type">int</span></span><br><span class="line">  Company      Company <span class="string">`gorm:&quot;foreignKey:CompanyRefer&quot;`</span></span><br><span class="line">  <span class="comment">// 使用 CompanyRefer 作为外键</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> Company <span class="keyword">struct</span> &#123;</span><br><span class="line">  ID   <span class="type">int</span></span><br><span class="line">  Name <span class="type">string</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="重写引用"><a href="#重写引用" class="headerlink" title="重写引用"></a>重写引用</h3><p>对于 belongs to 关系，GORM 通常使用数据库表，主表（拥有者）的主键值作为外键参考。 正如上面的例子，我们使用主表Company中的主键字段ID作为外键的参考值。</p><p>如果设置了User实体属于Company实体，那么GORM会自动把Company中的<code>ID</code>属性保存到User的<code>CompanyID</code>属性中。</p><p>同样的，您也可以使用标签 <code>references</code> 来更改它，例如：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> User <span class="keyword">struct</span> &#123;</span><br><span class="line">  gorm.Model</span><br><span class="line">  Name      <span class="type">string</span></span><br><span class="line">  CompanyID <span class="type">string</span></span><br><span class="line">  Company   Company <span class="string">`gorm:&quot;references:Code&quot;`</span> <span class="comment">// 使用 Code 作为引用</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> Company <span class="keyword">struct</span> &#123;</span><br><span class="line">  ID   <span class="type">int</span></span><br><span class="line">  Code <span class="type">string</span></span><br><span class="line">  Name <span class="type">string</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> User <span class="keyword">struct</span> &#123;</span><br><span class="line">  gorm.Model</span><br><span class="line">  Name      <span class="type">string</span></span><br><span class="line">  CompanyID <span class="type">string</span></span><br><span class="line">  Company   Company <span class="string">`gorm:&quot;references:CompanyID&quot;`</span> <span class="comment">// 使用 Company.CompanyID 作为引用</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> Company <span class="keyword">struct</span> &#123;</span><br><span class="line">  CompanyID   <span class="type">int</span></span><br><span class="line">  Code        <span class="type">string</span></span><br><span class="line">  Name        <span class="type">string</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="Has-One"><a href="#Has-One" class="headerlink" title="Has One"></a>Has One</h2><p><code>has one</code> 与另一个模型建立一对一的关联，但它和一对一关系有些许不同。 这种关联表明一个模型的每个实例都包含或拥有另一个模型的一个实例。</p><p>例如，您的应用包含 user 和 credit card 模型，且每个 user 只能有一张 credit card。</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// User 有一张 CreditCard，UserID 是外键</span></span><br><span class="line"><span class="keyword">type</span> User <span class="keyword">struct</span> &#123;</span><br><span class="line">  gorm.Model</span><br><span class="line">  CreditCard CreditCard</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> CreditCard <span class="keyword">struct</span> &#123;</span><br><span class="line">  gorm.Model</span><br><span class="line">  Number <span class="type">string</span></span><br><span class="line">  UserID <span class="type">uint</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="重写外键-1"><a href="#重写外键-1" class="headerlink" title="重写外键"></a>重写外键</h3><p>对于 <code>has one</code> 关系，同样必须存在外键字段。拥有者将把属于它的模型的主键保存到这个字段。</p><p>这个字段的名称通常由 <code>has one</code> 模型的类型加上其 <code>主键</code> 生成，对于上面的例子，它是 <code>UserID</code>。</p><p>为 user 添加 credit card 时，它会将 user 的 <code>ID</code> 保存到自己的 <code>UserID</code> 字段。</p><p>如果你想要使用另一个字段来保存该关系，你同样可以使用标签 <code>foreignKey</code> 来更改它，例如：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> User <span class="keyword">struct</span> &#123;</span><br><span class="line">  gorm.Model</span><br><span class="line">  CreditCard CreditCard <span class="string">`gorm:&quot;foreignKey:UserName&quot;`</span> <span class="comment">// 使用 UserName 作为外键</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> CreditCard <span class="keyword">struct</span> &#123;</span><br><span class="line">  gorm.Model</span><br><span class="line">  Number   <span class="type">string</span></span><br><span class="line">  UserName <span class="type">string</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="重写引用-1"><a href="#重写引用-1" class="headerlink" title="重写引用"></a>重写引用</h3><p>默认情况下，拥有者实体会将 <code>has one</code> 对应模型的主键保存为外键，您也可以修改它，用另一个字段来保存，例如下面这个使用 <code>Name</code> 来保存的例子。</p><p>您可以使用标签 <code>references</code> 来更改它，例如：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> User <span class="keyword">struct</span> &#123;</span><br><span class="line">  gorm.Model</span><br><span class="line">  Name       <span class="type">string</span>     <span class="string">`gorm:&quot;index&quot;`</span></span><br><span class="line">  CreditCard CreditCard <span class="string">`gorm:&quot;foreignKey:UserName;references:name&quot;`</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> CreditCard <span class="keyword">struct</span> &#123;</span><br><span class="line">  gorm.Model</span><br><span class="line">  Number   <span class="type">string</span></span><br><span class="line">  UserName <span class="type">string</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="多态关联"><a href="#多态关联" class="headerlink" title="多态关联"></a>多态关联</h3><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> Cat <span class="keyword">struct</span> &#123;</span><br><span class="line">  ID    <span class="type">int</span></span><br><span class="line">  Name  <span class="type">string</span></span><br><span class="line">  Toy   Toy <span class="string">`gorm:&quot;polymorphic:Owner;&quot;`</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> Dog <span class="keyword">struct</span> &#123;</span><br><span class="line">  ID   <span class="type">int</span></span><br><span class="line">  Name <span class="type">string</span></span><br><span class="line">  Toy  Toy <span class="string">`gorm:&quot;polymorphic:Owner;&quot;`</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> Toy <span class="keyword">struct</span> &#123;</span><br><span class="line">  ID        <span class="type">int</span></span><br><span class="line">  Name      <span class="type">string</span></span><br><span class="line">  OwnerID   <span class="type">int</span></span><br><span class="line">  OwnerType <span class="type">string</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">db.Create(&amp;Dog&#123;Name: <span class="string">&quot;dog1&quot;</span>, Toy: Toy&#123;Name: <span class="string">&quot;toy1&quot;</span>&#125;&#125;)</span><br><span class="line"><span class="comment">// INSERT INTO `dogs` (`name`) VALUES (&quot;dog1&quot;)</span></span><br><span class="line"><span class="comment">// INSERT INTO `toys` (`name`,`owner_id`,`owner_type`) VALUES (&quot;toy1&quot;,&quot;1&quot;,&quot;dogs&quot;)</span></span><br></pre></td></tr></table></figure><p>您可以使用标签 <code>polymorphicValue</code> 来更改多态类型的值，例如：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> Dog <span class="keyword">struct</span> &#123;</span><br><span class="line">  ID   <span class="type">int</span></span><br><span class="line">  Name <span class="type">string</span></span><br><span class="line">  Toy  Toy <span class="string">`gorm:&quot;polymorphic:Owner;polymorphicValue:master&quot;`</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> Toy <span class="keyword">struct</span> &#123;</span><br><span class="line">  ID        <span class="type">int</span></span><br><span class="line">  Name      <span class="type">string</span></span><br><span class="line">  OwnerID   <span class="type">int</span></span><br><span class="line">  OwnerType <span class="type">string</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">db.Create(&amp;Dog&#123;Name: <span class="string">&quot;dog1&quot;</span>, Toy: Toy&#123;Name: <span class="string">&quot;toy1&quot;</span>&#125;&#125;)</span><br><span class="line"><span class="comment">// INSERT INTO `dogs` (`name`) VALUES (&quot;dog1&quot;)</span></span><br><span class="line"><span class="comment">// INSERT INTO `toys` (`name`,`owner_id`,`owner_type`) VALUES (&quot;toy1&quot;,&quot;1&quot;,&quot;master&quot;)</span></span><br><span class="line"></span><br></pre></td></tr></table></figure><h2 id="Has-Many"><a href="#Has-Many" class="headerlink" title="Has Many"></a>Has Many</h2><p><code>has many</code> 与另一个模型建立了一对多的连接。 不同于 <code>has one</code>，拥有者可以有零或多个关联模型。</p><p>例如，您的应用包含 user 和 credit card 模型，且每个 user 可以有多张 credit card。</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// User 有多张 CreditCard，UserID 是外键</span></span><br><span class="line"><span class="keyword">type</span> User <span class="keyword">struct</span> &#123;</span><br><span class="line">  gorm.Model</span><br><span class="line">  CreditCards []CreditCard</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> CreditCard <span class="keyword">struct</span> &#123;</span><br><span class="line">  gorm.Model</span><br><span class="line">  Number <span class="type">string</span></span><br><span class="line">  UserID <span class="type">uint</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="重写外键-2"><a href="#重写外键-2" class="headerlink" title="重写外键"></a>重写外键</h3><p>要定义 <code>has many</code> 关系，同样必须存在外键。 默认的外键名是拥有者的类型名加上其主键字段名</p><p>例如，要定义一个属于 <code>User</code> 的模型，则其外键应该是 <code>UserID</code>。</p><p>此外，想要使用另一个字段作为外键，您可以使用 <code>foreignKey</code> 标签自定义它：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> User <span class="keyword">struct</span> &#123;</span><br><span class="line">  gorm.Model</span><br><span class="line">  CreditCards []CreditCard <span class="string">`gorm:&quot;foreignKey:UserRefer&quot;`</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> CreditCard <span class="keyword">struct</span> &#123;</span><br><span class="line">  gorm.Model</span><br><span class="line">  Number    <span class="type">string</span></span><br><span class="line">  UserRefer <span class="type">uint</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="重写引用-2"><a href="#重写引用-2" class="headerlink" title="重写引用"></a>重写引用</h3><p>GORM 通常使用拥有者的主键作为外键的值。 对于上面的例子，它是 <code>User</code> 的 <code>ID</code> 字段。</p><p>为 user 添加 credit card 时，GORM 会将 user 的 <code>ID</code> 字段保存到 credit card 的 <code>UserID</code> 字段。</p><p>同样的，您也可以使用标签 <code>references</code> 来更改它，例如：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> User <span class="keyword">struct</span> &#123;</span><br><span class="line">  gorm.Model</span><br><span class="line">  MemberNumber <span class="type">string</span></span><br><span class="line">  CreditCards  []CreditCard <span class="string">`gorm:&quot;foreignKey:UserNumber;references:MemberNumber&quot;`</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> CreditCard <span class="keyword">struct</span> &#123;</span><br><span class="line">  gorm.Model</span><br><span class="line">  Number     <span class="type">string</span></span><br><span class="line">  UserNumber <span class="type">string</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="多态关联-1"><a href="#多态关联-1" class="headerlink" title="多态关联"></a>多态关联</h3><p>GORM 为 <code>has one</code> 和 <code>has many</code> 提供了多态关联支持，它会将拥有者实体的表名、主键都保存到多态类型的字段中。</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> Dog <span class="keyword">struct</span> &#123;</span><br><span class="line">  ID   <span class="type">int</span></span><br><span class="line">  Name <span class="type">string</span></span><br><span class="line">  Toys []Toy <span class="string">`gorm:&quot;polymorphic:Owner;&quot;`</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> Toy <span class="keyword">struct</span> &#123;</span><br><span class="line">  ID        <span class="type">int</span></span><br><span class="line">  Name      <span class="type">string</span></span><br><span class="line">  OwnerID   <span class="type">int</span></span><br><span class="line">  OwnerType <span class="type">string</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">db.Create(&amp;Dog&#123;Name: <span class="string">&quot;dog1&quot;</span>, Toys: []Toy&#123;&#123;Name: <span class="string">&quot;toy1&quot;</span>&#125;, &#123;Name: <span class="string">&quot;toy2&quot;</span>&#125;&#125;&#125;)</span><br><span class="line"><span class="comment">// INSERT INTO `dogs` (`name`) VALUES (&quot;dog1&quot;)</span></span><br><span class="line"><span class="comment">// INSERT INTO `toys` (`name`,`owner_id`,`owner_type`) VALUES (&quot;toy1&quot;,&quot;1&quot;,&quot;dogs&quot;), (&quot;toy2&quot;,&quot;1&quot;,&quot;dogs&quot;)</span></span><br><span class="line"></span><br></pre></td></tr></table></figure><p>您可以使用标签 <code>polymorphicValue</code> 来更改多态类型的值，例如：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="keyword">type</span> Dog <span class="keyword">struct</span> &#123;</span><br><span class="line">  ID   <span class="type">int</span></span><br><span class="line">  Name <span class="type">string</span></span><br><span class="line">  Toys []Toy <span class="string">`gorm:&quot;polymorphic:Owner;polymorphicValue:master&quot;`</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> Toy <span class="keyword">struct</span> &#123;</span><br><span class="line">  ID        <span class="type">int</span></span><br><span class="line">  Name      <span class="type">string</span></span><br><span class="line">  OwnerID   <span class="type">int</span></span><br><span class="line">  OwnerType <span class="type">string</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">db.Create(&amp;Dog&#123;Name: <span class="string">&quot;dog1&quot;</span>, Toys: []Toy&#123;&#123;Name: <span class="string">&quot;toy1&quot;</span>&#125;, &#123;Name: <span class="string">&quot;toy2&quot;</span>&#125;&#125;&#125;)</span><br><span class="line"><span class="comment">// INSERT INTO `dogs` (`name`) VALUES (&quot;dog1&quot;)</span></span><br><span class="line"><span class="comment">// INSERT INTO `toys` (`name`,`owner_id`,`owner_type`) VALUES (&quot;toy1&quot;,&quot;1&quot;,&quot;master&quot;), (&quot;toy2&quot;,&quot;1&quot;,&quot;master&quot;)</span></span><br><span class="line"></span><br></pre></td></tr></table></figure><h2 id="Many-To-Many"><a href="#Many-To-Many" class="headerlink" title="Many To Many"></a>Many To Many</h2><p>Many to Many 会在两个 model 中添加一张连接表。</p><p>例如，您的应用包含了 user 和 language，且一个 user 可以说多种 language，多个 user 也可以说一种 language。</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// User 拥有并属于多种 language，`user_languages` 是连接表</span></span><br><span class="line"><span class="keyword">type</span> User <span class="keyword">struct</span> &#123;</span><br><span class="line">  gorm.Model</span><br><span class="line">  Languages []Language <span class="string">`gorm:&quot;many2many:user_languages;&quot;`</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> Language <span class="keyword">struct</span> &#123;</span><br><span class="line">  gorm.Model</span><br><span class="line">  Name <span class="type">string</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>当使用 GORM 的 <code>AutoMigrate</code> 为 <code>User</code> 创建表时，GORM 会自动创建连接表</p><h3 id="反向引用"><a href="#反向引用" class="headerlink" title="反向引用"></a>反向引用</h3><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// User 拥有并属于多种 language，`user_languages` 是连接表</span></span><br><span class="line"><span class="keyword">type</span> User <span class="keyword">struct</span> &#123;</span><br><span class="line">  gorm.Model</span><br><span class="line">  Languages []*Language <span class="string">`gorm:&quot;many2many:user_languages;&quot;`</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> Language <span class="keyword">struct</span> &#123;</span><br><span class="line">  gorm.Model</span><br><span class="line">  Name <span class="type">string</span></span><br><span class="line">  Users []*User <span class="string">`gorm:&quot;many2many:user_languages;&quot;`</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="重写外键-3"><a href="#重写外键-3" class="headerlink" title="重写外键"></a>重写外键</h3><p>对于 <code>many2many</code> 关系，连接表会同时拥有两个模型的外键，例如：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> User <span class="keyword">struct</span> &#123;</span><br><span class="line">  gorm.Model</span><br><span class="line">  Languages []Language <span class="string">`gorm:&quot;many2many:user_languages;&quot;`</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> Language <span class="keyword">struct</span> &#123;</span><br><span class="line">  gorm.Model</span><br><span class="line">  Name <span class="type">string</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 连接表：user_languages</span></span><br><span class="line"><span class="comment">//   foreign key: user_id, reference: users.id</span></span><br><span class="line"><span class="comment">//   foreign key: language_id, reference: languages.id</span></span><br></pre></td></tr></table></figure><p>若要重写它们，可以使用标签 <code>foreignKey</code>、<code>references</code>、<code>joinforeignKey</code>、<code>joinReferences</code>。当然，您不需要使用全部的标签，你可以仅使用其中的一个重写部分的外键、引用。</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> User <span class="keyword">struct</span> &#123;</span><br><span class="line">    gorm.Model</span><br><span class="line">    Profiles []Profile <span class="string">`gorm:&quot;many2many:user_profiles;foreignKey:Refer;joinForeignKey:UserReferID;References:UserRefer;joinReferences:ProfileRefer&quot;`</span></span><br><span class="line">    Refer    <span class="type">uint</span>      <span class="string">`gorm:&quot;index:,unique&quot;`</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> Profile <span class="keyword">struct</span> &#123;</span><br><span class="line">    gorm.Model</span><br><span class="line">    Name      <span class="type">string</span></span><br><span class="line">    UserRefer <span class="type">uint</span> <span class="string">`gorm:&quot;index:,unique&quot;`</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 会创建连接表：user_profiles</span></span><br><span class="line"><span class="comment">//   foreign key: user_refer_id, reference: users.refer</span></span><br><span class="line"><span class="comment">//   foreign key: profile_refer, reference: profiles.user_refer</span></span><br></pre></td></tr></table></figure><h1 id="事务"><a href="#事务" class="headerlink" title="事务"></a>事务</h1><h2 id="禁用默认事务"><a href="#禁用默认事务" class="headerlink" title="禁用默认事务"></a>禁用默认事务</h2><p>为了确保数据一致性，GORM 会在事务里执行写入操作（创建、更新、删除）。如果没有这方面的要求，您可以在初始化时禁用它，这将获得大约 30%+ 性能提升。</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 全局禁用</span></span><br><span class="line">db, err := gorm.Open(sqlite.Open(<span class="string">&quot;gorm.db&quot;</span>), &amp;gorm.Config&#123;</span><br><span class="line">  SkipDefaultTransaction: <span class="literal">true</span>,</span><br><span class="line">&#125;)</span><br><span class="line"></span><br><span class="line"><span class="comment">// 持续会话模式</span></span><br><span class="line">tx := db.Session(&amp;Session&#123;SkipDefaultTransaction: <span class="literal">true</span>&#125;)</span><br><span class="line">tx.First(&amp;user, <span class="number">1</span>)</span><br><span class="line">tx.Find(&amp;users)</span><br><span class="line">tx.Model(&amp;user).Update(<span class="string">&quot;Age&quot;</span>, <span class="number">18</span>)</span><br></pre></td></tr></table></figure><h2 id="事务-1"><a href="#事务-1" class="headerlink" title="事务"></a>事务</h2><p>要在事务中执行一系列操作，一般流程如下：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">db.Transaction(<span class="function"><span class="keyword">func</span><span class="params">(tx *gorm.DB)</span></span> <span class="type">error</span> &#123;</span><br><span class="line">  <span class="comment">// 在事务中执行一些 db 操作（从这里开始，您应该使用 &#x27;tx&#x27; 而不是 &#x27;db&#x27;）</span></span><br><span class="line">  <span class="keyword">if</span> err := tx.Create(&amp;Animal&#123;Name: <span class="string">&quot;Giraffe&quot;</span>&#125;).Error; err != <span class="literal">nil</span> &#123;</span><br><span class="line">    <span class="comment">// 返回任何错误都会回滚事务</span></span><br><span class="line">    <span class="keyword">return</span> err</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span> err := tx.Create(&amp;Animal&#123;Name: <span class="string">&quot;Lion&quot;</span>&#125;).Error; err != <span class="literal">nil</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> err</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 返回 nil 提交事务</span></span><br><span class="line">  <span class="keyword">return</span> <span class="literal">nil</span></span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure><h2 id="嵌套事务"><a href="#嵌套事务" class="headerlink" title="嵌套事务"></a>嵌套事务</h2><p>GORM 支持嵌套事务，您可以回滚较大事务内执行的一部分操作，例如：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">db.Transaction(<span class="function"><span class="keyword">func</span><span class="params">(tx *gorm.DB)</span></span> <span class="type">error</span> &#123;</span><br><span class="line">  tx.Create(&amp;user1)</span><br><span class="line"></span><br><span class="line">  tx.Transaction(<span class="function"><span class="keyword">func</span><span class="params">(tx2 *gorm.DB)</span></span> <span class="type">error</span> &#123;</span><br><span class="line">    tx2.Create(&amp;user2)</span><br><span class="line">    <span class="keyword">return</span> errors.New(<span class="string">&quot;rollback user2&quot;</span>) <span class="comment">// Rollback user2</span></span><br><span class="line">  &#125;)</span><br><span class="line"></span><br><span class="line">  tx.Transaction(<span class="function"><span class="keyword">func</span><span class="params">(tx2 *gorm.DB)</span></span> <span class="type">error</span> &#123;</span><br><span class="line">    tx2.Create(&amp;user3)</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">nil</span></span><br><span class="line">  &#125;)</span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> <span class="literal">nil</span></span><br><span class="line">&#125;)</span><br><span class="line"></span><br><span class="line"><span class="comment">// Commit user1, user3</span></span><br></pre></td></tr></table></figure><h2 id="手动事务"><a href="#手动事务" class="headerlink" title="手动事务"></a>手动事务</h2><p>Gorm 支持直接调用事务控制方法（commit、rollback），例如：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 开始事务</span></span><br><span class="line">tx := db.Begin()</span><br><span class="line"></span><br><span class="line"><span class="comment">// 在事务中执行一些 db 操作（从这里开始，您应该使用 &#x27;tx&#x27; 而不是 &#x27;db&#x27;）</span></span><br><span class="line">tx.Create(...)</span><br><span class="line"></span><br><span class="line"><span class="comment">// ...</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 遇到错误时回滚事务</span></span><br><span class="line">tx.Rollback()</span><br><span class="line"></span><br><span class="line"><span class="comment">// 否则，提交事务</span></span><br><span class="line">tx.Commit()</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> Golang </category>
          
          <category> mysql </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Golang </tag>
            
            <tag> mysql </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Go_Redis</title>
      <link href="/2023/07/02/go_Redis/"/>
      <url>/2023/07/02/go_Redis/</url>
      
        <content type="html"><![CDATA[<h1 id="Go-Redis入门"><a href="#Go-Redis入门" class="headerlink" title="Go_Redis入门"></a>Go_Redis入门</h1><p>之前是已经学习完了redis的基本用法，现在开始学习go中的一款redis框架用于操作redis。在使用之前当然得先准备好redis环境，这里就不多做赘述。</p><p>本文大多数内容参自go-redis的官方文档</p><h2 id="安装"><a href="#安装" class="headerlink" title="安装"></a>安装</h2><p>Go 社区中目前有很多成熟的 redis client 库，比如[<a href="https://github.com/gomodule/redigo">https://github.com/gomodule/redigo</a> 和<a href="https://github.com/go-redis/redis%EF%BC%8C%E5%8F%AF%E4%BB%A5%E8%87%AA%E8%A1%8C%E9%80%89%E6%8B%A9%E9%80%82%E5%90%88%E8%87%AA%E5%B7%B1%E7%9A%84%E5%BA%93%E3%80%82">https://github.com/go-redis/redis，可以自行选择适合自己的库。</a></p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">go</span> get github.com/<span class="keyword">go</span>-redis/redis/v8</span><br></pre></td></tr></table></figure><h2 id="连接"><a href="#连接" class="headerlink" title="连接"></a>连接</h2><h3 id="普通连接"><a href="#普通连接" class="headerlink" title="普通连接"></a>普通连接</h3><p>goredis使用redis.NewClient函数连接Redis服务器</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">red := redis.NewClient(&amp;redis.Options&#123;</span><br><span class="line">Addr:     <span class="string">&quot;localhost:6379&quot;</span>,</span><br><span class="line">Password: <span class="string">&quot;&quot;</span>,</span><br><span class="line">DB:       <span class="number">0</span>,</span><br><span class="line">&#125;)</span><br><span class="line">fmt.Println(red)</span><br><span class="line">fmt.Println(<span class="string">&quot;test_______GoRedis&quot;</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>redis.Options是redis配置文件，其定义如下：</p><figure class="highlight golang"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> Options <span class="keyword">struct</span> &#123;</span><br><span class="line"><span class="comment">// The network type, either tcp or unix.</span></span><br><span class="line"><span class="comment">// Default is tcp.</span></span><br><span class="line">Network <span class="type">string</span></span><br><span class="line"><span class="comment">// host:port address.</span></span><br><span class="line">Addr <span class="type">string</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// Dialer creates new network connection and has priority over</span></span><br><span class="line"><span class="comment">// Network and Addr options.</span></span><br><span class="line">Dialer <span class="function"><span class="keyword">func</span><span class="params">(ctx context.Context, network, addr <span class="type">string</span>)</span></span> (net.Conn, <span class="type">error</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment">// Hook that is called when new connection is established.</span></span><br><span class="line">OnConnect <span class="function"><span class="keyword">func</span><span class="params">(ctx context.Context, cn *Conn)</span></span> <span class="type">error</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// Use the specified Username to authenticate the current connection</span></span><br><span class="line"><span class="comment">// with one of the connections defined in the ACL list when connecting</span></span><br><span class="line"><span class="comment">// to a Redis 6.0 instance, or greater, that is using the Redis ACL system.</span></span><br><span class="line">Username <span class="type">string</span></span><br><span class="line"><span class="comment">// Optional password. Must match the password specified in the</span></span><br><span class="line"><span class="comment">// requirepass server configuration option (if connecting to a Redis 5.0 instance, or lower),</span></span><br><span class="line"><span class="comment">// or the User Password when connecting to a Redis 6.0 instance, or greater,</span></span><br><span class="line"><span class="comment">// that is using the Redis ACL system.</span></span><br><span class="line">Password <span class="type">string</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// Database to be selected after connecting to the server.</span></span><br><span class="line">DB <span class="type">int</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// Maximum number of retries before giving up.</span></span><br><span class="line"><span class="comment">// Default is 3 retries; -1 (not 0) disables retries.</span></span><br><span class="line">MaxRetries <span class="type">int</span></span><br><span class="line"><span class="comment">// Minimum backoff between each retry.</span></span><br><span class="line"><span class="comment">// Default is 8 milliseconds; -1 disables backoff.</span></span><br><span class="line">MinRetryBackoff time.Duration</span><br><span class="line"><span class="comment">// Maximum backoff between each retry.</span></span><br><span class="line"><span class="comment">// Default is 512 milliseconds; -1 disables backoff.</span></span><br><span class="line">MaxRetryBackoff time.Duration</span><br><span class="line"></span><br><span class="line"><span class="comment">// Dial timeout for establishing new connections.</span></span><br><span class="line"><span class="comment">// Default is 5 seconds.</span></span><br><span class="line">DialTimeout time.Duration</span><br><span class="line"><span class="comment">// Timeout for socket reads. If reached, commands will fail</span></span><br><span class="line"><span class="comment">// with a timeout instead of blocking. Use value -1 for no timeout and 0 for default.</span></span><br><span class="line"><span class="comment">// Default is 3 seconds.</span></span><br><span class="line">ReadTimeout time.Duration</span><br><span class="line"><span class="comment">// Timeout for socket writes. If reached, commands will fail</span></span><br><span class="line"><span class="comment">// with a timeout instead of blocking.</span></span><br><span class="line"><span class="comment">// Default is ReadTimeout.</span></span><br><span class="line">WriteTimeout time.Duration</span><br><span class="line"></span><br><span class="line"><span class="comment">// Type of connection pool.</span></span><br><span class="line"><span class="comment">// true for FIFO pool, false for LIFO pool.</span></span><br><span class="line"><span class="comment">// Note that fifo has higher overhead compared to lifo.</span></span><br><span class="line">PoolFIFO <span class="type">bool</span></span><br><span class="line"><span class="comment">// Maximum number of socket connections.</span></span><br><span class="line"><span class="comment">// Default is 10 connections per every available CPU as reported by runtime.GOMAXPROCS.</span></span><br><span class="line">PoolSize <span class="type">int</span></span><br><span class="line"><span class="comment">// Minimum number of idle connections which is useful when establishing</span></span><br><span class="line"><span class="comment">// new connection is slow.</span></span><br><span class="line">MinIdleConns <span class="type">int</span></span><br><span class="line"><span class="comment">// Connection age at which client retires (closes) the connection.</span></span><br><span class="line"><span class="comment">// Default is to not close aged connections.</span></span><br><span class="line">MaxConnAge time.Duration</span><br><span class="line"><span class="comment">// Amount of time client waits for connection if all connections</span></span><br><span class="line"><span class="comment">// are busy before returning an error.</span></span><br><span class="line"><span class="comment">// Default is ReadTimeout + 1 second.</span></span><br><span class="line">PoolTimeout time.Duration</span><br><span class="line"><span class="comment">// Amount of time after which client closes idle connections.</span></span><br><span class="line"><span class="comment">// Should be less than server&#x27;s timeout.</span></span><br><span class="line"><span class="comment">// Default is 5 minutes. -1 disables idle timeout check.</span></span><br><span class="line">IdleTimeout time.Duration</span><br><span class="line"><span class="comment">// Frequency of idle checks made by idle connections reaper.</span></span><br><span class="line"><span class="comment">// Default is 1 minute. -1 disables idle connections reaper,</span></span><br><span class="line"><span class="comment">// but idle connections are still discarded by the client</span></span><br><span class="line"><span class="comment">// if IdleTimeout is set.</span></span><br><span class="line">IdleCheckFrequency time.Duration</span><br><span class="line"></span><br><span class="line"><span class="comment">// Enables read only queries on slave nodes.</span></span><br><span class="line">readOnly <span class="type">bool</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// TLS Config to use. When set TLS will be negotiated.</span></span><br><span class="line">TLSConfig *tls.Config</span><br><span class="line"><span class="comment">// Limiter interface used to implemented circuit breaker or rate limiter.</span></span><br><span class="line">Limiter Limiter</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>也可以使用redis.ParseURL解析url参数来获取opt，再以此连接redis，其基本格式为：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="string">&quot;redis://&lt;user&gt;:&lt;pass&gt;@localhost:6379/&lt;db&gt;&quot;</span></span><br></pre></td></tr></table></figure><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">opt,err:=redis.ParseURL(<span class="string">&quot;redis://:@localhost:6379/0&quot;</span>)</span><br><span class="line"><span class="keyword">if</span> err!=<span class="literal">nil</span>&#123;</span><br><span class="line">log.Fatal(err)</span><br><span class="line">&#125;</span><br><span class="line">rdb := redis.NewClient(opt)</span><br><span class="line">fmt.Println(rdb)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>另外还有TLS，SSH方式，但是我计网基础不行，理解不了，后续我把计算机网络相关知识搞了再来整整吧。</p><h2 id="Context-上下文"><a href="#Context-上下文" class="headerlink" title="Context 上下文"></a>Context 上下文</h2><p>go-redis 支持 Context，你可以使用它控制 <a href="https://redis.uptrace.dev/zh/guide/go-redis-debugging.html#timeouts">超时</a> 或者传递一些数据, 也可以 <a href="https://redis.uptrace.dev/zh/guide/go-redis-monitoring.html">监控</a> go-redis 性能。</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ctx := context.Background()</span><br></pre></td></tr></table></figure><h2 id="执行-Redis-命令"><a href="#执行-Redis-命令" class="headerlink" title="执行 Redis 命令"></a>执行 Redis 命令</h2><p>执行 Redis 命令:</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">val, err := rdb.Get(ctx, <span class="string">&quot;key&quot;</span>).Result()</span><br><span class="line">fmt.Println(val)</span><br></pre></td></tr></table></figure><p>你也可以分别访问值和错误：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">get := rdb.Get(ctx, <span class="string">&quot;key&quot;</span>)</span><br><span class="line">fmt.Println(get.Val(), get.Err())</span><br></pre></td></tr></table></figure><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">ctx := context.Background()</span><br><span class="line">opt, err := redis.ParseURL(<span class="string">&quot;redis://:@localhost:6379/0&quot;</span>)</span><br><span class="line"><span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">log.Fatal(err)</span><br><span class="line">&#125;</span><br><span class="line">    </span><br><span class="line">rdb := redis.NewClient(opt)</span><br><span class="line">val, err := rdb.Get(ctx, <span class="string">&quot;k1&quot;</span>).Result()</span><br><span class="line"><span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">log.Fatal(err)</span><br><span class="line">&#125;</span><br><span class="line">fmt.Println(rdb)</span><br><span class="line">fmt.Println(val)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//output:</span></span><br><span class="line"><span class="comment">//Redis&lt;localhost:6379 db:0&gt;</span></span><br><span class="line"><span class="comment">//v1</span></span><br></pre></td></tr></table></figure><h2 id="不支持的命令"><a href="#不支持的命令" class="headerlink" title="不支持的命令"></a>不支持的命令</h2><p>可以使用 <code>Do()</code> 方法执行尚不支持或者任意命令:</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">val, err := rdb.Do(ctx, <span class="string">&quot;get&quot;</span>, <span class="string">&quot;key&quot;</span>).Result()</span><br><span class="line"><span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line"><span class="keyword">if</span> err == redis.Nil &#123;</span><br><span class="line">fmt.Println(<span class="string">&quot;key does not exists&quot;</span>)</span><br><span class="line"><span class="keyword">return</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">panic</span>(err)</span><br><span class="line">&#125;</span><br><span class="line">fmt.Println(val.(<span class="type">string</span>))</span><br></pre></td></tr></table></figure><p><code>Do()</code> 方法返回 <a href="https://pkg.go.dev/github.com/redis/go-redis/v9#Cmd">Cmd在新窗口打开</a> 类型，你可以使用它获取你想要的类型：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">val, err := rdb.Do(ctx, <span class="string">&quot;get&quot;</span>, <span class="string">&quot;key&quot;</span>).Text()</span><br><span class="line">fmt.Println(val, err)</span><br></pre></td></tr></table></figure><p>方法列表:</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">s, err := cmd.Text()</span><br><span class="line">flag, err := cmd.Bool()</span><br><span class="line"></span><br><span class="line">num, err := cmd.Int()</span><br><span class="line">num, err := cmd.Int64()</span><br><span class="line">num, err := cmd.Uint64()</span><br><span class="line">num, err := cmd.Float32()</span><br><span class="line">num, err := cmd.Float64()</span><br><span class="line"></span><br><span class="line">ss, err := cmd.StringSlice()</span><br><span class="line">ns, err := cmd.Int64Slice()</span><br><span class="line">ns, err := cmd.Uint64Slice()</span><br><span class="line">fs, err := cmd.Float32Slice()</span><br><span class="line">fs, err := cmd.Float64Slice()</span><br><span class="line">bs, err := cmd.BoolSlice()</span><br></pre></td></tr></table></figure><p>例如想要使用redis的HGET命令就可以这么传</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">ctx1 := context.Background()</span><br><span class="line">val1, err := rdb.Do(ctx1, <span class="string">&quot;HGET&quot;</span>, <span class="string">&quot;redisHash&quot;</span>, <span class="string">&quot;f1&quot;</span>).Text()</span><br><span class="line"><span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">log.Fatal(err)</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//output:v1</span></span><br></pre></td></tr></table></figure><h2 id="redis-Nil"><a href="#redis-Nil" class="headerlink" title="redis.Nil"></a>redis.Nil</h2><p><code>redis.Nil</code> 是一种特殊的错误，严格意义上来说它并不是错误，而是代表一种状态，例如你使用 Get 命令获取 key 的值，当 key 不存在时，返回 <code>redis.Nil</code>。在其他比如 <code>BLPOP</code> 、 <code>ZSCORE</code> 也有类似的响应，你需要区分错误：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">val, err := rdb.Get(ctx, <span class="string">&quot;key&quot;</span>).Result()</span><br><span class="line"><span class="keyword">switch</span> &#123;</span><br><span class="line"><span class="keyword">case</span> err == redis.Nil:</span><br><span class="line">fmt.Println(<span class="string">&quot;key不存在&quot;</span>)</span><br><span class="line"><span class="keyword">case</span> err != <span class="literal">nil</span>:</span><br><span class="line">fmt.Println(<span class="string">&quot;错误&quot;</span>, err)</span><br><span class="line"><span class="keyword">case</span> val == <span class="string">&quot;&quot;</span>:</span><br><span class="line">fmt.Println(<span class="string">&quot;值是空字符串&quot;</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="Conn"><a href="#Conn" class="headerlink" title="Conn"></a>Conn</h2><p>redis.Conn 是从连接池中取出的单个连接，除非你有特殊的需要，否则尽量不要使用它。你可以使用它向 redis 发送任何数据并读取 redis 的响应，当你使用完毕时，应该把它返回给 go-redis，否则连接池会永远丢失一个连接。</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">cn := rdb.Conn(ctx)</span><br><span class="line"><span class="keyword">defer</span> cn.Close()</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> err := cn.ClientSetName(ctx, <span class="string">&quot;myclient&quot;</span>).Err(); err != <span class="literal">nil</span> &#123;</span><br><span class="line"><span class="built_in">panic</span>(err)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">name, err := cn.ClientGetName(ctx).Result()</span><br><span class="line"><span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line"><span class="built_in">panic</span>(err)</span><br><span class="line">&#125;</span><br><span class="line">fmt.Println(<span class="string">&quot;client name&quot;</span>, name)</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> golang </category>
          
          <category> redis </category>
          
      </categories>
      
      
        <tags>
            
            <tag> golang </tag>
            
            <tag> redis </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Go语言底层剖析</title>
      <link href="/2023/07/02/Go%E8%AF%AD%E8%A8%80%E6%BA%90%E7%A0%81%E5%89%96%E6%9E%90/"/>
      <url>/2023/07/02/Go%E8%AF%AD%E8%A8%80%E6%BA%90%E7%A0%81%E5%89%96%E6%9E%90/</url>
      
        <content type="html"><![CDATA[<p>本文主要介绍slice channel 和map等golang中比较重要的数据结构底层</p><h1 id="Channel"><a href="#Channel" class="headerlink" title="Channel"></a>Channel</h1><h2 id="channel基本概念"><a href="#channel基本概念" class="headerlink" title="channel基本概念"></a>channel基本概念</h2><p>在Go语言中，channel是一种类型，它可以用来在协程之间传递数据。channel类型的定义如下：</p><figure class="highlight golang"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">chan</span> T</span><br></pre></td></tr></table></figure><h3 id="构造"><a href="#构造" class="headerlink" title="构造"></a>构造</h3><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">ch1 :=<span class="built_in">make</span>(<span class="keyword">chan</span> <span class="type">int</span>)<span class="comment">//无缓冲channel</span></span><br><span class="line">ch2 :=<span class="built_in">make</span>(<span class="keyword">chan</span> <span class="type">int</span>,<span class="number">10</span>)<span class="comment">//有缓冲channel</span></span><br></pre></td></tr></table></figure><h3 id="读写"><a href="#读写" class="headerlink" title="读写"></a>读写</h3><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">val :=&lt;- ch</span><br><span class="line">&lt;-ch</span><br><span class="line">val,ok :=&lt;-ch</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> data <span class="type">int</span></span><br><span class="line">ch &lt;- data</span><br></pre></td></tr></table></figure><h3 id="关闭"><a href="#关闭" class="headerlink" title="关闭"></a>关闭</h3><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">close</span>(ch)</span><br></pre></td></tr></table></figure><hr><h3 id="Select"><a href="#Select" class="headerlink" title="Select"></a>Select</h3><p>select里的case后面并不带判断条件，而是一个信道的操作，不同于switch里的case，对于从其它语言转过来的开发者来说有些需要特别注意的地方。</p><p>golang 的 select 就是监听 IO 操作，当 IO 操作发生时，触发相应的动作每个case语句里必须是一个IO操作，确切的说，应该是一个面向channel的IO操作。</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">select</span> &#123;</span><br><span class="line">    <span class="keyword">case</span> &lt;-ch1:</span><br><span class="line">        <span class="comment">// 如果从 ch1 信道成功接收数据，则执行该分支代码</span></span><br><span class="line">    <span class="keyword">case</span> ch2 &lt;- <span class="number">1</span>:</span><br><span class="line">        <span class="comment">// 如果成功向 ch2 信道成功发送数据，则执行该分支代码</span></span><br><span class="line">    <span class="keyword">default</span>:</span><br><span class="line">        <span class="comment">// 如果上面都没有成功，则进入 default 分支处理流程</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>如果 <code>ch1</code> 或者 <code>ch2</code> 信道都阻塞的话，就会立即进入 <code>default</code> 分支，并不会阻塞。但是如果没有 <code>default</code> 语句，则会阻塞直到某个信道操作成功为止</p><h4 id="Select特性"><a href="#Select特性" class="headerlink" title="Select特性"></a>Select特性</h4><ul><li><p>select语句只能用于信道的读写操作</p></li><li><p>xxxxxxxxxx type hchan struct {  qcount   uint           &#x2F;&#x2F; chan中的数据个数  dataqsiz uint           &#x2F;&#x2F; chan中的元素容量  buf      unsafe.Pointer &#x2F;&#x2F; chan中的元素队列（环形数组）  elemsize uint16 &#x2F;&#x2F;chan元素类型的大小  closed   uint32 &#x2F;&#x2F; 标识channel是否关闭  elemtype *_type &#x2F;&#x2F; 数据 元素类型  sendx    uint   &#x2F;&#x2F; 写入元素的 index  recvx    uint   &#x2F;&#x2F; 读取元素的 index  recvq    waitq  &#x2F;&#x2F; 阻塞的读协程队列  sendq    waitq  &#x2F;&#x2F; 阻塞的写协程队列    lock mutex  &#x2F;&#x2F; 锁 }go</p></li><li><p>对于case条件语句中，如果存在信道值为nil的读写操作，则该分支将被忽略，可以理解为从select语句中删除了这个case语句</p></li><li><p>如果有超时条件语句，判断逻辑为如果在这个时间段内一直没有满足条件的case,则执行这个超时case。如果此段时间内出现了可操作的case,则直接执行这个case。一般用超时语句代替了default语句</p></li><li><p>对于空的select{}，会引起死锁</p></li><li><p>对于for中的select{}, 也有可能会引起cpu占用过高的问题</p></li></ul><hr><h3 id="特性"><a href="#特性" class="headerlink" title="特性"></a>特性</h3><p>Go语言中的channel具有以下几个特性：</p><p><em><strong>线程安全</strong></em><br>channel是线程安全的，多个协程可以同时读写一个channel，而不会发生数据竞争的问题。这是因为Go语言中的channel内部实现了锁机制，保证了多个协程之间对channel的访问是安全的。</p><p><em><strong>阻塞式发送和接收</strong></em><br>当一个协程向一个channel发送数据时，如果channel已经满了，发送操作会被阻塞，直到有其他协程从channel中取走了数据。同样地，当一个协程从一个channel中接收数据时，如果channel中没有数据可供接收，接收操作会被阻塞，直到有其他协程向channel中发送了数据。这种阻塞式的机制可以保证协程之间的同步和通信。</p><p><em><strong>顺序性</strong></em><br>通过channel发送的数据是按照发送的顺序进行排列的。也就是说，如果协程A先向channel中发送了数据x，而协程B再向channel中发送了数据y，那么从channel中接收数据时，先接收到的一定是x，后接收到的一定是y。</p><p><em><strong>可以关闭</strong></em><br>通过关闭channel可以通知其他协程这个channel已经不再使用了。关闭一个channel之后，其他协程仍然可以从中接收数据，但是不能再向其中发送数据了。关闭channel的操作可以避免内存泄漏等问题。</p><p><em><strong>缓冲区大小</strong></em><br>channel可以带有一个缓冲区，用于存储一定量的数据。如果缓冲区已经满了，发送操作会被阻塞，直到有其他协程从channel中取走了数据；如果缓冲区已经空了，接收操作会被阻塞，直到有其他协程向channel中发送了数据。缓冲区的大小可以在创建channel时指定，例如：</p><h2 id="channel底层数据结构"><a href="#channel底层数据结构" class="headerlink" title="channel底层数据结构"></a>channel底层数据结构</h2><p>chan的实现在runtime&#x2F;chan.go下，是一个hchan的结构体：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> hchan <span class="keyword">struct</span> &#123;</span><br><span class="line">  qcount   <span class="type">uint</span>           <span class="comment">// chan中的数据个数</span></span><br><span class="line">  dataqsiz <span class="type">uint</span>           <span class="comment">// chan中的元素容量</span></span><br><span class="line">  buf      unsafe.Pointer <span class="comment">// chan中的元素队列（环形数组）</span></span><br><span class="line">  elemsize <span class="type">uint16</span> <span class="comment">//chan元素类型的大小</span></span><br><span class="line">  closed   <span class="type">uint32</span> <span class="comment">// 标识channel是否关闭</span></span><br><span class="line">  elemtype *_type <span class="comment">// 数据 元素类型</span></span><br><span class="line">  sendx    <span class="type">uint</span>   <span class="comment">// 写入元素的 index</span></span><br><span class="line">  recvx    <span class="type">uint</span>   <span class="comment">// 读取元素的 index</span></span><br><span class="line">  recvq    waitq  <span class="comment">// 阻塞的读协程队列</span></span><br><span class="line">  sendq    waitq  <span class="comment">// 阻塞的写协程队列</span></span><br><span class="line">  </span><br><span class="line">  lock mutex  <span class="comment">// 锁 </span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>waitq的底层实现</p><figure class="highlight golang"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//阻塞的协程队列</span></span><br><span class="line"><span class="keyword">type</span> waitq <span class="keyword">struct</span>&#123;</span><br><span class="line">    first *sudog<span class="comment">//队列头部</span></span><br><span class="line">    last *sudog<span class="comment">//队列尾部</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>sudog的底层<br>sudog本质上是对goroutinue的一个再封装</p><figure class="highlight golang"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//用于包装协程的节点</span></span><br><span class="line"><span class="keyword">type</span> sudog <span class="keyword">struct</span>&#123;</span><br><span class="line">    g *g <span class="comment">//协程</span></span><br><span class="line"></span><br><span class="line">    next *sudog<span class="comment">//队列中的下一个节点</span></span><br><span class="line">    prev *sudog<span class="comment">//队列中的前一个节点</span></span><br><span class="line">    elem unsafe.Pointer <span class="comment">//data element(may point to stack)</span></span><br><span class="line"></span><br><span class="line">    inSelect <span class="type">bool</span><span class="comment">//是否处于select多路复用的模式下</span></span><br><span class="line"></span><br><span class="line">    c *hchan<span class="comment">//标识与当前sudog交互的chan</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><h2 id="创建channel"><a href="#创建channel" class="headerlink" title="创建channel"></a>创建channel</h2><p>当我们在代码里面通过make创建一个channel时，实际调用的是*<strong>runtime.makechan(t <em>chantype, size int)</em></strong>,</p><p>channel的类型有三种：  </p><ol><li>无缓冲类型的channel</li><li>有缓冲struct类型的channel</li><li>有缓冲pointer类型的channel</li></ol><p>makechan()实现：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">makechan</span><span class="params">(t *chantype, size <span class="type">int</span>)</span></span> *hchan &#123;</span><br><span class="line">  elem := t.elem</span><br><span class="line">  <span class="comment">// 判断 元素类型的大小</span></span><br><span class="line">  <span class="keyword">if</span> elem.size &gt;= <span class="number">1</span>&lt;&lt;<span class="number">16</span> &#123;</span><br><span class="line">    throw(<span class="string">&quot;makechan: invalid channel element type&quot;</span>)</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">// 判断对齐限制</span></span><br><span class="line">  <span class="keyword">if</span> hchanSize%maxAlign != <span class="number">0</span> || elem.align &gt; maxAlign &#123;</span><br><span class="line">    throw(<span class="string">&quot;makechan: bad alignment&quot;</span>)</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">// 判断 size非负 和 是否大于 maxAlloc限制</span></span><br><span class="line">  <span class="comment">// 缓冲区大小</span></span><br><span class="line">  mem, overflow := math.MulUintptr(elem.size, <span class="type">uintptr</span>(size))</span><br><span class="line">  <span class="keyword">if</span> overflow || mem &gt; maxAlloc-hchanSize || size &lt; <span class="number">0</span> &#123;</span><br><span class="line">    <span class="built_in">panic</span>(plainError(<span class="string">&quot;makechan: size out of range&quot;</span>))</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">var</span> c *hchan</span><br><span class="line">  <span class="keyword">switch</span> &#123;</span><br><span class="line">  <span class="keyword">case</span> mem == <span class="number">0</span>: <span class="comment">// 无缓冲区，即 make没设置大小</span></span><br><span class="line">    c = (*hchan)(mallocgc(hchanSize, <span class="literal">nil</span>, <span class="literal">true</span>)) </span><br><span class="line">    c.buf = c.raceaddr()</span><br><span class="line">  <span class="keyword">case</span> elem.ptrdata == <span class="number">0</span>:  <span class="comment">// 数据类型不包含指针</span></span><br><span class="line">    c = (*hchan)(mallocgc(hchanSize+mem, <span class="literal">nil</span>, <span class="literal">true</span>))</span><br><span class="line">    c.buf = add(unsafe.Pointer(c), hchanSize)</span><br><span class="line">  <span class="keyword">default</span>:  <span class="comment">// 如果包含指针</span></span><br><span class="line">    <span class="comment">// Elements contain pointers.</span></span><br><span class="line">    c = <span class="built_in">new</span>(hchan)</span><br><span class="line">    c.buf = mallocgc(mem, elem, <span class="literal">true</span>)</span><br><span class="line">  &#125;</span><br><span class="line">  c.elemsize = <span class="type">uint16</span>(elem.size)</span><br><span class="line">  c.elemtype = elem</span><br><span class="line">  c.dataqsiz = <span class="type">uint</span>(size)</span><br><span class="line">  <span class="keyword">if</span> debugChan &#123;</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&quot;makechan: chan=&quot;</span>, c, <span class="string">&quot;; elemsize=&quot;</span>, elem.size, <span class="string">&quot;; dataqsiz=&quot;</span>, size, <span class="string">&quot;\n&quot;</span>)</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> c</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><h2 id="写流程"><a href="#写流程" class="headerlink" title="写流程"></a>写流程</h2><h3 id="异常情况处理"><a href="#异常情况处理" class="headerlink" title="异常情况处理"></a>异常情况处理</h3><p>此处chansend源码已省略。</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">chansend1</span><span class="params">(c *hchan,elem unsafe.Pointer)</span></span>&#123;</span><br><span class="line">    chansend(c,elem,<span class="literal">true</span>,getcallerpc())</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">chansend</span><span class="params">(c *hchan, ep unsafe.Pointer, block <span class="type">bool</span>, callerpc <span class="type">uintptr</span>)</span></span> <span class="type">bool</span> &#123;</span><br><span class="line"><span class="keyword">if</span> c == <span class="literal">nil</span> &#123;<span class="comment">//未初始化的channel，抛出异常死锁</span></span><br><span class="line"><span class="keyword">if</span> !block &#123;</span><br><span class="line"><span class="keyword">return</span> <span class="literal">false</span></span><br><span class="line">&#125;</span><br><span class="line">gopark(<span class="literal">nil</span>, <span class="literal">nil</span>, waitReasonChanSendNilChan, traceEvGoStop, <span class="number">2</span>)</span><br><span class="line">throw(<span class="string">&quot;unreachable&quot;</span>)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">    ...</span><br><span class="line"></span><br><span class="line">lock(&amp;c.lock)</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> c.closed != <span class="number">0</span> &#123;<span class="comment">//往已关闭的channel中写数据</span></span><br><span class="line">unlock(&amp;c.lock)</span><br><span class="line"><span class="built_in">panic</span>(plainError(<span class="string">&quot;send on closed channel&quot;</span>))</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">...</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><ol><li>对于未初始化的chan，写操作引发死锁</li><li>对于已关闭的chan，写操作引发panic</li></ol><h3 id="写时存在阻塞读协程"><a href="#写时存在阻塞读协程" class="headerlink" title="写时存在阻塞读协程"></a>写时存在阻塞读协程</h3><p>存在阻塞读协程，显然表明channel底层的环形数组为空</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">chansend</span><span class="params">(c *hchan, ep unsafe.Pointer, block <span class="type">bool</span>, callerpc <span class="type">uintptr</span>)</span></span> <span class="type">bool</span> &#123;</span><br><span class="line"></span><br><span class="line">...</span><br><span class="line"></span><br><span class="line">lock(&amp;c.lock)</span><br><span class="line"></span><br><span class="line">...</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> sg := c.recvq.dequeue(); sg != <span class="literal">nil</span> &#123;</span><br><span class="line"></span><br><span class="line">send(c, sg, ep, <span class="function"><span class="keyword">func</span><span class="params">()</span></span> &#123; unlock(&amp;c.lock) &#125;, <span class="number">3</span>)</span><br><span class="line"><span class="keyword">return</span> <span class="literal">true</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><ol><li>加锁保证并发安全</li><li>从阻塞读协程队列中取出一个goroutinue的封装对象sudog</li><li>在send方法中，会给予memmove方法，直接将元素拷贝交给sudog对应的goroutinue</li><li>在send的方法中会完成解锁动作</li></ol><h3 id="写时无阻塞读协程但环形缓冲区仍然有空间"><a href="#写时无阻塞读协程但环形缓冲区仍然有空间" class="headerlink" title="写时无阻塞读协程但环形缓冲区仍然有空间"></a>写时无阻塞读协程但环形缓冲区仍然有空间</h3><p>如果写时无阻塞读协程但是环形缓冲区仍然有空间，那么则将对应的数据放入缓冲区即可。</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">chansend</span><span class="params">(c *hchan, ep unsafe.Pointer, block <span class="type">bool</span>, callerpc <span class="type">uintptr</span>)</span></span> <span class="type">bool</span> &#123;</span><br><span class="line">...</span><br><span class="line"></span><br><span class="line">lock(&amp;c.lock)</span><br><span class="line"></span><br><span class="line">...</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> c.qcount &lt; c.dataqsiz &#123;</span><br><span class="line"></span><br><span class="line">qp := chanbuf(c, c.sendx)</span><br><span class="line"><span class="keyword">if</span> raceenabled &#123;</span><br><span class="line">racenotify(c, c.sendx, <span class="literal">nil</span>)</span><br><span class="line">&#125;</span><br><span class="line">typedmemmove(c.elemtype, qp, ep)</span><br><span class="line">c.sendx++<span class="comment">//写数据对应的指针，标明新添加的数据应该写入环形数组的哪一个凹槽之中</span></span><br><span class="line"><span class="keyword">if</span> c.sendx == c.dataqsiz &#123;</span><br><span class="line">c.sendx = <span class="number">0</span></span><br><span class="line">&#125;<span class="comment">//环形</span></span><br><span class="line">c.qcount++<span class="comment">//元素数量</span></span><br><span class="line">unlock(&amp;c.lock)<span class="comment">//解锁</span></span><br><span class="line"><span class="keyword">return</span> <span class="literal">true</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">...</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><ol><li>加锁</li><li>将当前元素添加到环形缓冲区sendx对应的位置</li><li>sendx++</li><li>qcount++</li><li>解锁返回true</li></ol><h3 id="写时无阻塞读协程且环形缓冲区没有空间"><a href="#写时无阻塞读协程且环形缓冲区没有空间" class="headerlink" title="写时无阻塞读协程且环形缓冲区没有空间"></a>写时无阻塞读协程且环形缓冲区没有空间</h3><p>将当前的写goroutinue添加到对应的阻塞的写协程队列</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">chansend</span><span class="params">(c *hchan, ep unsafe.Pointer, block <span class="type">bool</span>, callerpc <span class="type">uintptr</span>)</span></span> <span class="type">bool</span> &#123;</span><br><span class="line"></span><br><span class="line">    ...</span><br><span class="line"></span><br><span class="line">lock(&amp;c.lock)</span><br><span class="line"></span><br><span class="line">    ...</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">gp := getg()<span class="comment">//返回当前goroutinue的一个引用</span></span><br><span class="line">mysg := acquireSudog()</span><br><span class="line">mysg.releasetime = <span class="number">0</span></span><br><span class="line"><span class="keyword">if</span> t0 != <span class="number">0</span> &#123;</span><br><span class="line">mysg.releasetime = <span class="number">-1</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">mysg.elem = ep</span><br><span class="line">mysg.waitlink = <span class="literal">nil</span></span><br><span class="line">mysg.g = gp</span><br><span class="line">mysg.isSelect = <span class="literal">false</span></span><br><span class="line">mysg.c = c</span><br><span class="line">gp.waiting = mysg</span><br><span class="line">gp.param = <span class="literal">nil</span></span><br><span class="line">c.sendq.enqueue(mysg)<span class="comment">//包装节点并且添加到写协程阻塞队列中</span></span><br><span class="line"></span><br><span class="line">gp.parkingOnChan.Store(<span class="literal">true</span>)</span><br><span class="line">gopark(chanparkcommit, unsafe.Pointer(&amp;c.lock), waitReasonChanSend, traceEvGoBlockSend, <span class="number">2</span>)</span><br><span class="line">    <span class="comment">//阻塞微停</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">KeepAlive(ep)</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> mysg != gp.waiting &#123;</span><br><span class="line">throw(<span class="string">&quot;G waiting list is corrupted&quot;</span>)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">gp.waiting = <span class="literal">nil</span></span><br><span class="line">gp.activeStackChans = <span class="literal">false</span></span><br><span class="line">closed := !mysg.success</span><br><span class="line">gp.param = <span class="literal">nil</span></span><br><span class="line"><span class="keyword">if</span> mysg.releasetime &gt; <span class="number">0</span> &#123;</span><br><span class="line">blockevent(mysg.releasetime-t0, <span class="number">2</span>)</span><br><span class="line">&#125;</span><br><span class="line">mysg.c = <span class="literal">nil</span></span><br><span class="line">releaseSudog(mysg)</span><br><span class="line"><span class="keyword">if</span> closed &#123;</span><br><span class="line"><span class="keyword">if</span> c.closed == <span class="number">0</span> &#123;</span><br><span class="line">throw(<span class="string">&quot;chansend: spurious wakeup&quot;</span>)</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">panic</span>(plainError(<span class="string">&quot;send on closed channel&quot;</span>))</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> <span class="literal">true</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><ol><li>加锁</li><li>构造封装当前goroutinue的sudog对象</li><li>完成指针指向，建立sudog，goroutinue，channel之间的指向关系</li><li>把sudog添加到当前的channel的阻塞写协程队列之中</li><li>park（微停阻塞）当前协程</li><li>倘若协程从park中被唤醒，则回收sudog（sudog能被唤醒，则对应的goroutinue一定已经被读协程队列取走）</li><li>解锁返回true</li></ol><h3 id="写总流程"><a href="#写总流程" class="headerlink" title="写总流程"></a>写总流程</h3><p>![channel](.&#x2F;Go语言底层剖析&#x2F;channel写流程 .png)</p><h2 id="读流程"><a href="#读流程" class="headerlink" title="读流程"></a>读流程</h2><h3 id="异常情况处理-1"><a href="#异常情况处理-1" class="headerlink" title="异常情况处理"></a>异常情况处理</h3><p>读空channel</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">chanrecv</span><span class="params">(c *hchan, ep unsafe.Pointer, block <span class="type">bool</span>)</span></span> (selected, received <span class="type">bool</span>) &#123;</span><br><span class="line">    <span class="keyword">if</span> c == <span class="literal">nil</span> &#123;</span><br><span class="line">        gopark(<span class="literal">nil</span>, <span class="literal">nil</span>, waitReasonChanReceiveNilChan, traceEvGoStop, <span class="number">2</span>)</span><br><span class="line">        throw(<span class="string">&quot;unreachable&quot;</span>)</span><br><span class="line">    &#125;</span><br><span class="line">     ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ol><li>park 挂起，引起死锁；</li></ol><p>channel 已关闭且内部无元素</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">chanrecv</span><span class="params">(c *hchan, ep unsafe.Pointer, block <span class="type">bool</span>)</span></span> (selected, received <span class="type">bool</span>) &#123;</span><br><span class="line">  </span><br><span class="line">    lock(&amp;c.lock)</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> c.closed != <span class="number">0</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> c.qcount == <span class="number">0</span> &#123;</span><br><span class="line">            unlock(&amp;c.lock)</span><br><span class="line">            <span class="keyword">if</span> ep != <span class="literal">nil</span> &#123;</span><br><span class="line">                typedmemclr(c.elemtype, ep)</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">true</span>, <span class="literal">false</span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// The channel has been closed, but the channel&#x27;s buffer have data.</span></span><br><span class="line">    &#125; </span><br><span class="line"></span><br><span class="line">     ...</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>直接解锁返回即可</p><hr><h3 id="读时有阻塞的写协程"><a href="#读时有阻塞的写协程" class="headerlink" title="读时有阻塞的写协程"></a>读时有阻塞的写协程</h3><p>有阻塞的写协程则channel一定满了</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">chanrecv</span><span class="params">(c *hchan, ep unsafe.Pointer, block <span class="type">bool</span>)</span></span> (selected, received <span class="type">bool</span>) &#123;</span><br><span class="line">   </span><br><span class="line">    lock(&amp;c.lock)</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> sg := c.sendq.dequeue(); sg != <span class="literal">nil</span> &#123;</span><br><span class="line">        recv(c, sg, ep, <span class="function"><span class="keyword">func</span><span class="params">()</span></span> &#123; unlock(&amp;c.lock) &#125;, <span class="number">3</span>)</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span>, <span class="literal">true</span></span><br><span class="line">     &#125;</span><br><span class="line">      ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ol><li>加锁；</li><li>从阻塞写协程队列中获取到一个写协程；</li><li>倘若 channel 无缓冲区，则直接读取写协程元素，并唤醒写协程；</li><li>倘若 channel 有缓冲区，则读取缓冲区头部元素，并将写协程元素写入缓冲区尾部后唤醒写写成；</li><li>解锁，返回.</li></ol><hr><h3 id="读时无阻塞写协程且缓冲区有元素"><a href="#读时无阻塞写协程且缓冲区有元素" class="headerlink" title="读时无阻塞写协程且缓冲区有元素"></a>读时无阻塞写协程且缓冲区有元素</h3> <figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">chanrecv</span><span class="params">(c *hchan, ep unsafe.Pointer, block <span class="type">bool</span>)</span></span> (selected, received <span class="type">bool</span>) &#123;</span><br><span class="line">     ...</span><br><span class="line">    lock(&amp;c.lock)</span><br><span class="line">     ...</span><br><span class="line">    <span class="keyword">if</span> c.qcount &gt; <span class="number">0</span> &#123;</span><br><span class="line">        <span class="comment">// Receive directly from queue</span></span><br><span class="line">        qp := chanbuf(c, c.recvx)</span><br><span class="line">        <span class="keyword">if</span> ep != <span class="literal">nil</span> &#123;</span><br><span class="line">            typedmemmove(c.elemtype, ep, qp)</span><br><span class="line">        &#125;</span><br><span class="line">        typedmemclr(c.elemtype, qp)</span><br><span class="line">        c.recvx++</span><br><span class="line">        <span class="keyword">if</span> c.recvx == c.dataqsiz &#123;</span><br><span class="line">            c.recvx = <span class="number">0</span></span><br><span class="line">        &#125;</span><br><span class="line">        c.qcount--</span><br><span class="line">        unlock(&amp;c.lock)</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span>, <span class="literal">true</span></span><br><span class="line">    &#125;</span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ol><li>加锁</li><li>获取到recvx对应位置的元素</li><li>recvx++</li><li>qcount–</li><li>解锁返回true</li></ol><hr><h3 id="读时无阻塞写协程且缓冲区无元素"><a href="#读时无阻塞写协程且缓冲区无元素" class="headerlink" title="读时无阻塞写协程且缓冲区无元素"></a>读时无阻塞写协程且缓冲区无元素</h3><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">chanrecv</span><span class="params">(c *hchan, ep unsafe.Pointer, block <span class="type">bool</span>)</span></span> (selected, received <span class="type">bool</span>) &#123;</span><br><span class="line">    ...</span><br><span class="line">   lock(&amp;c.lock)</span><br><span class="line">    ...</span><br><span class="line">    gp := getg()</span><br><span class="line">    mysg := acquireSudog()</span><br><span class="line">    mysg.elem = ep</span><br><span class="line">    gp.waiting = mysg</span><br><span class="line">    mysg.g = gp</span><br><span class="line">    mysg.c = c</span><br><span class="line">    gp.param = <span class="literal">nil</span></span><br><span class="line">    c.recvq.enqueue(mysg)</span><br><span class="line">    atomic.Store8(&amp;gp.parkingOnChan, <span class="number">1</span>)</span><br><span class="line">    gopark(chanparkcommit, unsafe.Pointer(&amp;c.lock), waitReasonChanReceive, traceEvGoBlockRecv, <span class="number">2</span>)</span><br><span class="line"></span><br><span class="line">    gp.waiting = <span class="literal">nil</span></span><br><span class="line">    success := mysg.success</span><br><span class="line">    gp.param = <span class="literal">nil</span></span><br><span class="line">    mysg.c = <span class="literal">nil</span></span><br><span class="line">    releaseSudog(mysg)</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">true</span>, success</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ol><li>加锁</li><li>构造封装当前的gorountinue的sudog对象</li><li>完成指针指向，建立sudog，goroutinue，channel之间的指向关系</li><li>把sudog添加到当前的阻塞读协程队列之中</li><li>park（微停阻塞）当前的协程</li><li>倘若协程从park中被唤醒，则回收sudog（因为该协程被唤醒，那么就一定代表有元素写入了环形队列中）</li><li>解锁返回</li></ol><h3 id="读总流程"><a href="#读总流程" class="headerlink" title="读总流程"></a>读总流程</h3><p><img src="/2023/07/02/Go%E8%AF%AD%E8%A8%80%E6%BA%90%E7%A0%81%E5%89%96%E6%9E%90/channel%E8%AF%BB%E6%B5%81%E7%A8%8B.png" alt="channel"></p><h2 id="阻塞模式和非阻塞模式"><a href="#阻塞模式和非阻塞模式" class="headerlink" title="阻塞模式和非阻塞模式"></a>阻塞模式和非阻塞模式</h2><p>在上述源码分析流程中，均是以阻塞模式为主线进行讲述，忽略非阻塞模式的有关处理逻辑. 此处阐明两个问题：</p><ul><li>非阻塞模式下，流程逻辑有何区别？</li><li>何时会进入非阻塞模式？</li></ul><h3 id="非阻塞模式逻辑区别"><a href="#非阻塞模式逻辑区别" class="headerlink" title="非阻塞模式逻辑区别"></a>非阻塞模式逻辑区别</h3><p>非阻塞模式下，读&#x2F;写 channel 方法通过一个 bool 型的响应参数，用以标识是否读取&#x2F;写入成功.</p><ul><li>所有需要使得当前 goroutine 被挂起的操作，在非阻塞模式下都会返回 false；</li><li>所有使得当前 goroutine 会进入死锁的操作，在非阻塞模式下都会返回 false；</li><li>所有能立即完成读取&#x2F;写入操作的条件下，非阻塞模式下会返回 true.</li></ul><p>例如如下代码，如果即将使得当前goroutinue被挂起park，切当前为非阻塞模式，那么就会直接return false</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> c == <span class="literal">nil</span> &#123;</span><br><span class="line"><span class="keyword">if</span> !block &#123;</span><br><span class="line"><span class="keyword">return</span> <span class="literal">false</span></span><br><span class="line">&#125;</span><br><span class="line">gopark(<span class="literal">nil</span>, <span class="literal">nil</span>, waitReasonChanSendNilChan, traceEvGoStop, <span class="number">2</span>)</span><br><span class="line">throw(<span class="string">&quot;unreachable&quot;</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="何时进入非阻塞模式"><a href="#何时进入非阻塞模式" class="headerlink" title="何时进入非阻塞模式"></a>何时进入非阻塞模式</h3><p>默认情况下，读&#x2F;写 channel 都是阻塞模式，只有在 select 语句组成的多路复用分支中，与 channel 的交互会变成非阻塞模式：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">select</span> &#123;</span><br><span class="line">    <span class="keyword">case</span> &lt;-ch1:</span><br><span class="line">        <span class="comment">// 如果从 ch1 信道成功接收数据，则执行该分支代码</span></span><br><span class="line">    <span class="keyword">case</span> ch2 &lt;- <span class="number">1</span>:</span><br><span class="line">        <span class="comment">// 如果成功向 ch2 信道成功发送数据，则执行该分支代码</span></span><br><span class="line">    <span class="keyword">default</span>:</span><br><span class="line">        <span class="comment">// 如果上面都没有成功，则进入 default 分支处理流程</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="非阻塞模式代码一览"><a href="#非阻塞模式代码一览" class="headerlink" title="非阻塞模式代码一览"></a>非阻塞模式代码一览</h3><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">selectnbsend</span><span class="params">(c *hchan, elem unsafe.Pointer)</span></span> (selected <span class="type">bool</span>) &#123;</span><br><span class="line">    <span class="keyword">return</span> chansend(c, elem, <span class="literal">false</span>, getcallerpc())</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">selectnbrecv</span><span class="params">(elem unsafe.Pointer, c *hchan)</span></span> (selected, received <span class="type">bool</span>) &#123;</span><br><span class="line">    <span class="keyword">return</span> chanrecv(c, elem, <span class="literal">false</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在 select 语句包裹的多路复用分支中，读和写 channel 操作会被汇编为 selectnbrecv 和 selectnbsend 方法，底层同样复用 chanrecv 和 chansend 方法，但此时由于第三个入参 block 被设置为 false，导致后续会走进非阻塞的处理分支.</p><h2 id="两种读channel协议"><a href="#两种读channel协议" class="headerlink" title="两种读channel协议"></a>两种读channel协议</h2><p>读取 channel 时，可以根据第二个 bool 型的返回值用以判断当前 channel 是否已处于关闭状态：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">ch := <span class="built_in">make</span>(<span class="keyword">chan</span> <span class="type">int</span>, <span class="number">2</span>)</span><br><span class="line">got1 := &lt;- ch</span><br><span class="line">got2,ok := &lt;- ch</span><br></pre></td></tr></table></figure><p>实现上述功能的原因是，两种格式下，读 channel 操作会被汇编成不同的方法：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">chanrecv1</span><span class="params">(c *hchan, elem unsafe.Pointer)</span></span> &#123;</span><br><span class="line">    chanrecv(c, elem, <span class="literal">true</span>)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//go:nosplit</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">chanrecv2</span><span class="params">(c *hchan, elem unsafe.Pointer)</span></span> (received <span class="type">bool</span>) &#123;</span><br><span class="line">    _, received = chanrecv(c, elem, <span class="literal">true</span>)</span><br><span class="line">    <span class="keyword">return</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>如果对某一个chan写入一个0值，然后又要读取这个chan，此时，无论这个channel是否关闭，都能读取到0，如果想要知道channel是被关了，还是真实的有这笔数据，我们需要进行如下处理：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">ch&lt;<span class="number">-0</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> val,ok:=&lt;-ch;ok&#123;</span><br><span class="line">    <span class="comment">//open</span></span><br><span class="line">&#125;<span class="keyword">else</span>&#123;</span><br><span class="line">    <span class="comment">//close</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="关闭-1"><a href="#关闭-1" class="headerlink" title="关闭"></a>关闭</h2><p>closechan执行流程</p><p><img src="/2023/07/02/Go%E8%AF%AD%E8%A8%80%E6%BA%90%E7%A0%81%E5%89%96%E6%9E%90/channel%E5%85%B3%E9%97%AD.png" alt="channel"></p><p>closechan源码：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">closechan</span><span class="params">(c *hchan)</span></span> &#123;</span><br><span class="line"><span class="keyword">if</span> c == <span class="literal">nil</span> &#123;</span><br><span class="line"><span class="built_in">panic</span>(plainError(<span class="string">&quot;close of nil channel&quot;</span>))</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">lock(&amp;c.lock)</span><br><span class="line"><span class="keyword">if</span> c.closed != <span class="number">0</span> &#123;</span><br><span class="line">unlock(&amp;c.lock)</span><br><span class="line"><span class="built_in">panic</span>(plainError(<span class="string">&quot;close of closed channel&quot;</span>))</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> raceenabled &#123;</span><br><span class="line">callerpc := getcallerpc()</span><br><span class="line">racewritepc(c.raceaddr(), callerpc, abi.FuncPCABIInternal(closechan))</span><br><span class="line">racerelease(c.raceaddr())</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">c.closed = <span class="number">1</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> glist gList</span><br><span class="line"></span><br><span class="line"><span class="comment">// release all readers</span></span><br><span class="line"><span class="keyword">for</span> &#123;</span><br><span class="line">sg := c.recvq.dequeue()</span><br><span class="line"><span class="keyword">if</span> sg == <span class="literal">nil</span> &#123;</span><br><span class="line"><span class="keyword">break</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">if</span> sg.elem != <span class="literal">nil</span> &#123;</span><br><span class="line">typedmemclr(c.elemtype, sg.elem)</span><br><span class="line">sg.elem = <span class="literal">nil</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">if</span> sg.releasetime != <span class="number">0</span> &#123;</span><br><span class="line">sg.releasetime = cputicks()</span><br><span class="line">&#125;</span><br><span class="line">gp := sg.g</span><br><span class="line">gp.param = unsafe.Pointer(sg)</span><br><span class="line">sg.success = <span class="literal">false</span></span><br><span class="line"><span class="keyword">if</span> raceenabled &#123;</span><br><span class="line">raceacquireg(gp, c.raceaddr())</span><br><span class="line">&#125;</span><br><span class="line">glist.push(gp)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// release all writers (they will panic)</span></span><br><span class="line"><span class="keyword">for</span> &#123;</span><br><span class="line">sg := c.sendq.dequeue()</span><br><span class="line"><span class="keyword">if</span> sg == <span class="literal">nil</span> &#123;</span><br><span class="line"><span class="keyword">break</span></span><br><span class="line">&#125;</span><br><span class="line">sg.elem = <span class="literal">nil</span></span><br><span class="line"><span class="keyword">if</span> sg.releasetime != <span class="number">0</span> &#123;</span><br><span class="line">sg.releasetime = cputicks()</span><br><span class="line">&#125;</span><br><span class="line">gp := sg.g</span><br><span class="line">gp.param = unsafe.Pointer(sg)</span><br><span class="line">sg.success = <span class="literal">false</span></span><br><span class="line"><span class="keyword">if</span> raceenabled &#123;</span><br><span class="line">raceacquireg(gp, c.raceaddr())</span><br><span class="line">&#125;</span><br><span class="line">glist.push(gp)</span><br><span class="line">&#125;</span><br><span class="line">unlock(&amp;c.lock)</span><br><span class="line"></span><br><span class="line"><span class="comment">// Ready all Gs now that we&#x27;ve dropped the channel lock.</span></span><br><span class="line"><span class="keyword">for</span> !glist.empty() &#123;</span><br><span class="line">gp := glist.pop()</span><br><span class="line">gp.schedlink = <span class="number">0</span></span><br><span class="line">goready(gp, <span class="number">3</span>)</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> Golang </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>TestImage</title>
      <link href="/2023/07/02/TestImage/"/>
      <url>/2023/07/02/TestImage/</url>
      
        <content type="html"><![CDATA[<p><em><strong>测试MarkDown内插入的图片能否在博客内显示</strong></em></p><p><img src="/2023/07/02/TestImage/lingmeng.jpg" alt="Image1"></p>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>Go语言底层剖析</title>
      <link href="/2023/07/01/Go%E8%AF%AD%E8%A8%80%E5%BA%95%E5%B1%82%E5%89%96%E6%9E%90/"/>
      <url>/2023/07/01/Go%E8%AF%AD%E8%A8%80%E5%BA%95%E5%B1%82%E5%89%96%E6%9E%90/</url>
      
        <content type="html"><![CDATA[<p>本文主要介绍slice channel 和map等golang中比较重要的数据结构底层</p><h1 id="Channel"><a href="#Channel" class="headerlink" title="Channel"></a>Channel</h1><h2 id="channel基本概念"><a href="#channel基本概念" class="headerlink" title="channel基本概念"></a>channel基本概念</h2><p>在Go语言中，channel是一种类型，它可以用来在协程之间传递数据。channel类型的定义如下：</p><figure class="highlight golang"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">chan</span> T</span><br></pre></td></tr></table></figure><p>构造：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">ch1 :=<span class="built_in">make</span>(<span class="keyword">chan</span> <span class="type">int</span>)<span class="comment">//无缓冲channel</span></span><br><span class="line">ch2 :=<span class="built_in">make</span>(<span class="keyword">chan</span> <span class="type">int</span>,<span class="number">10</span>)<span class="comment">//有缓冲channel</span></span><br></pre></td></tr></table></figure><p>读写：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">val :=&lt;- ch</span><br><span class="line">&lt;-ch</span><br><span class="line">val,ok :=&lt;-ch</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> data <span class="type">int</span></span><br><span class="line">ch &lt;- data</span><br></pre></td></tr></table></figure><p>关闭：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">close</span>(ch)</span><br></pre></td></tr></table></figure><p>select 是 Go 中的一个控制结构。select 语句类似于 switch 语句，但是select会随机执行一个可运行的case。如果没有case可运行，它将阻塞，直到有case可运行。</p><p>select是Golang在语言层面提供的多路IO复用的机制，其可以检测多个channel是否ready(即是否可读或可写)，使用起来非常方便。</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">select</span> &#123;</span><br><span class="line">    <span class="keyword">case</span> communication clause:</span><br><span class="line">        statement(s);</span><br><span class="line">    <span class="keyword">case</span> communication clause:</span><br><span class="line">        statement(s);</span><br><span class="line">    <span class="keyword">default</span>:</span><br><span class="line">        statement(s);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="特性"><a href="#特性" class="headerlink" title="特性"></a>特性</h3><p>Go语言中的channel具有以下几个特性：</p><p><em><strong>线程安全</strong></em><br>channel是线程安全的，多个协程可以同时读写一个channel，而不会发生数据竞争的问题。这是因为Go语言中的channel内部实现了锁机制，保证了多个协程之间对channel的访问是安全的。</p><p><em><strong>阻塞式发送和接收</strong></em><br>当一个协程向一个channel发送数据时，如果channel已经满了，发送操作会被阻塞，直到有其他协程从channel中取走了数据。同样地，当一个协程从一个channel中接收数据时，如果channel中没有数据可供接收，接收操作会被阻塞，直到有其他协程向channel中发送了数据。这种阻塞式的机制可以保证协程之间的同步和通信。</p><p><em><strong>顺序性</strong></em><br>通过channel发送的数据是按照发送的顺序进行排列的。也就是说，如果协程A先向channel中发送了数据x，而协程B再向channel中发送了数据y，那么从channel中接收数据时，先接收到的一定是x，后接收到的一定是y。</p><p><em><strong>可以关闭</strong></em><br>通过关闭channel可以通知其他协程这个channel已经不再使用了。关闭一个channel之后，其他协程仍然可以从中接收数据，但是不能再向其中发送数据了。关闭channel的操作可以避免内存泄漏等问题。</p><p><em><strong>缓冲区大小</strong></em><br>channel可以带有一个缓冲区，用于存储一定量的数据。如果缓冲区已经满了，发送操作会被阻塞，直到有其他协程从channel中取走了数据；如果缓冲区已经空了，接收操作会被阻塞，直到有其他协程向channel中发送了数据。缓冲区的大小可以在创建channel时指定，例如：</p><h2 id="channel底层数据结构"><a href="#channel底层数据结构" class="headerlink" title="channel底层数据结构"></a>channel底层数据结构</h2><p>chan的实现在runtime&#x2F;chan.go下，是一个hchan的结构体：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> hchan <span class="keyword">struct</span> &#123;</span><br><span class="line">  qcount   <span class="type">uint</span>           <span class="comment">// chan中的数据个数</span></span><br><span class="line">  dataqsiz <span class="type">uint</span>           <span class="comment">// chan中的元素容量</span></span><br><span class="line">  buf      unsafe.Pointer <span class="comment">// chan中的元素队列（环形数组）</span></span><br><span class="line">  elemsize <span class="type">uint16</span> <span class="comment">//chan元素类型的大小</span></span><br><span class="line">  closed   <span class="type">uint32</span> <span class="comment">// 标识channel是否关闭</span></span><br><span class="line">  elemtype *_type <span class="comment">// 数据 元素类型</span></span><br><span class="line">  sendx    <span class="type">uint</span>   <span class="comment">// 写入元素的 index</span></span><br><span class="line">  recvx    <span class="type">uint</span>   <span class="comment">// 读取元素的 index</span></span><br><span class="line">  recvq    waitq  <span class="comment">// 阻塞的读协程队列</span></span><br><span class="line">  sendq    waitq  <span class="comment">// 阻塞的写协程队列</span></span><br><span class="line">  </span><br><span class="line">  lock mutex  <span class="comment">// 锁 </span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> Golang </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>算法板子</title>
      <link href="/2023/07/01/%E7%AE%97%E6%B3%95%E6%9D%BF%E5%AD%90%E6%B1%87%E6%80%BB/"/>
      <url>/2023/07/01/%E7%AE%97%E6%B3%95%E6%9D%BF%E5%AD%90%E6%B1%87%E6%80%BB/</url>
      
        <content type="html"><![CDATA[<h1 id="排序算法"><a href="#排序算法" class="headerlink" title="排序算法"></a>排序算法</h1><h2 id="计数排序"><a href="#计数排序" class="headerlink" title="计数排序"></a>计数排序</h2><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">countsort</span><span class="params">(<span class="type">int</span>* a, <span class="type">int</span> n)</span><span class="comment">//计数排序</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt;= n; i++)</span><br><span class="line">    &#123;</span><br><span class="line">        cnt[a[i]]++;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> j = <span class="number">1</span>; j &lt;= Max; j++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> k = <span class="number">0</span>; k &lt; cnt[j]; k++)</span><br><span class="line">            cout &lt;&lt; j &lt;&lt; <span class="string">&quot; &quot;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="希尔排序"><a href="#希尔排序" class="headerlink" title="希尔排序"></a>希尔排序</h2><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">ShellSort</span><span class="params">(<span class="type">int</span>* arr, <span class="type">int</span> n)</span></span></span><br><span class="line"><span class="function"><span class="comment">//shell排序，基本思想：有点类似于分组排序，数组下标为i的值与下标为i+shell(如果n为奇数，还存在与i+2*shelll进行比较的情况）的值进行比较，如果比他大就交换，反之就小，i从0遍历到n-shell（想想也知道只用遍历一半吧）</span></span></span><br><span class="line"><span class="function"><span class="comment">//然后shell自除以2，再重复上述操作。</span></span></span><br><span class="line"><span class="function"><span class="comment">//最后当shell为0时，数组便排列好了。</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="type">int</span> shell=n;</span><br><span class="line">    <span class="keyword">while</span> (shell &gt; <span class="number">0</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        shell /= <span class="number">2</span>;<span class="comment">//希尔增量，shell=shell/3+1也可以</span></span><br><span class="line">        <span class="type">int</span> i = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; n - shell; i++)<span class="comment">//折半，所以遍历原数组长度的一半就行</span></span><br><span class="line">        &#123;</span><br><span class="line">            <span class="type">int</span> end = i;</span><br><span class="line">            <span class="type">int</span> temp = arr[end + shell];</span><br><span class="line">            <span class="keyword">while</span> (end &gt;= <span class="number">0</span>)</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="keyword">if</span> (temp &lt; arr[end])</span><br><span class="line">                &#123;</span><br><span class="line">                    arr[end + shell] = arr[end];</span><br><span class="line">                    end -= shell;<span class="comment">//这个位置很关键，这样才能分别比较三项及以上的数，并且交换位置。</span></span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">else</span></span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            arr[end+shell] = temp;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="归并排序"><a href="#归并排序" class="headerlink" title="归并排序"></a>归并排序</h2><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">msort</span><span class="params">(<span class="type">int</span> l,  <span class="type">int</span> r)</span></span></span><br><span class="line"><span class="function"><span class="comment">//归并排序，基本思想：左端点指针与右端点指针，将其从中间分割，对左半部分进行递归，右半部分进行递归，</span></span></span><br><span class="line"><span class="function"><span class="comment">//然后从头分别遍历左半部分与右半部分，哪边小就把哪边的数追加到新的数组之中，如果左右半边数组有没有被遍历到的情况，则直接将后面的元素全部追加到新数组后面；</span></span></span><br><span class="line"><span class="function"><span class="comment">//最后通过新的已经排好的数组更新原来的数组，</span></span></span><br><span class="line"><span class="function"><span class="comment">//递归，后面由边界到抽象，逐渐合并为一个已经排好的数组。</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (l == r)  <span class="keyword">return</span>;</span><br><span class="line">    <span class="type">int</span> m = (l + r) / <span class="number">2</span>;</span><br><span class="line">    <span class="built_in">msort</span>(l, m);<span class="comment">//对左半部分递归</span></span><br><span class="line">    <span class="built_in">msort</span>(m + <span class="number">1</span>, r);<span class="comment">//对右半部分递归</span></span><br><span class="line">    <span class="built_in">merge</span>(l, m, r); <span class="comment">//合并数组</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">merge</span><span class="params">(<span class="type">int</span> l, <span class="type">int</span> m, <span class="type">int</span> r)</span><span class="comment">//合并数组</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="type">int</span> i = l, j = m + <span class="number">1</span>,k=l;</span><br><span class="line">    <span class="keyword">while</span> (i &lt;= m &amp;&amp; j &lt;= r)<span class="comment">//从头遍历数组的左半部分和右半部分，哪边小就把哪边的数组加到新数组中</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span> (arr[i] &gt; arr[j])</span><br><span class="line">            arr1[k++] = arr[j++];</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">            arr1[k++] = arr[i++];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//后面是考虑左右半边数组有没被遍历到的情况，如果有就直接添加到新数组后面</span></span><br><span class="line">    <span class="keyword">while</span> (i &lt;= m)</span><br><span class="line">        arr1[k++] = arr[i++];</span><br><span class="line">    <span class="keyword">while</span> (j &lt;= r)</span><br><span class="line">        arr1[k++] = arr[j++];</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = l; i &lt;= r; i++)<span class="comment">//将已经排好的数组重新添加到原数组中</span></span><br><span class="line">        arr[i] = arr1[i];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="插入排序"><a href="#插入排序" class="headerlink" title="插入排序"></a>插入排序</h2><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">insertsort</span><span class="params">(<span class="type">int</span> a[],<span class="type">int</span> n)</span></span></span><br><span class="line"><span class="function"><span class="comment">//插入排序，基本思想：左半部分为有序区，右半部分为无序区，从有序区右端依次向左与无序区第一个值进行比较，</span></span></span><br><span class="line"><span class="function"><span class="comment">//如果比这个值大，则该值向右移，如果比这个值小，则插入这个值的右端，合并为新的有序区</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt; n; i++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="type">int</span> now = a[i];</span><br><span class="line">        <span class="type">int</span> j;</span><br><span class="line">        <span class="keyword">for</span> (j = i - <span class="number">1</span>; j &gt;= <span class="number">0</span>; j--)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span> (now &lt; a[j]) a[j + <span class="number">1</span>] = a[j];<span class="comment">//若a[j]大于now，则往前移，直到不大于</span></span><br><span class="line">            <span class="keyword">else</span></span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        a[j + <span class="number">1</span>] = now;<span class="comment">//因为j--，所以这里是j+1；</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="快速排序"><a href="#快速排序" class="headerlink" title="快速排序"></a>快速排序</h2><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">quicksort</span><span class="params">(<span class="type">int</span> a[], <span class="type">int</span> l, <span class="type">int</span> r)</span></span></span><br><span class="line"><span class="function"><span class="comment">//快速排序:基本思想为找到一个“哨兵”值，起始端和终止端各有一个指针i，j，</span></span></span><br><span class="line"><span class="function"><span class="comment">//如果指针i指向的值大于哨兵值，j指向的值小于哨兵值，则进行交换，直到左半部分的值全部小于哨兵值，右半部分的值全部大于哨兵值，然后对左右半部分进行递归，最后可以排序成功</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="type">int</span> i = l, j = r, tag = a[(l + r) / <span class="number">2</span>],temp;</span><br><span class="line">    <span class="keyword">do</span> &#123;</span><br><span class="line">        <span class="keyword">while</span> (a[i] &lt; tag) i++;</span><br><span class="line">        <span class="keyword">while</span> (a[j] &gt; tag) j--;</span><br><span class="line">        <span class="keyword">if</span> (i &lt;= j)</span><br><span class="line">        &#123;</span><br><span class="line">            temp = a[i];</span><br><span class="line">            a[i] = a[j];</span><br><span class="line">            a[j] = temp;</span><br><span class="line">            i++; j--;<span class="comment">//交换值，并且将两端指针各往前挪一格，方便之后继续进行交换操作</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125; <span class="keyword">while</span> (i &lt;= j);</span><br><span class="line">    <span class="keyword">if</span> (l &lt; j) <span class="built_in">quicksort</span>(a, l, j);<span class="comment">//左半部分进行递归</span></span><br><span class="line">    <span class="keyword">if</span> (r &gt; i) <span class="built_in">quicksort</span>(a, i, r);<span class="comment">//右半部分进行递归</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="基数排序"><a href="#基数排序" class="headerlink" title="基数排序"></a>基数排序</h2><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">int</span> <span class="title">maxbit</span><span class="params">(<span class="type">int</span> data[], <span class="type">int</span> n)</span> </span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="type">int</span> maxData = data[<span class="number">0</span>];             </span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt; n; ++i)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span> (maxData &lt; data[i])</span><br><span class="line">            maxData = data[i];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="type">int</span> d = <span class="number">1</span>;</span><br><span class="line">    <span class="type">int</span> p = <span class="number">10</span>;</span><br><span class="line">    <span class="keyword">while</span> (maxData &gt;= p)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="comment">//p *= 10; // Maybe overflow</span></span><br><span class="line">        maxData /= <span class="number">10</span>;</span><br><span class="line">        ++d;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> d;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">radixsort</span><span class="params">(<span class="type">int</span> data[], <span class="type">int</span> n)</span> </span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="type">int</span> d = <span class="built_in">maxbit</span>(data, n);</span><br><span class="line">    <span class="type">int</span> *tmp = <span class="keyword">new</span> <span class="type">int</span>[n];</span><br><span class="line">    <span class="type">int</span> *count = <span class="keyword">new</span> <span class="type">int</span>[<span class="number">10</span>]; </span><br><span class="line">    <span class="type">int</span> i, j, k;</span><br><span class="line">    <span class="type">int</span> radix = <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">for</span>(i = <span class="number">1</span>; i &lt;= d; i++) </span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">for</span>(j = <span class="number">0</span>; j &lt; <span class="number">10</span>; j++)</span><br><span class="line">            count[j] = <span class="number">0</span>; </span><br><span class="line">        <span class="keyword">for</span>(j = <span class="number">0</span>; j &lt; n; j++)</span><br><span class="line">        &#123;</span><br><span class="line">            k = (data[j] / radix) % <span class="number">10</span>; </span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span>(j = <span class="number">1</span>; j &lt; <span class="number">10</span>; j++)</span><br><span class="line">            count[j] = count[j - <span class="number">1</span>] + count[j]; </span><br><span class="line">        <span class="keyword">for</span>(j = n - <span class="number">1</span>; j &gt;= <span class="number">0</span>; j--) </span><br><span class="line">        &#123;</span><br><span class="line">            k = (data[j] / radix) % <span class="number">10</span>;</span><br><span class="line">            tmp[count[k] - <span class="number">1</span>] = data[j];</span><br><span class="line">            count[k]--;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span>(j = <span class="number">0</span>; j &lt; n; j++)</span><br><span class="line">            data[j] = tmp[j];</span><br><span class="line">        radix = radix * <span class="number">10</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">delete</span> []tmp;</span><br><span class="line">    <span class="keyword">delete</span> []count;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="堆排序"><a href="#堆排序" class="headerlink" title="堆排序"></a>堆排序</h2><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">max_heapify</span><span class="params">(<span class="type">int</span> arr[], <span class="type">int</span> start, <span class="type">int</span> end)</span> </span>&#123;</span><br><span class="line">    <span class="type">int</span> dad = start;</span><br><span class="line">    <span class="type">int</span> son = dad * <span class="number">2</span> + <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">while</span> (son &lt;= end) &#123;</span><br><span class="line">        <span class="keyword">if</span> (son + <span class="number">1</span> &lt;= end &amp;&amp; arr[son] &lt; arr[son + <span class="number">1</span>])</span><br><span class="line">            son++;</span><br><span class="line">        <span class="keyword">if</span> (arr[dad] &gt; arr[son])</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="built_in">swap</span>(arr[dad], arr[son]);</span><br><span class="line">            dad = son;</span><br><span class="line">            son = dad * <span class="number">2</span> + <span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">heap_sort</span><span class="params">(<span class="type">int</span> arr[], <span class="type">int</span> len)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = len / <span class="number">2</span> - <span class="number">1</span>; i &gt;= <span class="number">0</span>; i--)</span><br><span class="line">        <span class="built_in">max_heapify</span>(arr, i, len - <span class="number">1</span>);</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = len - <span class="number">1</span>; i &gt; <span class="number">0</span>; i--) &#123;</span><br><span class="line">        <span class="built_in">swap</span>(arr[<span class="number">0</span>], arr[i]);</span><br><span class="line">        <span class="built_in">max_heapify</span>(arr, <span class="number">0</span>, i - <span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>另外还有桶排序，这里就不列举了。</p><h1 id="差分与前缀和"><a href="#差分与前缀和" class="headerlink" title="差分与前缀和"></a>差分与前缀和</h1><p>差分与前缀和是相对的，差分的本质就是前缀和的逆运算，相比前缀和要抽象一点，这里不详细介绍前缀和</p><p>对于一个一维数组a，其差分数组b，两者关系有：</p><p>$ b[n]&#x3D;a[n]-a[n-1]; $</p><p>对于一个二维数组a，其差分矩阵b，两者关系有：</p><p>$ b[i][j] &#x3D; a[i][j] - a[i][j-1] - a[i-1][j] + a[i-1][j-1]; $</p><p>实现An中从$(x1,y1)$到$(x2,y2)$子矩阵同时加上或者减去常数C<br>通过对差分矩阵元素的的改变进而改变前缀和矩阵元素的值，代码实现形式：</p><p>$ b[x1][y1] +&#x3D; c; $</p><p>$ b[x1][y2+1] -&#x3D; c; $</p><p>$ b[x2+1][y1] -&#x3D; c; $</p><p>$ b[x2+1][y2+1] +&#x3D; c; $</p><p>对于一维数组a，其有差分数组b，若想在一维数组 a  l  到  r 这个区间加上c，则对于差分数组b有：</p><p>$ b[l] +&#x3D; c; $<br>$ b[r+1] -&#x3D; c; $</p><p><a href="https://www.luogu.com.cn/problem/P3397">https://www.luogu.com.cn/problem/P3397</a></p><h1 id="高精度算法"><a href="#高精度算法" class="headerlink" title="高精度算法"></a>高精度算法</h1><h2 id="高精加"><a href="#高精加" class="headerlink" title="高精加"></a>高精加</h2><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;tuple&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> LL long long</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> MAX 100000</span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="type">int</span> a[MAX], b[MAX], c[MAX]&#123; <span class="number">0</span> &#125;;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">        string num1, num2;</span><br><span class="line">        cin &gt;&gt; num1 &gt;&gt; num2;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = num1.<span class="built_in">size</span>()<span class="number">-1</span>,j=<span class="number">0</span>; i &gt;=<span class="number">0</span> ; i--,j++)</span><br><span class="line">            a[j] = num1[i] - <span class="string">&#x27;0&#x27;</span>;</span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span> i = num2.<span class="built_in">size</span>()<span class="number">-1</span>,j=<span class="number">0</span>; i &gt;=<span class="number">0</span> ; i--,j++)</span><br><span class="line">            b[j] = num2[i] - <span class="string">&#x27;0&#x27;</span>;</span><br><span class="line">        <span class="type">int</span> max = num1.<span class="built_in">size</span>() &gt; num2.<span class="built_in">size</span>() ? num1.<span class="built_in">size</span>() : num2.<span class="built_in">size</span>();</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; max; i++)</span><br><span class="line">        &#123;</span><br><span class="line">            c[i] += a[i] + b[i];</span><br><span class="line">            c[i + <span class="number">1</span>] = c[i] / <span class="number">10</span>;</span><br><span class="line">            c[i] %= <span class="number">10</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        max--;</span><br><span class="line">        <span class="keyword">while</span> (c[max+<span class="number">1</span>])</span><br><span class="line">        &#123;</span><br><span class="line">            max++;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = max; i &gt;=<span class="number">0</span>; i--)</span><br><span class="line">            cout &lt;&lt; c[i];</span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="高精乘"><a href="#高精乘" class="headerlink" title="高精乘"></a>高精乘</h2><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;tuple&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> LL long long</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> MAX 100000</span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="type">int</span> a[MAX], b[MAX], c[MAX]&#123; <span class="number">0</span> &#125;;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">            string num1, num2;</span><br><span class="line">            cin &gt;&gt; num1 &gt;&gt; num2;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = num1.<span class="built_in">size</span>()<span class="number">-1</span>,j=<span class="number">1</span>; i &gt;=<span class="number">0</span> ; i--,j++)</span><br><span class="line">            a[j] = num1[i] - <span class="string">&#x27;0&#x27;</span>;</span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span> i = num2.<span class="built_in">size</span>()<span class="number">-1</span>,j=<span class="number">1</span>; i &gt;=<span class="number">0</span> ; i--,j++)</span><br><span class="line">            b[j] = num2[i] - <span class="string">&#x27;0&#x27;</span>;</span><br><span class="line">            <span class="type">int</span> max = num1.<span class="built_in">size</span>() &gt; num2.<span class="built_in">size</span>() ? num1.<span class="built_in">size</span>() : num2.<span class="built_in">size</span>();</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt;= num1.<span class="built_in">size</span>(); i++)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span> j = <span class="number">1</span>; j &lt;= num2.<span class="built_in">size</span>(); j++)</span><br><span class="line">            &#123;</span><br><span class="line">                c[j + i - <span class="number">1</span>] += a[i] * b[j];</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="type">int</span> len = num1.<span class="built_in">size</span>() + num2.<span class="built_in">size</span>();</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt;= len; i++)</span><br><span class="line">        &#123;</span><br><span class="line">            c[i + <span class="number">1</span>] += c[i] / <span class="number">10</span>;</span><br><span class="line">            c[i] %= <span class="number">10</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="type">int</span> cnt = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt;= len; i++)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span> (c[i] == <span class="number">0</span>)</span><br><span class="line">                cnt++;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (cnt == len) cout &lt;&lt; <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">while</span> (!c[len]) len--;</span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span> i = len; i &gt;= <span class="number">1</span>; i--)</span><br><span class="line">                cout &lt;&lt; c[i];</span><br><span class="line">            &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="枚举"><a href="#枚举" class="headerlink" title="枚举"></a>枚举</h1><h2 id="二进制枚举"><a href="#二进制枚举" class="headerlink" title="二进制枚举"></a>二进制枚举</h2><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="type">int</span> n;</span><br><span class="line">    cin &gt;&gt; n;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">0</span>; i &lt; (<span class="number">1</span>&lt;&lt;n); i++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> j = <span class="number">0</span>; j &lt; n; j++) </span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span>(i &amp; (<span class="number">1</span> &lt;&lt; j))</span><br><span class="line"></span><br><span class="line">               cout&lt;&lt;j;</span><br><span class="line"></span><br><span class="line">        &#125;</span><br><span class="line">        cout&lt;&lt;endl;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="动态规划"><a href="#动态规划" class="headerlink" title="动态规划"></a>动态规划</h1><h2 id="背包dp"><a href="#背包dp" class="headerlink" title="背包dp"></a>背包dp</h2><h3 id="01背包"><a href="#01背包" class="headerlink" title="01背包"></a>01背包</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"> <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">1</span>; i &lt;= n; i++) </span><br><span class="line">     <span class="keyword">for</span>(<span class="type">int</span> j = <span class="number">1</span>; j &lt;= m; j++)</span><br><span class="line">         <span class="keyword">if</span>(j &lt; v[i]) </span><br><span class="line">             f[i][j] = f[i - <span class="number">1</span>][j];</span><br><span class="line">         <span class="keyword">else</span>    </span><br><span class="line">             f[i][j] = <span class="built_in">max</span>(f[i - <span class="number">1</span>][j], f[i - <span class="number">1</span>][j - v[i]] + w[i]);</span><br><span class="line">             </span><br><span class="line">               </span><br><span class="line"><span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">1</span>; i &lt;= n; i++)</span><br><span class="line">     <span class="keyword">for</span>(<span class="type">int</span> j = m; j &gt;= v; j--)</span><br><span class="line">         f[j] = <span class="built_in">max</span>(f[j], f[j - v] + w);                                                                                                                                          </span><br><span class="line">                                                           </span><br></pre></td></tr></table></figure><h3 id="完全背包"><a href="#完全背包" class="headerlink" title="完全背包"></a>完全背包</h3><p>可以无限拿取背包内的东西</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">1</span> ; i &lt;= n ; i++)</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> j = <span class="number">0</span> ; j &lt;= m ; j ++)</span><br><span class="line">        &#123;</span><br><span class="line">           f[i][j] = f[i<span class="number">-1</span>][j];</span><br><span class="line">                 <span class="keyword">if</span>(j-v[i]&gt;=<span class="number">0</span>)</span><br><span class="line">           f[i][j] = <span class="built_in">max</span>(f[i][j],f[i<span class="number">-1</span>][j-v[i]]+w[i]);</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">         </span><br><span class="line"><span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">1</span> ; i&lt;=n ;i++)</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> j = v[i] ; j&lt;=m ;j++)<span class="comment">//注意了，这里的j是从小到大枚举，和01背包不一样</span></span><br><span class="line">    &#123;</span><br><span class="line">            f[j] = <span class="built_in">max</span>(f[j],f[j-v[i]]+w[i]);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure><h3 id="多重背包"><a href="#多重背包" class="headerlink" title="多重背包"></a>多重背包</h3><p>将背包拆出来，然后转化成01背包问题即可</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">   ll n,m;</span><br><span class="line">ll cnt=<span class="number">1</span>;</span><br><span class="line">ll a,b,c;</span><br><span class="line"><span class="keyword">for</span>(ll i=<span class="number">1</span>;i&lt;=n;i++)</span><br><span class="line">&#123;</span><br><span class="line">    cin&gt;&gt;a&gt;&gt;b&gt;&gt;c;</span><br><span class="line">    <span class="keyword">for</span>(ll j=<span class="number">1</span>;j&lt;=c;j++)</span><br><span class="line">    &#123;</span><br><span class="line">        v[cnt]=a;</span><br><span class="line">        w[cnt]=b;</span><br><span class="line">        cnt++;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">for</span>(ll i=<span class="number">1</span>;i&lt;=cnt;i++)</span><br><span class="line">    <span class="keyword">for</span>(ll j=m;j&gt;=v[i];j--)</span><br><span class="line">        f[j]=<span class="built_in">max</span>(f[j],f[j-v[i]]+w[i]);</span><br></pre></td></tr></table></figure><p>如果数据范围较大可能会导致超时，此时需要进行优化</p><h4 id="二进制优化"><a href="#二进制优化" class="headerlink" title="二进制优化"></a>二进制优化</h4><p>如果不采用动态规划的做法, 就像普通的遍历问题那样, 是否采用二进制的计数方法对时间复杂度的优化没有任何关系。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt;= n; i ++)</span><br><span class="line">   &#123;</span><br><span class="line">       <span class="type">int</span> a, b, s;</span><br><span class="line">       <span class="type">int</span> k = <span class="number">1</span>; </span><br><span class="line">       <span class="keyword">while</span> (k &lt;= s)</span><br><span class="line">       &#123;</span><br><span class="line">           cnt ++;</span><br><span class="line">           v[cnt] = a * k; </span><br><span class="line">           w[cnt] = b * k; </span><br><span class="line">           s -= k;</span><br><span class="line">           k *= <span class="number">2</span>;  </span><br><span class="line">       &#125;</span><br><span class="line">       <span class="keyword">if</span> (s &gt; <span class="number">0</span>)   </span><br><span class="line">       &#123;</span><br><span class="line">           cnt ++;</span><br><span class="line">           v[cnt] = a * s;</span><br><span class="line">           w[cnt] = b * s;</span><br><span class="line">       &#125;</span><br><span class="line">   &#125;</span><br><span class="line"></span><br><span class="line">   n = cnt;  </span><br><span class="line"></span><br></pre></td></tr></table></figure><h3 id="混合背包"><a href="#混合背包" class="headerlink" title="混合背包"></a>混合背包</h3><p>就是将上面三种混合起来，没什么好说的</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span> (循环物品种类) &#123;</span><br><span class="line">  <span class="keyword">if</span> (是 <span class="number">0</span> - <span class="number">1</span> 背包)</span><br><span class="line">     <span class="number">0</span> - <span class="number">1</span> 背包代码;</span><br><span class="line">  <span class="keyword">else</span> <span class="keyword">if</span> (是完全背包)</span><br><span class="line">    完全背包代码;</span><br><span class="line">  <span class="keyword">else</span> <span class="keyword">if</span> (是多重背包)</span><br><span class="line">    多重背包代码;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="分组背包"><a href="#分组背包" class="headerlink" title="分组背包"></a>分组背包</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=n;i++)&#123;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> j=<span class="number">0</span>;j&lt;=m;j++)&#123;</span><br><span class="line">            f[i][j]=f[i<span class="number">-1</span>][j]; </span><br><span class="line">            <span class="keyword">for</span>(<span class="type">int</span> k=<span class="number">0</span>;k&lt;s[i];k++)&#123;</span><br><span class="line">                <span class="keyword">if</span>(j&gt;=v[i][k])     f[i][j]=<span class="built_in">max</span>(f[i][j],f[i<span class="number">-1</span>][j-v[i][k]]+w[i][k]);  </span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">     &#125;</span><br></pre></td></tr></table></figure><h3 id="单调队列优化"><a href="#单调队列优化" class="headerlink" title="单调队列优化"></a>单调队列优化</h3><p>因为单调队列的单调性，所以我们可以用它来进行降低DP维数，进行时间和空间的优化。<br>这里以优化多重背包问题为例，<br>转移只会发生在「对当前物品体积取余相同」的状态之间。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">     </span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> j = <span class="number">0</span>; j &lt; vi; j++) &#123;</span><br><span class="line">    <span class="type">int</span> head = <span class="number">0</span>, tail = <span class="number">-1</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> k = j; k &lt;= C; k+=vi) &#123;</span><br><span class="line">        dp[k] = g[k];</span><br><span class="line">        <span class="comment">// 将不在窗口范围内的值弹出</span></span><br><span class="line">        <span class="keyword">if</span> (head &lt;= tail &amp;&amp; q[head] &lt; k - si * vi) head++;</span><br><span class="line">        <span class="comment">// 如果队列中存在元素，直接使用队头来更新</span></span><br><span class="line">        <span class="keyword">if</span> (head &lt;= tail) dp[k] = <span class="built_in">max</span>(dp[k], g[q[head]] + (k - q[head]) / vi * wi);</span><br><span class="line">        <span class="comment">// 当前值比对尾值更优，队尾元素没有存在必要，队尾出队</span></span><br><span class="line">        <span class="keyword">while</span> (head &lt;= tail &amp;&amp; g[q[tail]] - (q[tail] - j) / vi * wi &lt;= g[k] - (k - j) / vi * wi) tail--;</span><br><span class="line">        <span class="comment">// 将新下标入队 </span></span><br><span class="line">        q[++tail] = k;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="区间dp"><a href="#区间dp" class="headerlink" title="区间dp"></a>区间dp</h2><p>就是对区间进行动态规划<br>P1880 [NOI1995] 石子合并 - 洛谷 </p><p>这题汇总了对于区间dp，求最大值，最小值以及形成一个圈的所有情况。<br>其中$dp[j][j+i]$代表，以j为起点，j+i为终点，区间的最优解情况<br>状态转移方程：</p><p> $ dp1[j][j+i]&#x3D;min&#x2F;max(dp1[j][j+i],dp1[j][k]+dp1[k+1][j+i]+s[j+i]-s[j-1]); $</p><p>$ s[j+i]-s[j-1] $代表j到j+i这个区间的所有元素的和，之所以要加上区间所有元素的和，是因为单纯将$ dp1[j][k]，dp1[k+1][j+i] $相加，其实少加了一次j到j+i这个区间的所有元素的。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="type">int</span> dp1[<span class="number">501</span>][<span class="number">501</span>],dp2[<span class="number">501</span>][<span class="number">501</span>],n,a[<span class="number">501</span>],s[<span class="number">501</span>];</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    std::ios::<span class="built_in">sync_with_stdio</span>(<span class="literal">false</span>);</span><br><span class="line">    cin.<span class="built_in">tie</span>(<span class="number">0</span>);</span><br><span class="line">    cin&gt;&gt;n;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=n;i++)&#123;</span><br><span class="line">        cin&gt;&gt;a[i];</span><br><span class="line">        a[n+i]=a[i];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">memset</span>(dp1,<span class="number">127</span>,<span class="built_in">sizeof</span>(dp1));</span><br><span class="line">    <span class="built_in">memset</span>(dp2,<span class="number">0</span>,<span class="built_in">sizeof</span>(dp2));</span><br><span class="line">    n*=<span class="number">2</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=n;i++)</span><br><span class="line">        s[i]=s[i<span class="number">-1</span>]+a[i];</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=n;i++)&#123;</span><br><span class="line">        dp1[i][i]=<span class="number">0</span>;</span><br><span class="line">        dp2[i][i]=<span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;n;i++)</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> j=<span class="number">1</span>;j&lt;n-i;j++)</span><br><span class="line">            <span class="keyword">for</span>(<span class="type">int</span> k=j;k&lt;j+i;k++)&#123;</span><br><span class="line">                dp1[j][j+i]=<span class="built_in">min</span>(dp1[j][j+i],dp1[j][k]+dp1[k+<span class="number">1</span>][j+i]+s[j+i]-s[j<span class="number">-1</span>]);</span><br><span class="line">                dp2[j][j+i]=<span class="built_in">max</span>(dp2[j][j+i],dp2[j][k]+dp2[k+<span class="number">1</span>][j+i]+s[j+i]-s[j<span class="number">-1</span>]);</span><br><span class="line">            &#125;</span><br><span class="line">    <span class="type">int</span> ans1=<span class="number">1</span>&lt;&lt;<span class="number">30</span>,ans2=<span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=n;i++)&#123;</span><br><span class="line">        ans1=<span class="built_in">min</span>(ans1,dp1[i][i+n/<span class="number">2</span><span class="number">-1</span>]);</span><br><span class="line">        ans2=<span class="built_in">max</span>(ans2,dp2[i][i+n/<span class="number">2</span><span class="number">-1</span>]);</span><br><span class="line">    &#125;</span><br><span class="line">    cout&lt;&lt;ans1&lt;&lt;endl;</span><br><span class="line">    cout&lt;&lt;ans2&lt;&lt;endl;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="树形dp"><a href="#树形dp" class="headerlink" title="树形dp"></a>树形dp</h2><p>P1352 没有上司的舞会 - 洛谷 </p><p>wls的板子，本题比起wls的题目，就是多了个·查找根节点的操作，其余的都是一样的，树形dp说白了就是在树结构在上进行dp，此时就需要遍历树（使用dfs或者bfs），wls的建链表（链式向前星）挺巧妙的，可以学学；</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="type">const</span> <span class="type">int</span> MAX = <span class="number">200005</span>;</span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">Node</span> &#123;</span><br><span class="line">Node* next;</span><br><span class="line"><span class="type">int</span> Where;</span><br><span class="line">&#125;* f[MAX],a[MAX];</span><br><span class="line"><span class="type">int</span> v[MAX], n, l;</span><br><span class="line"><span class="type">int</span> vis[MAX];</span><br><span class="line"><span class="type">long</span> <span class="type">long</span> dp[MAX][<span class="number">2</span>];</span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="type">void</span> <span class="title">makelist</span><span class="params">(<span class="type">int</span> x, <span class="type">int</span> y)</span> </span>&#123;<span class="comment">//起点，终点</span></span><br><span class="line">a[++l].Where = y;</span><br><span class="line">a[l].next = f[x];</span><br><span class="line">f[x] = &amp;a[l];</span><br><span class="line">vis[y] = <span class="number">1</span>;</span><br><span class="line">&#125; </span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="type">void</span> <span class="title">solve</span><span class="params">(<span class="type">int</span> d)</span> </span>&#123;</span><br><span class="line">dp[d][<span class="number">1</span>] = v[d];</span><br><span class="line"><span class="keyword">for</span> (Node* x=f[d]; x; x = x-&gt;next) &#123;</span><br><span class="line"><span class="built_in">solve</span>(x-&gt;Where);</span><br><span class="line">dp[d][<span class="number">0</span>] += <span class="built_in">max</span>(dp[x-&gt;Where][<span class="number">0</span>], dp[x-&gt;Where][<span class="number">1</span>]);</span><br><span class="line">dp[d][<span class="number">1</span>] += dp[x-&gt;Where][<span class="number">0</span>];</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">std::ios::<span class="built_in">sync_with_stdio</span>(<span class="literal">false</span>);</span><br><span class="line">cin.<span class="built_in">tie</span>(<span class="number">0</span>);</span><br><span class="line">cin &gt;&gt; n;</span><br><span class="line"><span class="type">int</span> res = <span class="number">0</span>;</span><br><span class="line"><span class="built_in">memset</span>(f, <span class="number">0</span>, <span class="built_in">sizeof</span>(f));</span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt;= n; i++)</span><br><span class="line">cin &gt;&gt; v[i];</span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt;= n - <span class="number">1</span>; i++) &#123;</span><br><span class="line"><span class="type">int</span> l,k; cin &gt;&gt; l&gt;&gt;k;</span><br><span class="line"><span class="built_in">makelist</span>(k,l);</span><br><span class="line">&#125;</span><br><span class="line"><span class="type">int</span> root; <span class="comment">//寻根，谁的入度为0谁就是根</span></span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt;= n; i++) &#123;</span><br><span class="line"><span class="keyword">if</span> (!vis[i]) &#123;</span><br><span class="line">root = i;</span><br><span class="line"><span class="keyword">break</span>;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">solve</span>(root);</span><br><span class="line">cout &lt;&lt; <span class="built_in">max</span>(dp[root][<span class="number">1</span>],dp[root][<span class="number">0</span>]);</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="状压dp"><a href="#状压dp" class="headerlink" title="状压dp"></a>状压dp</h2><h2 id="数位dp"><a href="#数位dp" class="headerlink" title="数位dp"></a>数位dp</h2><h1 id="搜索"><a href="#搜索" class="headerlink" title="搜索"></a>搜索</h1><h2 id="DFS基本形式"><a href="#DFS基本形式" class="headerlink" title="DFS基本形式"></a>DFS基本形式</h2><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">基本模型</span></span><br><span class="line"><span class="comment">void dfs(int step)</span></span><br><span class="line"><span class="comment">&#123;</span></span><br><span class="line"><span class="comment">if(所有空都填完了)&#123;</span></span><br><span class="line"><span class="comment">        判断最优解或者记录答案；</span></span><br><span class="line"><span class="comment">        return;</span></span><br><span class="line"><span class="comment">      &#123;</span></span><br><span class="line"><span class="comment">    for(枚举所有的情况)&#123;</span></span><br><span class="line"><span class="comment">        if(该选项是合法的)</span></span><br><span class="line"><span class="comment">           记录下这个空；</span></span><br><span class="line"><span class="comment">           dfs(step+1);</span></span><br><span class="line"><span class="comment">           取消这个空</span></span><br><span class="line"><span class="comment">        &#125;</span></span><br><span class="line"><span class="comment">&#125;              </span></span><br><span class="line"><span class="comment">*/</span></span><br></pre></td></tr></table></figure><h2 id="DFS基本运用：N皇后问题"><a href="#DFS基本运用：N皇后问题" class="headerlink" title="DFS基本运用：N皇后问题"></a>DFS基本运用：N皇后问题</h2><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="type">const</span> <span class="type">int</span> N = <span class="number">1000</span>;</span><br><span class="line"><span class="type">int</span> n,res;</span><br><span class="line"><span class="type">int</span> a[N], b[N], c[N];<span class="comment">//行，两个斜行，对于某一个点而言，</span></span><br><span class="line"><span class="comment">//其中一个斜行x+y固定，另一个行x-y固定；</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">dfs</span><span class="params">(<span class="type">int</span> step)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">if</span> (step &gt; n)</span><br><span class="line">&#123;</span><br><span class="line">res++;</span><br><span class="line"><span class="keyword">return</span>;</span><br><span class="line"><span class="comment">//因为棋子已经摆完了，所以回溯到上一种情况继续摆放。</span></span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt;= n; i++)</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">if</span> (a[i] == <span class="number">0</span> &amp;&amp; b[step + i] == <span class="number">0</span> &amp;&amp; c[step - i + <span class="number">20</span>] == <span class="number">0</span>)</span><br><span class="line">&#123;</span><br><span class="line">a[i] = <span class="number">1</span>; b[step + i] = <span class="number">1</span>; c[step - i + <span class="number">20</span>] = <span class="number">1</span>;</span><br><span class="line"><span class="built_in">dfs</span>(step + <span class="number">1</span>);</span><br><span class="line">a[i] = <span class="number">0</span>; b[step + i] = <span class="number">0</span>; c[step - i + <span class="number">20</span>] = <span class="number">0</span>;</span><br><span class="line"><span class="comment">//如果没有满足上述情况的位置放置，则恢复现场。</span></span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">cin &gt;&gt; n;</span><br><span class="line"><span class="built_in">dfs</span>(<span class="number">1</span>);</span><br><span class="line">cout &lt;&lt; res;</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="BFS基本形式"><a href="#BFS基本形式" class="headerlink" title="BFS基本形式"></a>BFS基本形式</h1><p>通常是与队列（queue）捆绑的。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">   Q.push(初始状态);</span></span><br><span class="line"><span class="comment">   while(!Q.empty())</span></span><br><span class="line"><span class="comment">   &#123;</span></span><br><span class="line"><span class="comment">     State  u  =Q.front();</span></span><br><span class="line"><span class="comment"> Q.pop();</span></span><br><span class="line"><span class="comment"> for(枚举所有的可能状态)</span></span><br><span class="line"><span class="comment">    if(是合法的)</span></span><br><span class="line"><span class="comment">   Q.push(v);</span></span><br><span class="line"><span class="comment">   &#125;</span></span><br><span class="line"><span class="comment">*/</span></span><br></pre></td></tr></table></figure><h2 id="BFS的基本应用："><a href="#BFS的基本应用：" class="headerlink" title="BFS的基本应用："></a>BFS的基本应用：</h2><p>P1443 马的遍历 - 洛谷 </p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="type">const</span> <span class="type">int</span> N = <span class="number">1000</span>;</span><br><span class="line"><span class="type">int</span> horse[<span class="number">8</span>][<span class="number">2</span>] = &#123;</span><br><span class="line">&#123;<span class="number">1</span>,<span class="number">2</span>&#125;,&#123;<span class="number">2</span>,<span class="number">1</span>&#125;,&#123;<span class="number">-1</span>,<span class="number">2</span>&#125;,&#123;<span class="number">-2</span>,<span class="number">1</span>&#125;,&#123;<span class="number">-1</span>,<span class="number">-2</span>&#125;,&#123;<span class="number">-2</span>,<span class="number">-1</span>&#125;,&#123;<span class="number">1</span>,<span class="number">-2</span>&#125;,&#123;<span class="number">2</span>,<span class="number">-1</span>&#125;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="type">int</span> ans[N][N];</span><br><span class="line">queue&lt;pair&lt;<span class="type">int</span>, <span class="type">int</span>&gt;&gt; temp;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="built_in">memset</span>(ans, <span class="number">-1</span>, <span class="built_in">sizeof</span>(ans));</span><br><span class="line"><span class="type">int</span> n, m, dx, dy;</span><br><span class="line">cin &gt;&gt; n &gt;&gt; m &gt;&gt; dx &gt;&gt; dy;</span><br><span class="line">ans[dx][dy] = <span class="number">0</span>;</span><br><span class="line">temp.<span class="built_in">push</span>(&#123; dx,dy &#125;);</span><br><span class="line"><span class="keyword">while</span> (!temp.<span class="built_in">empty</span>()) </span><br><span class="line">&#123;</span><br><span class="line">pair&lt;<span class="type">int</span>, <span class="type">int</span>&gt; Top = temp.<span class="built_in">front</span>();<span class="comment">//标记原点</span></span><br><span class="line">temp.<span class="built_in">pop</span>();</span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; <span class="number">8</span>; i++) &#123;</span><br><span class="line"><span class="type">int</span> dx1 = Top.first + horse[i][<span class="number">0</span>];</span><br><span class="line"><span class="type">int</span> dy1 = Top.second + horse[i][<span class="number">1</span>];</span><br><span class="line"><span class="keyword">if</span> (dx1 &lt; <span class="number">1</span> || dx1 &gt; n || dy1 &lt; <span class="number">1</span> || dy1 &gt; m || ans[dx1][dy1] != <span class="number">-1</span>)</span><br><span class="line"><span class="keyword">continue</span>;</span><br><span class="line"><span class="type">int</span> temp1 = ans[Top.first][Top.second];<span class="comment">//继承原点的步数</span></span><br><span class="line">ans[dx1][dy1] = temp1 + <span class="number">1</span>;</span><br><span class="line">temp.<span class="built_in">push</span>(&#123; dx1,dy1 &#125;);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt;= n; i++)</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> j = <span class="number">1</span>; j &lt;= m; j++)</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;%-5d&quot;</span>, ans[i][j]);</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;\n&quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="字符串算法"><a href="#字符串算法" class="headerlink" title="字符串算法"></a>字符串算法</h1><p>这里就不写暴力匹配了。</p><h2 id="KMP"><a href="#KMP" class="headerlink" title="KMP"></a>KMP</h2><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">const</span> <span class="type">int</span> N = <span class="number">1e5</span>;</span><br><span class="line"><span class="type">int</span> Next[N];</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">getNext</span><span class="params">(string b,<span class="type">int</span> next[])</span></span>&#123;<span class="comment">//取模式串的next数组</span></span><br><span class="line">    <span class="type">int</span> len = b.<span class="built_in">size</span>();</span><br><span class="line">    next[<span class="number">0</span>] = <span class="number">-1</span>;</span><br><span class="line">    <span class="type">int</span> k = <span class="number">-1</span>, j = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">while</span> (j &lt; len - <span class="number">1</span>) &#123;</span><br><span class="line">        <span class="keyword">if</span> (k == <span class="number">-1</span> || b[j] == b[k]) &#123;</span><br><span class="line">            k++;</span><br><span class="line">            j++;</span><br><span class="line">            <span class="keyword">if</span> (b[j] != b[k]) next[j] = k;</span><br><span class="line">            <span class="keyword">else</span></span><br><span class="line">                next[j] = next[k];</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> k = next[k];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">kmp_search</span><span class="params">(string a , string b)</span> </span>&#123;</span><br><span class="line">    <span class="type">int</span> i = <span class="number">0</span>, j = <span class="number">0</span>;</span><br><span class="line">    <span class="built_in">getNext</span>(b, Next);</span><br><span class="line">    <span class="keyword">while</span> (i &lt; a.<span class="built_in">size</span>()&amp;&amp;j&lt;b.<span class="built_in">size</span>()) &#123;</span><br><span class="line">        <span class="keyword">if</span> (j==<span class="number">-1</span>||a[i] == b[j]) i++, j++;</span><br><span class="line">        <span class="keyword">else</span>  j = Next[j];<span class="comment">//递归思想，将模式串下标返回Next[j]</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (j == b.<span class="built_in">size</span>()) </span><br><span class="line">        <span class="keyword">return</span> i - j;</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">        <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="EXkmp"><a href="#EXkmp" class="headerlink" title="EXkmp"></a>EXkmp</h2><p>$ next[i]： T[i]…T[m - 1] $与 T（模式串） 的最长相同前缀长度；</p><p>$ extend[i]： S[i]…S[n - 1] $ 与 T 的最长相同前缀长度。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">GetNext</span><span class="params">(string T, <span class="type">int</span> m, <span class="type">int</span> next[])</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="type">int</span> a = <span class="number">0</span>, p = <span class="number">0</span>;</span><br><span class="line">    next[<span class="number">0</span>] = m;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt; m; i++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span> (i &gt;= p || i + next[i - a] &gt;= p)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span> (i &gt;= p)</span><br><span class="line">                p = i;</span><br><span class="line">            <span class="keyword">while</span> (p &lt; m &amp;&amp; T[p] == T[p - i])</span><br><span class="line">                p++;</span><br><span class="line">            next[i] = p - i;</span><br><span class="line">            a = i;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">            next[i] = next[i - a];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">GetExtend</span><span class="params">(string S, <span class="type">int</span> n, string T, <span class="type">int</span> m, <span class="type">int</span> extend[], <span class="type">int</span> next[])</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="type">int</span> a = <span class="number">0</span>, p = <span class="number">0</span>;</span><br><span class="line">    <span class="built_in">GetNext</span>(T, m, next);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; n; i++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span> (i &gt;= p || i + next[i - a] &gt;= p) </span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span> (i &gt;= p)</span><br><span class="line">                p = i;</span><br><span class="line">            <span class="keyword">while</span> (p &lt; n &amp;&amp; p - i &lt; m &amp;&amp; S[p] == T[p - i])</span><br><span class="line">                p++;</span><br><span class="line">            extend[i] = p - i;</span><br><span class="line">            a = i;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">            extend[i] = next[i - a];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="BM算法"><a href="#BM算法" class="headerlink" title="BM算法"></a>BM算法</h2><p>bm可以看作进阶的kmp算法，效率相比kmp要高。<br>BM算法定义了两个规则：</p><p><em><strong>坏字符规则</strong></em>：当文本串中的某个字符跟模式串的某个字符不匹配时，我们称文本串中的这个失配字符为坏字符，此时模式串需要向右移动，移动的位数 &#x3D; 坏字符在模式串中的位置 - 坏字符在模式串中最右出现的位置。此外，如果”坏字符”不包含在模式串之中，则最右出现位置为-1。</p><p><em><strong>好后缀规则</strong></em>：当字符失配时，后移位数 &#x3D; 好后缀在模式串中的位置 - 好后缀在模式串上一次出现的位置，且如果好后缀在模式串中没有再次出现，则为-1。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">const</span> <span class="type">int</span> N = <span class="number">1e4</span>;</span><br><span class="line"><span class="type">int</span> BC[N],suffix[N],gs[N];</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">getBC</span><span class="params">(string pattern, <span class="type">int</span> bc[])</span> </span>&#123;<span class="comment">//BC表</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; <span class="number">256</span>; i++)</span><br><span class="line">        bc[i] = <span class="number">-1</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; pattern.<span class="built_in">size</span>(); i++)</span><br><span class="line">        bc[pattern[i]] = i;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">suffixes</span><span class="params">(string a, <span class="type">int</span> suffix[])</span> </span>&#123;<span class="comment">//构建suffix表，suffix[i] = s 表示以i为边界，与模式串后缀匹配的最大长度。</span></span><br><span class="line">    <span class="type">int</span> len = a.<span class="built_in">size</span>(),num;</span><br><span class="line">    suffix[len - <span class="number">1</span>] = len;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = len - <span class="number">2</span>; i &gt;= <span class="number">0</span>; i--) &#123;</span><br><span class="line">        <span class="keyword">for</span> (num = <span class="number">0</span>; num &lt;= i &amp;&amp; a[i - num] == a[len - num - <span class="number">1</span>]; num++)</span><br><span class="line">            suffix[i] = num;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">getGS</span><span class="params">(string a, <span class="type">int</span> gs[])</span> </span>&#123;<span class="comment">//构建gs表，记录了每次需要移动的距离。</span></span><br><span class="line">    <span class="type">int</span> len = a.<span class="built_in">size</span>(), lastindex = len - <span class="number">1</span>;</span><br><span class="line">    <span class="built_in">suffixes</span>(a, suffix);</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; len; i++)</span><br><span class="line">        gs[i] = len;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = lastindex; i &gt;= <span class="number">0</span>; i--) &#123;</span><br><span class="line">        <span class="keyword">if</span> (suffix[i] == i + <span class="number">1</span>) &#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span> j = <span class="number">0</span>; j &lt; lastindex - i; j++) &#123;</span><br><span class="line">                <span class="keyword">if</span> (gs[j] == len)</span><br><span class="line">                    gs[j] = lastindex - i;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; lastindex; i++) &#123;</span><br><span class="line">        gs[lastindex - suffix[i]] = lastindex - i;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">BMsearch</span><span class="params">(string a, string b )</span> </span>&#123;</span><br><span class="line">    <span class="built_in">memset</span>(BC, <span class="number">0</span>, N);</span><br><span class="line">    <span class="built_in">memset</span>(gs, <span class="number">0</span>, N);</span><br><span class="line">    <span class="built_in">getBC</span>(b,BC);</span><br><span class="line">    <span class="built_in">getGS</span>(b,gs);</span><br><span class="line">    <span class="type">int</span> ptr1 = <span class="number">0</span>, ptr2=<span class="number">0</span>;</span><br><span class="line">    <span class="type">int</span> len1 = a.<span class="built_in">size</span>(), len2 = b.<span class="built_in">size</span>(), maxIndex = b.<span class="built_in">size</span>() - <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">while</span> (ptr1 + len2 &lt;= len1) &#123;</span><br><span class="line">        <span class="keyword">for</span> (ptr2 = maxIndex; ptr2 &gt;= <span class="number">0</span> &amp;&amp; b[ptr2] == a[ptr1 + ptr2]; ptr2--);</span><br><span class="line">        <span class="keyword">if</span> (ptr2 == <span class="number">-1</span>) <span class="keyword">break</span>;</span><br><span class="line">        <span class="keyword">else</span> &#123;</span><br><span class="line">            ptr1 += <span class="built_in">max</span>(gs[ptr2], ptr2 - BC[a[ptr1 + ptr2]]);<span class="comment">//好后缀和怀字符规则，取移动数目较大的。</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> (ptr1 + len2 &lt;= len1) ? ptr1 : <span class="number">-1</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="最长回文子串"><a href="#最长回文子串" class="headerlink" title="最长回文子串"></a>最长回文子串</h2><h3 id="Manacher算法"><a href="#Manacher算法" class="headerlink" title="Manacher算法"></a>Manacher算法</h3><p>查找一个字符串的最长回文子串，这里使用了string，推荐还是用char数组，string操作比较耗时。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">string <span class="title">preProcess</span><span class="params">(string str)</span> </span>&#123;<span class="comment">//准备字符串</span></span><br><span class="line"><span class="type">int</span> len = str.<span class="built_in">size</span>();</span><br><span class="line"><span class="keyword">if</span> (len == <span class="number">0</span>) <span class="keyword">return</span> <span class="string">&quot;^$&quot;</span>;</span><br><span class="line">string start = <span class="string">&quot;^&quot;</span>;</span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; len; i++)</span><br><span class="line">start =start + <span class="string">&quot;#&quot;</span> + str[i];</span><br><span class="line">start += <span class="string">&quot;#$&quot;</span>;</span><br><span class="line"><span class="keyword">return</span> start;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function">string <span class="title">manacher</span><span class="params">(string str)</span> </span>&#123;<span class="comment">//马拉车算法</span></span><br><span class="line">string str1 = <span class="built_in">preProcess</span>(str);</span><br><span class="line"><span class="type">int</span> len = str1.<span class="built_in">size</span>();</span><br><span class="line"><span class="type">int</span>* arr = <span class="keyword">new</span> <span class="type">int</span>[len];</span><br><span class="line"><span class="type">int</span> C = <span class="number">0</span>, R = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt; len - <span class="number">1</span>; i++) &#123;</span><br><span class="line"><span class="type">int</span> i_mirror = <span class="number">2</span> * C - i;</span><br><span class="line"><span class="keyword">if</span> (R &gt; i) arr[i] = <span class="built_in">min</span>(R - i, arr[i_mirror]);<span class="comment">//防止超出R</span></span><br><span class="line"><span class="keyword">else</span> arr[i] = <span class="number">0</span>;<span class="comment">//R=i的情况</span></span><br><span class="line"><span class="keyword">while</span> (str1[i + <span class="number">1</span> + arr[i]] == str1[i - <span class="number">1</span> - arr[i]])                       arr[i]++;<span class="comment">//中心拓展</span></span><br><span class="line"><span class="keyword">if</span> (i + arr[i] &gt; R) &#123;<span class="comment">//更新边界</span></span><br><span class="line">C = i;</span><br><span class="line">R = i + arr[i];</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="type">int</span> Max = <span class="number">0</span>, center = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt; len - <span class="number">1</span>; i++) &#123;</span><br><span class="line"><span class="keyword">if</span> (arr[i] &gt; Max) &#123;</span><br><span class="line">Max = arr[i];</span><br><span class="line">center = i;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="type">int</span> start = (center - Max) / <span class="number">2</span>;</span><br><span class="line"><span class="keyword">return</span> str.<span class="built_in">substr</span>(start,  Max);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>java代码，没事写一个</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">     <span class="keyword">public</span> <span class="keyword">static</span> String <span class="title function_">preString</span><span class="params">(String str)</span>&#123;</span><br><span class="line">        <span class="type">int</span> len=str.length();</span><br><span class="line">        <span class="keyword">if</span>(len==<span class="number">0</span>) <span class="keyword">return</span> <span class="string">&quot;^&amp;&quot;</span>;</span><br><span class="line">        String start=<span class="string">&quot;^&quot;</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;len;i++)</span><br><span class="line">            start=start+<span class="string">&quot;#&quot;</span>+str.charAt(i);</span><br><span class="line">        start+=<span class="string">&quot;#&amp;&quot;</span>;</span><br><span class="line">        <span class="keyword">return</span> start;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> String <span class="title function_">manacher</span><span class="params">(String str)</span>&#123;</span><br><span class="line">        String str1=preString(str);</span><br><span class="line">        <span class="type">int</span> len=str1.length();</span><br><span class="line">        <span class="type">int</span>[] arr=<span class="keyword">new</span> <span class="title class_">int</span>[len];</span><br><span class="line">        <span class="type">int</span> C=<span class="number">0</span>,R=<span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;len-<span class="number">1</span>;i++)&#123;</span><br><span class="line">            <span class="type">int</span> i_mirror=<span class="number">2</span>*C-i;</span><br><span class="line">           <span class="keyword">if</span>(R&gt;i) arr[i]=Math.min(arr[i_mirror],R-i);</span><br><span class="line">           <span class="keyword">else</span> arr[i]=<span class="number">0</span>;</span><br><span class="line">           <span class="keyword">while</span>(str1.charAt(i+<span class="number">1</span>+arr[i])==str1.charAt(i-<span class="number">1</span>-arr[i]))</span><br><span class="line">               arr[i]++;</span><br><span class="line">           <span class="keyword">if</span>(arr[i]+i&gt;R)&#123;</span><br><span class="line">               C=i;</span><br><span class="line">               R=i+arr[i];</span><br><span class="line">           &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="type">int</span> Max=<span class="number">0</span>,center=<span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;len-<span class="number">1</span>;i++)&#123;</span><br><span class="line">            <span class="keyword">if</span>(arr[i]&gt;Max) &#123;</span><br><span class="line">                Max = arr[i];</span><br><span class="line">                center = i;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="type">int</span> beg=(center-Max)/<span class="number">2</span>;</span><br><span class="line">        <span class="keyword">return</span> str.substring(beg,beg+Max);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">public</span> String <span class="title function_">longestPalindrome</span><span class="params">(String s)</span> &#123;</span><br><span class="line">            <span class="keyword">return</span> manacher(s);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="dp实现"><a href="#dp实现" class="headerlink" title="dp实现"></a>dp实现</h3><p>本质上就是枚举边界和长度，然后更新一下dp数组就好了</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line">       <span class="keyword">public</span> <span class="keyword">static</span> String <span class="title function_">dpSolve</span><span class="params">(String str)</span>&#123;</span><br><span class="line">        <span class="type">int</span> maxlen=<span class="number">1</span>,start=<span class="number">0</span>;</span><br><span class="line">        <span class="type">int</span> len=str.length();</span><br><span class="line">        <span class="type">boolean</span>[][] dp=<span class="keyword">new</span> <span class="title class_">boolean</span>[len][len];</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;len;i++)</span><br><span class="line">            dp[i][i]=<span class="literal">true</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> length=<span class="number">2</span>;length&lt;=len;length++) &#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; len; i++) &#123;</span><br><span class="line">                <span class="type">int</span> <span class="variable">j</span> <span class="operator">=</span> length + i - <span class="number">1</span>;</span><br><span class="line">                <span class="keyword">if</span>(j&gt;=len)</span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line">                <span class="keyword">if</span> (str.charAt(i) != str.charAt(j))</span><br><span class="line">                    dp[i][j] = <span class="literal">false</span>;</span><br><span class="line">                <span class="keyword">else</span> &#123;</span><br><span class="line">                    <span class="keyword">if</span> (j - i &lt; <span class="number">3</span>)</span><br><span class="line">                        dp[i][j] = <span class="literal">true</span>;</span><br><span class="line">                    <span class="keyword">else</span></span><br><span class="line">                        dp[i][j] = dp[i + <span class="number">1</span>][j - <span class="number">1</span>];</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">if</span> (dp[i][j] &amp;&amp; j - i + <span class="number">1</span> &gt; maxlen) &#123;</span><br><span class="line">                    maxlen = j - i + <span class="number">1</span>;</span><br><span class="line">                    start = i;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> str.substring(start,start+maxlen);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="数论"><a href="#数论" class="headerlink" title="数论"></a>数论</h1><h2 id="埃氏筛"><a href="#埃氏筛" class="headerlink" title="埃氏筛"></a>埃氏筛</h2><p>就是从质数2开始，其整数倍均不为质数，将区间内所有的2的倍数的下标，标记为false，代表不为质数，再从第二个质数开始，将其倍数标记为false，以此循环，最后留下来的都是质数。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">const</span> <span class="type">int</span> MAX = <span class="number">1e5</span>+<span class="number">1</span>;</span><br><span class="line"><span class="type">int</span> isPrime[MAX];</span><br><span class="line"><span class="type">int</span> Prime[MAX];</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">solve</span><span class="params">(<span class="type">int</span> n)</span> </span>&#123;</span><br><span class="line"><span class="type">int</span> n,ptr=<span class="number">0</span>; cin &gt;&gt; n;</span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt;= n; i++)</span><br><span class="line">isPrime[i] = <span class="number">1</span>;</span><br><span class="line">isPrime[<span class="number">0</span>] = isPrime[<span class="number">1</span>] = <span class="literal">false</span>;</span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">2</span>; i &lt;= n; i++) &#123;</span><br><span class="line"><span class="keyword">if</span> (isPrime[i]) &#123;</span><br><span class="line">Prime[ptr++] = i;</span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> j = <span class="number">2</span> * i; j &lt;= n; j += i)</span><br><span class="line">isPrime[j] = <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; ptr; i++)</span><br><span class="line">cout &lt;&lt; Prime[i] &lt;&lt; endl;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="欧拉筛"><a href="#欧拉筛" class="headerlink" title="欧拉筛"></a>欧拉筛</h2><p>核心思想是让每一个合数被其最小质因数筛到<br>关键就在于  <em><strong>if(i%isprime[j]&#x3D;&#x3D;0)</strong></em></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="type">const</span> <span class="type">int</span> Max = <span class="number">1e8</span> + <span class="number">5</span>;</span><br><span class="line"><span class="type">int</span> n, numPrime;</span><br><span class="line"><span class="type">int</span> prime[Max];</span><br><span class="line"><span class="type">bool</span> isPrime[Max];</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    std::ios::<span class="built_in">sync_with_stdio</span>(<span class="literal">false</span>);</span><br><span class="line">    cin.<span class="built_in">tie</span>(<span class="number">0</span>);</span><br><span class="line">    cin &gt;&gt; n;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">2</span>; i &lt;= n; i++) &#123;</span><br><span class="line">        <span class="keyword">if</span> (!isPrime[i])</span><br><span class="line">            prime[numPrime++] = i;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> j = <span class="number">0</span>; j &lt; numPrime; j++) &#123;</span><br><span class="line">            <span class="keyword">if</span> (i * prime[j] &gt; n)</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            isPrime[i * prime[j]] = <span class="literal">true</span>;</span><br><span class="line">            <span class="keyword">if</span> (i % prime[j] == <span class="number">0</span>)</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    cout &lt;&lt; numPrime;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="数据结构"><a href="#数据结构" class="headerlink" title="数据结构"></a>数据结构</h1><h2 id="单调栈"><a href="#单调栈" class="headerlink" title="单调栈"></a>单调栈</h2><p>保证栈中元素为单调递减或者递增的数据结构</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">stack&lt;<span class="type">int</span>&gt; S;</span><br><span class="line"><span class="type">int</span> T; cin &gt;&gt; T;</span><br><span class="line"><span class="keyword">while</span> (T--) &#123;</span><br><span class="line"><span class="type">int</span> x; cin &gt;&gt; x;</span><br><span class="line"><span class="keyword">while</span> (!S.<span class="built_in">empty</span>() &amp;&amp; S.<span class="built_in">top</span>() &gt; x)</span><br><span class="line">S.<span class="built_in">pop</span>();</span><br><span class="line">S.<span class="built_in">push</span>(x);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">while</span> (!S.<span class="built_in">empty</span>()) &#123;</span><br><span class="line"><span class="type">int</span> temp = S.<span class="built_in">top</span>();</span><br><span class="line">S.<span class="built_in">pop</span>();</span><br><span class="line">cout &lt;&lt; temp&lt;&lt;<span class="string">&quot; &quot;</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>模拟单调栈</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="type">unsigned</span> <span class="type">long</span> <span class="type">long</span> ull;</span><br><span class="line">ull n,top,ans,c[<span class="number">2000001</span>],s[<span class="number">2000001</span>];</span><br><span class="line"><span class="comment">//top 栈首</span></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>,&amp;n);</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=n;i++)</span><br><span class="line">        <span class="built_in">scanf</span>(<span class="string">&quot;%llu&quot;</span>,&amp;c[i]);</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=n;i++)&#123;</span><br><span class="line">        <span class="keyword">while</span>(top&amp;&amp;c[i]&gt;=c[s[top]])&#123;</span><br><span class="line">            ans^=s[top];</span><br><span class="line">            top--;</span><br><span class="line">        &#125;</span><br><span class="line">        ans^=i;</span><br><span class="line">        s[++top]=i;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;%llu\n&quot;</span>,ans);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="单调队列"><a href="#单调队列" class="headerlink" title="单调队列"></a>单调队列</h2><p>保证队列中的元素单调递增或者单调递减</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">deque&lt;<span class="type">int</span>&gt; Q; </span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; n; ++i)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">if</span> (!Q.<span class="built_in">empty</span>() &amp;&amp; i - Q.<span class="built_in">front</span>() &gt;= m)</span><br><span class="line">        Q.<span class="built_in">pop_front</span>();</span><br><span class="line">    <span class="keyword">while</span> (!Q.<span class="built_in">empty</span>() &amp;&amp; V[Q.<span class="built_in">back</span>()] &lt; V[i])</span><br><span class="line">        Q.<span class="built_in">pop_back</span>();</span><br><span class="line">    Q.<span class="built_in">push_back</span>(i); </span><br><span class="line">    <span class="keyword">if</span> (i &gt;= m - <span class="number">1</span>)</span><br><span class="line">        cout &lt;&lt; V[Q.<span class="built_in">front</span>()] &lt;&lt; <span class="string">&quot; &quot;</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>模拟单调队列</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line">ll a[MAX],q[MAX],front=<span class="number">1</span>,rear=<span class="number">0</span>;<span class="comment">//front队首，rear队尾 </span></span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=n;i++)</span><br><span class="line">    &#123;</span><br><span class="line"><span class="keyword">while</span>(front&lt;=rear&amp;&amp;a[q[rear]]&gt;=a[i])</span><br><span class="line">rear--;</span><br><span class="line">q[++rear]=i;</span><br><span class="line"><span class="keyword">if</span>(q[front]&lt;i-k+<span class="number">1</span>)</span><br><span class="line">front++;</span><br><span class="line"><span class="keyword">if</span>(i&gt;=k)</span><br><span class="line">cout&lt;&lt;a[q[front]]&lt;&lt;<span class="string">&quot; &quot;</span>;</span><br><span class="line">&#125;</span><br><span class="line">cout&lt;&lt;endl;</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=n;i++)&#123;</span><br><span class="line"><span class="keyword">while</span>(front&lt;=rear&amp;&amp;a[q[rear]]&lt;=a[i])</span><br><span class="line">rear--;</span><br><span class="line">q[++rear]=i;</span><br><span class="line"><span class="keyword">if</span>(q[front]&lt;i-k+<span class="number">1</span>)</span><br><span class="line">front++;</span><br><span class="line"><span class="keyword">if</span>(i&gt;=k)</span><br><span class="line">cout&lt;&lt;a[q[front]]&lt;&lt;<span class="string">&quot; &quot;</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="字典树"><a href="#字典树" class="headerlink" title="字典树"></a>字典树</h2><h3 id="数组存储"><a href="#数组存储" class="headerlink" title="数组存储"></a>数组存储</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="keyword">typedef</span> <span class="type">long</span> <span class="type">long</span> ll;</span><br><span class="line"><span class="comment">//Trie</span></span><br><span class="line"><span class="type">const</span> <span class="type">int</span> MAX = <span class="number">1e6</span> + <span class="number">10</span>;</span><br><span class="line"><span class="type">const</span> <span class="type">int</span> charsize = <span class="number">27</span>;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">//记录此节点的子节点编号（默认为小写字母）</span></span><br><span class="line"><span class="type">int</span> nxt[MAX][charsize];</span><br><span class="line"></span><br><span class="line"><span class="comment">//是否为终止节点</span></span><br><span class="line"><span class="type">bool</span> isend[MAX];</span><br><span class="line"></span><br><span class="line"><span class="comment">//cnt保存当前节点编号数</span></span><br><span class="line"><span class="type">int</span> root = <span class="number">0</span>, cnt = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">insert</span><span class="params">(<span class="type">char</span> s[], <span class="type">int</span> len)</span> </span>&#123;</span><br><span class="line"><span class="type">int</span> now = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt;= len; i++) &#123;</span><br><span class="line"><span class="type">int</span> x = s[i] - <span class="number">1</span>;</span><br><span class="line"><span class="keyword">if</span> (!nxt[now][x])</span><br><span class="line">nxt[now][x] = ++cnt;</span><br><span class="line">now = nxt[now][x];</span><br><span class="line">&#125;</span><br><span class="line">isend[now] = <span class="number">1</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">bool</span> <span class="title">search</span><span class="params">(<span class="type">char</span> s[], <span class="type">int</span> len)</span> </span>&#123;</span><br><span class="line"><span class="type">int</span> now = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt;= len; i++) &#123;</span><br><span class="line"><span class="type">int</span> x = s[i] - <span class="string">&#x27;a&#x27;</span>;</span><br><span class="line"><span class="keyword">if</span> (!nxt[now][x])</span><br><span class="line"><span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">now = nxt[now][x];</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> isend[now];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">std::ios::<span class="built_in">sync_with_stdio</span>(<span class="literal">false</span>);</span><br><span class="line">cin.<span class="built_in">tie</span>(<span class="number">0</span>); cout.<span class="built_in">tie</span>(<span class="number">0</span>);</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="结构体写法"><a href="#结构体写法" class="headerlink" title="结构体写法"></a>结构体写法</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//正常</span></span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">TreeNode1</span> &#123;</span><br><span class="line"><span class="type">int</span> nxt[charsize];</span><br><span class="line"><span class="type">bool</span> isend;</span><br><span class="line">&#125;tree1[MAX];</span><br><span class="line"></span><br><span class="line"><span class="comment">//字符集较大</span></span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">TreeNode2</span> &#123;</span><br><span class="line">unordered_map&lt;<span class="type">char</span>, <span class="type">int</span>&gt; nxt_map;</span><br><span class="line"><span class="type">bool</span> isend;</span><br><span class="line">&#125;tree2[MAX];</span><br><span class="line"></span><br><span class="line"><span class="comment">//指针写法</span></span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">TreeNode3</span> &#123;</span><br><span class="line">TreeNode3* nxt[charsize];</span><br><span class="line"><span class="type">bool</span> isend;</span><br><span class="line">&#125;tree3[MAX];<span class="comment">//insert search的操作思路类似，不写了。</span></span><br></pre></td></tr></table></figure><h3 id="统计前缀"><a href="#统计前缀" class="headerlink" title="统计前缀"></a>统计前缀</h3><p>把isend数组改成tol数组记录一下以某个位置为重点的字符串为前缀的数量就可以了。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="keyword">typedef</span> <span class="type">long</span> <span class="type">long</span> ll;</span><br><span class="line"><span class="type">const</span> <span class="type">int</span> charsize = <span class="number">70</span>;</span><br><span class="line"><span class="type">const</span> <span class="type">int</span> MAXN = <span class="number">3e6</span> + <span class="number">10</span>;</span><br><span class="line"><span class="type">int</span> nxt[MAXN][charsize],root,cnt;</span><br><span class="line"><span class="type">int</span> tol[MAXN];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">getnum</span><span class="params">(<span class="type">char</span> x)</span> </span>&#123;</span><br><span class="line"><span class="keyword">if</span> (x &gt;= <span class="string">&#x27;A&#x27;</span> &amp;&amp; x &lt;= <span class="string">&#x27;Z&#x27;</span>)</span><br><span class="line"><span class="keyword">return</span> x - <span class="string">&#x27;A&#x27;</span>;</span><br><span class="line"><span class="keyword">else</span> <span class="keyword">if</span> (x &gt;= <span class="string">&#x27;a&#x27;</span> &amp;&amp; x &lt;= <span class="string">&#x27;z&#x27;</span>)</span><br><span class="line"><span class="keyword">return</span> x - <span class="string">&#x27;a&#x27;</span> + <span class="number">26</span>;</span><br><span class="line"><span class="keyword">else</span></span><br><span class="line"><span class="keyword">return</span> x - <span class="string">&#x27;0&#x27;</span> + <span class="number">52</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">init</span><span class="params">(<span class="type">int</span> n)</span> </span>&#123;</span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; n; i++) &#123;</span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> j = <span class="number">0</span>; j &lt; charsize; j++) &#123;</span><br><span class="line">nxt[i][j] = <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; n; i++)</span><br><span class="line">tol[i] = <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">std::ios::<span class="built_in">sync_with_stdio</span>(<span class="literal">false</span>);</span><br><span class="line">cin.<span class="built_in">tie</span>(<span class="number">0</span>); cout.<span class="built_in">tie</span>(<span class="number">0</span>);</span><br><span class="line"><span class="type">int</span> T; cin &gt;&gt; T;</span><br><span class="line"><span class="keyword">while</span> (T--) &#123;</span><br><span class="line"><span class="built_in">init</span>(cnt + <span class="number">1</span>);</span><br><span class="line">root = <span class="number">0</span>, cnt = <span class="number">0</span>;</span><br><span class="line"><span class="type">int</span> n, q; cin &gt;&gt; n &gt;&gt; q;</span><br><span class="line"><span class="keyword">while</span>(n--)&#123;</span><br><span class="line">string s; cin &gt;&gt; s;</span><br><span class="line"><span class="type">int</span> now = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; s.<span class="built_in">size</span>(); i++) &#123;</span><br><span class="line"><span class="type">int</span> x = <span class="built_in">getnum</span>(s[i]);</span><br><span class="line"><span class="keyword">if</span> (!nxt[now][x])</span><br><span class="line">nxt[now][x] = ++cnt;</span><br><span class="line">now = nxt[now][x];</span><br><span class="line">tol[now]++;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">while</span>(q--) &#123;</span><br><span class="line">string pat; cin &gt;&gt; pat;</span><br><span class="line"><span class="type">int</span> now = <span class="number">0</span>,flag=<span class="number">1</span>;</span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; pat.<span class="built_in">size</span>(); i++) &#123;</span><br><span class="line"><span class="type">int</span> x = <span class="built_in">getnum</span>(pat[i]);</span><br><span class="line"><span class="keyword">if</span> (!nxt[now][x]) &#123;</span><br><span class="line">flag = <span class="number">0</span>;</span><br><span class="line">cout &lt;&lt; <span class="number">0</span> &lt;&lt; endl;</span><br><span class="line"><span class="keyword">break</span>;</span><br><span class="line">&#125;</span><br><span class="line">now = nxt[now][x];</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">if</span>(flag)</span><br><span class="line">cout &lt;&lt; tol[now] &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="链表"><a href="#链表" class="headerlink" title="链表"></a>链表</h2><h3 id="单链"><a href="#单链" class="headerlink" title="单链"></a>单链</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">struct</span> <span class="title class_">link</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="type">int</span> data;</span><br><span class="line">link* next;</span><br><span class="line">link* last;</span><br><span class="line">&#125; ;</span><br><span class="line"></span><br><span class="line"><span class="function">link* <span class="title">creatlink</span><span class="params">()</span><span class="comment">//创建一个头结点，链表的起始位置。</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">link* headNode = (link*)<span class="built_in">malloc</span>(<span class="built_in">sizeof</span>(link));</span><br><span class="line"><span class="keyword">if</span> (headNode == <span class="literal">NULL</span>)</span><br><span class="line"><span class="built_in">exit</span>(<span class="number">1</span>);</span><br><span class="line">headNode-&gt;next = <span class="literal">NULL</span>;</span><br><span class="line">headNode-&gt;last = <span class="literal">NULL</span>;</span><br><span class="line"><span class="keyword">return</span> headNode;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function">link* <span class="title">creatNode</span><span class="params">(<span class="type">int</span> data)</span><span class="comment">//创建一个结点，后续将其插入链表。</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">link* NewNode = (link*)<span class="built_in">malloc</span>(<span class="built_in">sizeof</span>(link));</span><br><span class="line"><span class="keyword">if</span> (NewNode == <span class="literal">NULL</span>)</span><br><span class="line"><span class="built_in">exit</span>(<span class="number">1</span>);</span><br><span class="line">NewNode-&gt;data = data;</span><br><span class="line">NewNode-&gt;next = <span class="literal">NULL</span>;</span><br><span class="line">NewNode-&gt;last = <span class="literal">NULL</span>;</span><br><span class="line"><span class="keyword">return</span> NewNode;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"> <span class="function"><span class="type">void</span> <span class="title">addNode</span><span class="params">(link * headNode,<span class="type">int</span> data)</span><span class="comment">//为该链表添加一个结点</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">link* AddNode = <span class="built_in">creatNode</span>(data); </span><br><span class="line">AddNode-&gt;next = headNode-&gt;next;</span><br><span class="line">headNode-&gt;next = AddNode;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"> <span class="function"><span class="type">void</span> <span class="title">delNode</span><span class="params">(link* headNode, <span class="type">int</span> num)</span><span class="comment">//删除某个节点</span></span></span><br><span class="line"><span class="function"> </span>&#123;</span><br><span class="line"> link* pmove = headNode-&gt;next;</span><br><span class="line"> link* p1move = headNode;         <span class="keyword">if</span>(p1move-&gt;data==num)&#123;            headNode-&gt;next=<span class="literal">NULL</span>;            headNode=pmove;                    &#125;</span><br><span class="line"> <span class="keyword">while</span> (pmove)</span><br><span class="line"> &#123;</span><br><span class="line"> <span class="keyword">if</span> (pmove-&gt;data == num)</span><br><span class="line"> &#123;</span><br><span class="line"> p1move-&gt;next = pmove-&gt;next;</span><br><span class="line"> &#125;</span><br><span class="line"> pmove=pmove-&gt;next;</span><br><span class="line"> p1move=p1move-&gt;next;</span><br><span class="line"> &#125;</span><br><span class="line"> &#125;</span><br><span class="line"></span><br><span class="line"> <span class="function"><span class="type">void</span> <span class="title">insertNode</span><span class="params">(link* headNode, <span class="type">int</span> num,<span class="type">int</span> data)</span> </span>&#123;</span><br><span class="line"> link* pmove = headNode-&gt;next;</span><br><span class="line"> link* p1move = headNode;</span><br><span class="line"> link* node = <span class="built_in">creatNode</span>(data);</span><br><span class="line"> <span class="keyword">while</span> (pmove)</span><br><span class="line"> &#123;</span><br><span class="line"> <span class="keyword">if</span> (pmove-&gt;data == num)</span><br><span class="line"> &#123;</span><br><span class="line"> node-&gt;next = pmove-&gt;next;</span><br><span class="line"> pmove-&gt;next = node;</span><br><span class="line"> <span class="keyword">break</span>;</span><br><span class="line"> &#125;</span><br><span class="line"> pmove = pmove-&gt;next;</span><br><span class="line"> p1move = p1move-&gt;next;</span><br><span class="line"> &#125;</span><br><span class="line"> &#125;</span><br><span class="line"><span class="function"><span class="type">int</span>  <span class="title">printflink</span><span class="params">(link* headNode)</span><span class="comment">//打印节点数据</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">link* ptrmove = headNode-&gt;next;</span><br><span class="line"><span class="keyword">while</span> (ptrmove)</span><br><span class="line">&#123;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;%d\n&quot;</span>, ptrmove-&gt;data);</span><br><span class="line">ptrmove =ptrmove-&gt;next;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">lastaddNode</span><span class="params">(link* headNode, <span class="type">int</span> num)</span><span class="comment">//在链表末尾添加一个新的节点</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">link* Node1 = <span class="built_in">lastNode</span>(headNode); </span><br><span class="line">link* AddNode = <span class="built_in">creatNode</span>(num);</span><br><span class="line">Node1-&gt;next = AddNode;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function">link* <span class="title">lastNode</span><span class="params">(link* headNode)</span><span class="comment">//使当前指针指到链表最后一个节点。</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">while</span> (headNode-&gt;next)</span><br><span class="line">&#123;</span><br><span class="line">headNode = headNode-&gt;next;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> headNode;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="双链"><a href="#双链" class="headerlink" title="双链"></a>双链</h3><p>双链只需要在数据结构上附加一个域，包含指向前一个单元的指针即可。</p><h3 id="Floyd-判圈算法"><a href="#Floyd-判圈算法" class="headerlink" title="Floyd 判圈算法"></a>Floyd 判圈算法</h3><p><em><strong>判断是否有环</strong></em><br>定义两个指针p1与p2，起始时，都指向链表的起点A，p1每次移动1个长度，p2每次移动2个长度。如果p2在移到链表的尾端时，并未与p1相遇，表明链表中不存在环。如果p1与p2相遇在环上的某一点C，表明链表有环。</p><p><em><strong>环的长度</strong></em><br>将指针p1固定在相遇位置C，移动p2，每次移动1个长度，并用变量计数。当p2再次与p1相遇时，此时该变量的值就是环的长度。</p><p><em><strong>环的起点</strong></em><br>将指针p1指向链表的起始位置A，指针p2仍在位置C，指针p1与p2每次均移动一个单位，p1与p2再次相遇的位置就是环的起点位置点B。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//判断链表中是否有环</span></span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">Node</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">int</span> data;</span><br><span class="line">    Node* next;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="function"><span class="type">bool</span> <span class="title">findCircle</span><span class="params">(Node* list)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (list == <span class="literal">NULL</span> || list-&gt;next == <span class="literal">NULL</span>)</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    Node* ptr_slow = list, *ptr_fast = list;</span><br><span class="line">    <span class="keyword">while</span> (ptr_fast != ptr_slow) &#123;</span><br><span class="line">        <span class="keyword">if</span> (ptr_fast == <span class="literal">NULL</span> || ptr_fast-&gt;next == <span class="literal">NULL</span>)</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">        ptr_slow = ptr_slow-&gt;next;</span><br><span class="line">        ptr_fast = ptr_fast-&gt;next-&gt;next;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//寻找环的起点</span></span><br><span class="line"> <span class="function">Node *<span class="title">detectCycle</span><span class="params">(Node *head)</span> </span>&#123;</span><br><span class="line">       Node *ptr_slow = head, *ptr_fast = head;</span><br><span class="line">        <span class="keyword">while</span> (ptr_fast != <span class="literal">NULL</span>) &#123;</span><br><span class="line">            ptr_slow = ptr_slow-&gt;next;</span><br><span class="line">            <span class="keyword">if</span> (ptr_fast-&gt;ptr_next == <span class="literal">NULL</span>)</span><br><span class="line">                <span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line">            ptr_fast = ptr_fast-&gt;next-&gt;next;</span><br><span class="line">            <span class="keyword">if</span> (ptr_fast == ptr_slow) &#123;</span><br><span class="line">                Node *ptr = head;</span><br><span class="line">                <span class="keyword">while</span> (ptr != ptr_slow) &#123;</span><br><span class="line">                    ptr = ptr-&gt;next;</span><br><span class="line">                    ptr_slow = ptr_slow-&gt;next;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">return</span> ptr;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="树"><a href="#树" class="headerlink" title="树"></a>树</h2><h3 id="二叉查找树"><a href="#二叉查找树" class="headerlink" title="二叉查找树"></a>二叉查找树</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">struct</span> <span class="title class_">DoubleTree</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="type">int</span> data;</span><br><span class="line">DoubleTree* lchild;</span><br><span class="line">DoubleTree* rchild;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="function">DoubleTree* <span class="title">creatHead</span><span class="params">(<span class="type">int</span> num)</span> </span>&#123;</span><br><span class="line">DoubleTree* Tree = <span class="keyword">new</span> DoubleTree;</span><br><span class="line">Tree-&gt;data = num;</span><br><span class="line">Tree-&gt;lchild = <span class="literal">NULL</span>;</span><br><span class="line">Tree-&gt;rchild = <span class="literal">NULL</span>;</span><br><span class="line"><span class="keyword">return</span> Tree;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function">DoubleTree* <span class="title">MakeEmpty</span><span class="params">(DoubleTree* Tree)</span> </span>&#123;</span><br><span class="line"><span class="keyword">if</span> (Tree != <span class="literal">NULL</span>) &#123;</span><br><span class="line"><span class="built_in">MakeEmpty</span>(Tree-&gt;lchild);</span><br><span class="line"><span class="built_in">MakeEmpty</span>(Tree-&gt;rchild);</span><br><span class="line"><span class="built_in">free</span>(Tree);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function">DoubleTree* <span class="title">Find</span><span class="params">(DoubleTree* Tree, <span class="type">int</span> Key)</span> </span>&#123;</span><br><span class="line"><span class="keyword">if</span> (Tree == <span class="literal">NULL</span>) <span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line"><span class="keyword">if</span> (Key &lt; Tree-&gt;data)</span><br><span class="line"><span class="keyword">return</span> <span class="built_in">Find</span>(Tree-&gt;lchild, Key);</span><br><span class="line"><span class="keyword">else</span> <span class="keyword">if</span> (Key &gt; Tree-&gt;data)</span><br><span class="line"><span class="keyword">return</span> <span class="built_in">Find</span>(Tree-&gt;rchild, Key);</span><br><span class="line"><span class="keyword">else</span></span><br><span class="line"><span class="keyword">return</span> Tree;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function">DoubleTree* <span class="title">FindMin</span><span class="params">(DoubleTree* Tree)</span> </span>&#123;</span><br><span class="line"><span class="keyword">if</span> (Tree == <span class="literal">NULL</span>) <span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line"><span class="keyword">else</span> <span class="keyword">if</span> (Tree-&gt;lchild == <span class="literal">NULL</span>) <span class="keyword">return</span> Tree;</span><br><span class="line"><span class="keyword">else</span> <span class="keyword">return</span> <span class="built_in">FindMin</span>(Tree-&gt;lchild);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function">DoubleTree* <span class="title">FindMax</span><span class="params">(DoubleTree* Tree)</span> </span>&#123;</span><br><span class="line"><span class="keyword">if</span> (Tree == <span class="literal">NULL</span>) <span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line"><span class="keyword">else</span> <span class="keyword">if</span> (Tree-&gt;rchild == <span class="literal">NULL</span>) <span class="keyword">return</span> Tree;</span><br><span class="line"><span class="keyword">else</span> <span class="keyword">return</span> <span class="built_in">FindMax</span>(Tree-&gt;rchild);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function">DoubleTree* <span class="title">insert</span><span class="params">(DoubleTree* Tree, <span class="type">int</span> x)</span> </span>&#123;</span><br><span class="line"><span class="keyword">if</span> (Tree == <span class="literal">NULL</span>) &#123;</span><br><span class="line">Tree = <span class="keyword">new</span> DoubleTree;</span><br><span class="line"><span class="keyword">if</span> (Tree == <span class="literal">NULL</span>) <span class="built_in">exit</span>(<span class="number">1</span>);</span><br><span class="line"><span class="keyword">else</span> &#123;</span><br><span class="line">Tree-&gt;data = x;</span><br><span class="line">Tree-&gt;lchild = <span class="literal">NULL</span>;</span><br><span class="line">Tree-&gt;rchild = <span class="literal">NULL</span>;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span> <span class="keyword">if</span> (x &lt; Tree-&gt;data)</span><br><span class="line">Tree-&gt;lchild = <span class="built_in">insert</span>(Tree-&gt;lchild, x);</span><br><span class="line"><span class="keyword">else</span> <span class="keyword">if</span> (x &gt; Tree-&gt;data)</span><br><span class="line">Tree-&gt;rchild = <span class="built_in">insert</span>(Tree-&gt;rchild, x);</span><br><span class="line"><span class="keyword">return</span> Tree;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function">DoubleTree* <span class="title">DeleteNode</span><span class="params">(DoubleTree* Tree, <span class="type">int</span> x)</span> </span>&#123;</span><br><span class="line">DoubleTree* temp;</span><br><span class="line"><span class="keyword">if</span> (Tree == <span class="literal">NULL</span>) <span class="built_in">exit</span>(<span class="number">1</span>);</span><br><span class="line"><span class="keyword">else</span> <span class="keyword">if</span> ((x &lt; Tree-&gt;data))</span><br><span class="line">Tree-&gt;lchild = <span class="built_in">DeleteNode</span>(Tree-&gt;lchild, x);</span><br><span class="line"><span class="keyword">else</span> <span class="keyword">if</span> ((x &gt; Tree-&gt;data))</span><br><span class="line">Tree-&gt;rchild = <span class="built_in">DeleteNode</span>(Tree-&gt;rchild, x);</span><br><span class="line"><span class="keyword">else</span> <span class="keyword">if</span> (Tree-&gt;lchild &amp;&amp; Tree-&gt;rchild) &#123;</span><br><span class="line">temp = <span class="built_in">FindMin</span>(Tree-&gt;rchild);</span><br><span class="line">Tree-&gt;data = temp-&gt;data;</span><br><span class="line">Tree-&gt;rchild = <span class="built_in">DeleteNode</span>(Tree-&gt;rchild, Tree-&gt;data);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span> &#123;</span><br><span class="line">temp = Tree; </span><br><span class="line"><span class="keyword">if</span> (Tree-&gt;lchild == <span class="literal">NULL</span>) Tree = Tree-&gt;rchild;</span><br><span class="line"><span class="keyword">else</span> <span class="keyword">if</span> (Tree-&gt;rchild == <span class="literal">NULL</span>) Tree = Tree-&gt;lchild;</span><br><span class="line"><span class="built_in">free</span>(temp);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> Tree;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">print</span><span class="params">(DoubleTree* Tree)</span> </span>&#123;</span><br><span class="line"><span class="keyword">if</span> (Tree == <span class="literal">NULL</span>)</span><br><span class="line"><span class="keyword">return</span>;</span><br><span class="line">cout &lt;&lt; Tree-&gt;data &lt;&lt; <span class="string">&quot; &quot;</span>;</span><br><span class="line"><span class="built_in">print</span>(Tree-&gt;lchild);</span><br><span class="line"><span class="built_in">print</span>(Tree-&gt;rchild);</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="AVL树（平衡二叉树）"><a href="#AVL树（平衡二叉树）" class="headerlink" title="AVL树（平衡二叉树）"></a>AVL树（平衡二叉树）</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">AVLtree* <span class="title">SingerotateWihtleft</span><span class="params">(AVLtree* T)</span> </span>&#123;<span class="comment">//左左</span></span><br><span class="line">AVLtree* T1;</span><br><span class="line">T1 = T-&gt;lchild;</span><br><span class="line">T-&gt;lchild = T1-&gt;rchild;</span><br><span class="line">T1-&gt;rchild = T;</span><br><span class="line">T-&gt;height = <span class="built_in">max</span>(<span class="built_in">returnHeight</span>(T-&gt;lchild), <span class="built_in">returnHeight</span>(T-&gt;rchild)) + <span class="number">1</span>;</span><br><span class="line">T1-&gt;height = <span class="built_in">max</span>(<span class="built_in">returnHeight</span>(T1-&gt;lchild), T-&gt;height) + <span class="number">1</span>;</span><br><span class="line"><span class="keyword">return</span> T1;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function">AVLtree* <span class="title">SingerotateWihtright</span><span class="params">(AVLtree* T)</span> </span>&#123;<span class="comment">//右右</span></span><br><span class="line">AVLtree* T1;</span><br><span class="line">T1 = T-&gt;rchild;</span><br><span class="line">T-&gt;rchild = T1-&gt;lchild;</span><br><span class="line">T1-&gt;lchild = T;</span><br><span class="line">T-&gt;height = <span class="built_in">max</span>(<span class="built_in">returnHeight</span>(T-&gt;lchild), <span class="built_in">returnHeight</span>(T-&gt;rchild)) + <span class="number">1</span>;</span><br><span class="line">T1-&gt;height = <span class="built_in">max</span>(T-&gt;height, <span class="built_in">returnHeight</span>(T1-&gt;rchild)) + <span class="number">1</span>;</span><br><span class="line"><span class="keyword">return</span> T1;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function">AVLtree* <span class="title">DoublerotateWihtleft</span><span class="params">(AVLtree* T)</span> </span>&#123;<span class="comment">//左右</span></span><br><span class="line">T-&gt;lchild = <span class="built_in">SingerotateWihtright</span>(T-&gt;lchild);</span><br><span class="line"><span class="keyword">return</span> <span class="built_in">SingerotateWihtleft</span>(T);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function">AVLtree* <span class="title">DoublerotateWihtright</span><span class="params">(AVLtree* T)</span> </span>&#123;<span class="comment">//右坐</span></span><br><span class="line">T-&gt;rchild = <span class="built_in">SingerotateWihtleft</span>(T-&gt;rchild);</span><br><span class="line"><span class="keyword">return</span> <span class="built_in">SingerotateWihtright</span>(T);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function">AVLtree* <span class="title">insertNode</span><span class="params">(AVLtree* T,<span class="type">int</span> x)</span> </span>&#123;</span><br><span class="line"><span class="keyword">if</span> (T == <span class="literal">NULL</span>) &#123;</span><br><span class="line">T = <span class="keyword">new</span> AVLtree;</span><br><span class="line"><span class="keyword">if</span> (T == <span class="literal">NULL</span>) <span class="built_in">exit</span>(<span class="number">1</span>);</span><br><span class="line"><span class="keyword">else</span> &#123;</span><br><span class="line">T-&gt;data = x; T-&gt;height = <span class="number">0</span>;</span><br><span class="line">T-&gt;lchild = <span class="literal">NULL</span>; T-&gt;rchild = <span class="literal">NULL</span>;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span> <span class="keyword">if</span> (x &lt; T-&gt;data) &#123;</span><br><span class="line">T-&gt;lchild = <span class="built_in">insertNode</span>(T-&gt;lchild, x);</span><br><span class="line"><span class="keyword">if</span> (<span class="built_in">returnHeight</span>(T-&gt;lchild) - <span class="built_in">returnHeight</span>(T-&gt;rchild) == <span class="number">2</span>) &#123;</span><br><span class="line"><span class="keyword">if</span> (x &lt; T-&gt;lchild-&gt;data)</span><br><span class="line">T = <span class="built_in">SingerotateWihtleft</span>(T);</span><br><span class="line"><span class="keyword">else</span></span><br><span class="line">T = <span class="built_in">DoublerotateWihtleft</span>(T);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span> <span class="keyword">if</span> (x &gt; T-&gt;data) &#123;</span><br><span class="line">T-&gt;rchild = <span class="built_in">insertNode</span>(T-&gt;rchild, x);</span><br><span class="line"><span class="keyword">if</span> (<span class="built_in">returnHeight</span>(T-&gt;rchild) - <span class="built_in">returnHeight</span>(T-&gt;lchild) == <span class="number">2</span>) &#123;</span><br><span class="line"><span class="keyword">if</span> (x &gt; T-&gt;rchild-&gt;data)</span><br><span class="line">T = <span class="built_in">SingerotateWihtright</span>(T);</span><br><span class="line"><span class="keyword">else</span></span><br><span class="line">T = <span class="built_in">DoublerotateWihtright</span>(T);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">T-&gt;height = <span class="built_in">max</span>(<span class="built_in">returnHeight</span>(T-&gt;lchild), <span class="built_in">returnHeight</span>(T-&gt;rchild))+<span class="number">1</span>;</span><br><span class="line"><span class="keyword">return</span> T;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function">AVLtree* <span class="title">DeleteNode</span><span class="params">(AVLtree* T, <span class="type">int</span> num)</span> </span>&#123;<span class="comment">//太麻烦了，删除操作相对较少懒惰删除是最好的策略</span></span><br><span class="line">AVLtree* temp = <span class="literal">NULL</span>;</span><br><span class="line"><span class="keyword">if</span> (T == <span class="literal">NULL</span>) cout &lt;&lt; <span class="string">&quot;NO data&quot;</span> &lt;&lt; endl;</span><br><span class="line"><span class="keyword">else</span> <span class="keyword">if</span> (num &lt; T-&gt;data)</span><br><span class="line">T-&gt;lchild = <span class="built_in">DeleteNode</span>(T-&gt;lchild, num);</span><br><span class="line"><span class="keyword">else</span> <span class="keyword">if</span> (num &gt; T-&gt;data)</span><br><span class="line">T-&gt;rchild = <span class="built_in">DeleteNode</span>(T-&gt;rchild, num);</span><br><span class="line"><span class="keyword">else</span> <span class="keyword">if</span> (T-&gt;lchild &amp;&amp; T-&gt;rchild) &#123;</span><br><span class="line">temp = <span class="built_in">FindMin</span>(T);</span><br><span class="line">T-&gt;data = temp-&gt;data;</span><br><span class="line">T-&gt;rchild = <span class="built_in">DeleteNode</span>(T-&gt;rchild, T-&gt;data);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span> &#123;</span><br><span class="line">temp = T;</span><br><span class="line"><span class="keyword">if</span> (T-&gt;lchild == <span class="literal">NULL</span>)</span><br><span class="line">T = T-&gt;rchild;</span><br><span class="line"><span class="keyword">else</span> <span class="keyword">if</span> (T-&gt;rchild == <span class="literal">NULL</span>)</span><br><span class="line">T = T-&gt;lchild;</span><br><span class="line"><span class="built_in">free</span>(temp);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">if</span> (T!=<span class="literal">NULL</span>) &#123;</span><br><span class="line"><span class="type">int</span> lheight = <span class="built_in">returnHeight</span>(T-&gt;lchild), rheight = <span class="built_in">returnHeight</span>(T-&gt;rchild);</span><br><span class="line">T-&gt;height = (lheight &gt; rheight ? lheight : rheight)+<span class="number">1</span>;</span><br><span class="line"><span class="keyword">if</span> (lheight - rheight == <span class="number">2</span>) &#123;</span><br><span class="line"><span class="keyword">if</span> (<span class="built_in">returnHeight</span>(T-&gt;lchild-&gt;lchild) &gt;= <span class="built_in">returnHeight</span>(T-&gt;lchild-&gt;rchild))</span><br><span class="line">T = <span class="built_in">SingerotateWihtleft</span>(T);</span><br><span class="line"><span class="keyword">else</span></span><br><span class="line">T = <span class="built_in">DoublerotateWihtleft</span>(T);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span> <span class="keyword">if</span> (rheight - lheight == <span class="number">2</span>) &#123;</span><br><span class="line"><span class="keyword">if</span> (<span class="built_in">returnHeight</span>(T-&gt;rchild-&gt;rchild) &gt;= <span class="built_in">returnHeight</span>(T-&gt;rchild-&gt;lchild))</span><br><span class="line">T = <span class="built_in">SingerotateWihtright</span>(T);</span><br><span class="line"><span class="keyword">else</span></span><br><span class="line">T = <span class="built_in">DoublerotateWihtright</span>(T);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> T;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="树状数组"><a href="#树状数组" class="headerlink" title="树状数组"></a>树状数组</h2><h3 id="树状数组的基本实现"><a href="#树状数组的基本实现" class="headerlink" title="树状数组的基本实现"></a>树状数组的基本实现</h3><p>时间复杂度为O(logN)<br>lowbit(x) &#x3D; x&amp;(-x); （说简单点就是x的二进制数从左往右数第一个1的位数，比如100的lowbit运算结果为3）<br>功能（在O（logN）的时间复杂度下）<br>单点加<br>查询前缀和<br>P3374 【模板】树状数组 1 - 洛谷 |</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">const</span> <span class="type">int</span> MAX = <span class="number">5e5</span> + <span class="number">5</span>;</span><br><span class="line"><span class="type">int</span> a[MAX], c[MAX],n;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">query</span><span class="params">(<span class="type">int</span> x)</span> </span>&#123; <span class="comment">//查询1-x的和</span></span><br><span class="line"><span class="type">int</span> s = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">for</span> (; x; x -= x &amp; (-x)) </span><br><span class="line">s += c[x];</span><br><span class="line"><span class="keyword">return</span> s;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">modify</span><span class="params">(<span class="type">int</span> x, <span class="type">long</span> <span class="type">long</span> k)</span> </span>&#123;<span class="comment">//修改树状数组</span></span><br><span class="line"><span class="keyword">for</span> (; x &lt;= n; x += x &amp; (-x) )</span><br><span class="line">c[x]+=k;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line"><span class="type">int</span>  m; cin &gt;&gt; n &gt;&gt; m;</span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt;= n; i++) &#123;</span><br><span class="line"><span class="type">int</span> num; cin &gt;&gt; num;</span><br><span class="line"><span class="built_in">modify</span>(i, num);</span><br><span class="line">&#125; </span><br><span class="line"><span class="keyword">while</span> (m--) &#123;</span><br><span class="line"><span class="type">int</span> choice,x,y; cin &gt;&gt; choice;</span><br><span class="line"><span class="keyword">if</span> (choice == <span class="number">1</span>) &#123;</span><br><span class="line">cin &gt;&gt; x &gt;&gt; y;</span><br><span class="line"><span class="built_in">modify</span>(x, y);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span> &#123;</span><br><span class="line">cin &gt;&gt; x &gt;&gt; y;</span><br><span class="line">cout &lt;&lt; <span class="built_in">query</span>(y) - <span class="built_in">query</span>(x<span class="number">-1</span>) &lt;&lt; endl; <span class="comment">//计算x---y的和</span></span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>区间加</p><p>对于数组a，区间[l,r]加上k，则对于其差分数组d(对于ai，ai&#x3D;d1到di之和)，dl+&#x3D;k，dr-&#x3D;k;<br>这里就不多赘述了，与上述模板相比，就是将树状数组c的初始值初始化为a的差分数组，然后再修改值的时候，加上一个modify(r+1,-k);<br>P3368 【模板】树状数组 2 - 洛谷 | 计算机科学教育新生态 (luogu.com.cn)</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="type">const</span> <span class="type">int</span> MAX = <span class="number">5e5</span> + <span class="number">5</span>;</span><br><span class="line"><span class="type">int</span>  c[MAX], n;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">query</span><span class="params">(<span class="type">int</span> x)</span> </span>&#123; <span class="comment">//查询1-x的和</span></span><br><span class="line">    <span class="type">int</span> s = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> (; x; x -= x &amp; (-x))</span><br><span class="line">        s += c[x];</span><br><span class="line">    <span class="keyword">return</span> s;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">modify</span><span class="params">(<span class="type">int</span> x, <span class="type">long</span> <span class="type">long</span> k)</span> </span>&#123;<span class="comment">//修改树状数组</span></span><br><span class="line">    <span class="keyword">for</span> (; x &lt;= n; x += x &amp; (-x))</span><br><span class="line">        c[x] += k;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="type">int</span>  m; cin &gt;&gt; n &gt;&gt; m;</span><br><span class="line">    <span class="type">int</span> last = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt;= n; i++) &#123;</span><br><span class="line">        <span class="type">int</span> now; cin &gt;&gt; now;</span><br><span class="line">        <span class="built_in">modify</span>(i, now-last);</span><br><span class="line">        last = now;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">while</span> (m--) &#123;</span><br><span class="line">        <span class="type">int</span> choice, x, y, k ; cin &gt;&gt; choice;</span><br><span class="line">        <span class="keyword">if</span> (choice == <span class="number">1</span>) &#123;</span><br><span class="line">            cin &gt;&gt; x &gt;&gt; y&gt;&gt; k ;</span><br><span class="line">            <span class="built_in">modify</span>(x, k);</span><br><span class="line">            <span class="built_in">modify</span>(y + <span class="number">1</span>, -k);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> &#123;</span><br><span class="line">            cin &gt;&gt; x;</span><br><span class="line">            cout &lt;&lt; <span class="built_in">query</span>(x) &lt;&lt; endl;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="一维树状数组基本应用"><a href="#一维树状数组基本应用" class="headerlink" title="一维树状数组基本应用"></a>一维树状数组基本应用</h3><p>P1908 逆序对<br>对pair数组的first进行排序，这里的first表示值，second表示下标。后面在创建一个数组A，从pair数组的第一个值开始，使得A[pair[i].second]&#x3D;i，最后可以使得数组A和原数组，数据大小是相反对应的，比如在下标3处，原数组存储的是最大值，A数组存储的则是最小值1。<br>最后将A数组，从第一个数开始，ans+&#x3D;query(A[i]),再modify(A[i],1)，这一操作，表示ans+&#x3D;（以i为分界点，满足j&lt; i,且Aj&lt; Ai的元素个数），直到最后一个元素，最后ans就是最后的结果（因为答案要求的是j&lt; i,且Aj&gt;Ai，是相反的，正好A数组和原数组数据大小是相反对应的，所以最后的结果是正确的）</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="type">const</span> <span class="type">int</span> MAX = <span class="number">5e5</span> + <span class="number">5</span>;</span><br><span class="line"><span class="keyword">typedef</span> <span class="type">long</span> <span class="type">long</span> ll;</span><br><span class="line"><span class="keyword">typedef</span> pair&lt;ll, ll&gt; Pll;</span><br><span class="line"><span class="type">int</span> n, a[MAX], c[MAX];</span><br><span class="line">Pll temp[MAX];</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">cmp</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">bool</span> <span class="title">operator</span><span class="params">()</span><span class="params">(<span class="type">const</span> Pll&amp; p1, <span class="type">const</span> Pll&amp; p2)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (p1.first &gt; p2.first)</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> (p1.first == p2.first &amp;&amp; p1.second &gt; p2.second)</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">            <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function">ll <span class="title">query</span><span class="params">(<span class="type">int</span> x)</span> </span>&#123;</span><br><span class="line">    ll s = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> (; x; x -= x &amp; (-x))</span><br><span class="line">        s += c[x];</span><br><span class="line">    <span class="keyword">return</span> s;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">modify</span><span class="params">(<span class="type">int</span> x, <span class="type">int</span> d)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">for</span> (; x &lt;= n; x += x &amp; (-x))</span><br><span class="line">        c[x] += d;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    cin &gt;&gt; n;</span><br><span class="line">    ll ans = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt;= n; i++) &#123;</span><br><span class="line">        cin &gt;&gt; temp[i].first;</span><br><span class="line">        temp[i].second = i;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">sort</span>(temp + <span class="number">1</span>, temp + <span class="number">1</span> + n, <span class="built_in">cmp</span>());</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt;= n; i++)</span><br><span class="line">        a[temp[i].second] = i;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt;= n; i++) &#123;</span><br><span class="line">        ans += <span class="built_in">query</span>(a[i]);</span><br><span class="line">        <span class="built_in">modify</span>(a[i], <span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    cout &lt;&lt; ans &lt;&lt; endl;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="高维树状数组"><a href="#高维树状数组" class="headerlink" title="高维树状数组"></a>高维树状数组</h3><p>这里以二维树状数组为例：<br>在一维树状数组中，tree[x]（树状数组中的那个“数组”）记录的是右端点为x、长度为lowbit(x)的区间的区间和。<br>那么在二维树状数组中，可以类似地定义tree[x][y]记录的是右下角为(x, y)，高为lowbit(x), 宽为 lowbit(y)的区间的区间和。<br>时间复杂度为O（log2N）<br>基本实现和一位数状数组相差不多，拓展到k维树状数组就是嵌套k维数组，k 层for循环。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="type">long</span> <span class="type">long</span> ll;</span><br><span class="line"><span class="type">const</span> <span class="type">int</span> MAX = <span class="number">5</span> - <span class="number">1</span>;</span><br><span class="line">ll c[MAX][MAX], n;</span><br><span class="line"><span class="function">ll <span class="title">query</span><span class="params">(<span class="type">int</span> x)</span> </span>&#123;</span><br><span class="line">    ll s = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> p=x; p; p -= p &amp; (-p))</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> q=x;q;q-=q&amp;(-q))    </span><br><span class="line">            s += c[p][q];</span><br><span class="line">    <span class="keyword">return</span> s;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">modify</span><span class="params">(<span class="type">int</span> x, ll d)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> p = x; p &lt;= n; p += p &amp; (-p))</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> q = x; q &lt;= n; q += q &amp; (-q))</span><br><span class="line">            c[p][q] += d;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="线段树"><a href="#线段树" class="headerlink" title="线段树"></a>线段树</h2><h3 id="区间查询最小值"><a href="#区间查询最小值" class="headerlink" title="区间查询最小值"></a>区间查询最小值</h3><p>单点修改<br>区间查询(树状数组仅可以进行前缀和查询)<br>时间复杂度O(logN)，可采用数组实现。<br>线段树可以进行多种查询，以下的板子为查询区间内的最小值。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="type">const</span> <span class="type">int</span> MAX = <span class="number">2e5</span> + <span class="number">5</span>;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> a[MAX];</span><br><span class="line"></span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">Node</span> &#123;</span><br><span class="line"><span class="type">int</span> minv;</span><br><span class="line">&#125;tree[<span class="number">4</span>*MAX];</span><br><span class="line"></span><br><span class="line"><span class="comment">//更新数据</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">update</span><span class="params">(<span class="type">int</span> id)</span> </span>&#123;</span><br><span class="line">tree[id].minv = <span class="built_in">min</span>(tree[id * <span class="number">2</span>].minv, tree[id * <span class="number">2</span> + <span class="number">1</span>].minv);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//建树</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">build</span><span class="params">(<span class="type">int</span> id, <span class="type">int</span> l, <span class="type">int</span> r)</span> </span>&#123;</span><br><span class="line"><span class="keyword">if</span> (l == r) &#123;</span><br><span class="line">tree[id].minv = a[l];</span><br><span class="line"><span class="keyword">return</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span> &#123;</span><br><span class="line"><span class="type">int</span> mid = (l + r) / <span class="number">2</span>;</span><br><span class="line"><span class="built_in">build</span>(id * <span class="number">2</span>, l, mid);</span><br><span class="line"><span class="built_in">build</span>(id * <span class="number">2</span>+<span class="number">1</span>, mid+<span class="number">1</span>, r);</span><br><span class="line"><span class="built_in">update</span>(id);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//节点为id，将区间[l,r]的数据，a[pos]修改为val</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">change</span><span class="params">(<span class="type">int</span> id, <span class="type">int</span> l, <span class="type">int</span> r, <span class="type">int</span> pos, <span class="type">int</span> val)</span> </span>&#123;</span><br><span class="line"><span class="keyword">if</span> (l == r) &#123;</span><br><span class="line">tree[id].minv = val;</span><br><span class="line"><span class="keyword">return</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span> &#123;</span><br><span class="line"><span class="type">int</span> mid = (l + r) / <span class="number">2</span>;</span><br><span class="line"><span class="keyword">if</span> (pos &lt;= mid)</span><br><span class="line"><span class="built_in">change</span>(id * <span class="number">2</span>, l, mid, pos, val);</span><br><span class="line"><span class="keyword">else</span> </span><br><span class="line"><span class="built_in">change</span>(id * <span class="number">2</span> + <span class="number">1</span>, mid + <span class="number">1</span>, r, pos, val);</span><br><span class="line"><span class="built_in">update</span>(id);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//[dl,dr]表示要查询的区间</span></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">query</span><span class="params">(<span class="type">int</span> id, <span class="type">int</span> l, <span class="type">int</span> r, <span class="type">int</span> dl, <span class="type">int</span> dr)</span> </span>&#123;</span><br><span class="line"><span class="keyword">if</span> (l == dl &amp;&amp; r == dr)</span><br><span class="line"><span class="keyword">return</span> tree[id].minv;</span><br><span class="line"><span class="type">int</span> mid = (l + r) / <span class="number">2</span>;</span><br><span class="line"><span class="comment">//[l,mid],[mid+1,r];</span></span><br><span class="line"><span class="keyword">if</span> (dr &lt;= mid)</span><br><span class="line"><span class="keyword">return</span> <span class="built_in">query</span>(<span class="number">2</span> * id, l, mid, dl, dr);</span><br><span class="line"><span class="keyword">else</span> <span class="keyword">if</span> (dl &gt; mid)</span><br><span class="line"><span class="keyword">return</span> <span class="built_in">query</span>(<span class="number">2</span> * id + <span class="number">1</span>, mid + <span class="number">1</span>, r, dl, dr);</span><br><span class="line"><span class="keyword">else</span> &#123;</span><br><span class="line"><span class="comment">// dr&gt; mid, dl&lt;=mid</span></span><br><span class="line"><span class="comment">//[ql,mid],[mid+1,dr];</span></span><br><span class="line"><span class="keyword">return</span> <span class="built_in">min</span>(<span class="built_in">query</span>(id * <span class="number">2</span>, l, mid, dl, mid), <span class="built_in">query</span>(id * <span class="number">2</span> + <span class="number">1</span>, mid + <span class="number">1</span>, r, mid+<span class="number">1</span>, dr));</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line"><span class="comment">// 3 2 4 6 8 9 5 3</span></span><br><span class="line"><span class="type">int</span> n; cin &gt;&gt; n;</span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt;= n; i++)</span><br><span class="line">cin &gt;&gt; a[i];</span><br><span class="line"><span class="built_in">build</span>(<span class="number">1</span>, <span class="number">1</span>, n);</span><br><span class="line"><span class="built_in">change</span>(<span class="number">1</span>, <span class="number">1</span>, n, <span class="number">2</span>, <span class="number">99</span>);</span><br><span class="line">cout &lt;&lt; <span class="built_in">query</span>(<span class="number">1</span>, <span class="number">1</span>, n, <span class="number">2</span>, n - <span class="number">1</span>) &lt;&lt; endl;</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="区间查询最大字段和"><a href="#区间查询最大字段和" class="headerlink" title="区间查询最大字段和"></a>区间查询最大字段和</h3><p>高度封装板子，wls真是永远的神</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="type">const</span> <span class="type">int</span> MAX = <span class="number">2e5</span> + <span class="number">5</span>;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> a[MAX];</span><br><span class="line"></span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">info</span> &#123;</span><br><span class="line"><span class="type">int</span> mPrefix,mSuffix,mSum,s;</span><br><span class="line"><span class="built_in">info</span>()&#123;&#125;</span><br><span class="line"><span class="built_in">info</span>(<span class="type">int</span> a):<span class="built_in">mPrefix</span>(a),<span class="built_in">mSuffix</span>(a),<span class="built_in">mSum</span>(a),<span class="built_in">s</span>(a)&#123;&#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">info <span class="keyword">operator</span>+(<span class="type">const</span> info&amp; left, <span class="type">const</span> info&amp; right) &#123;</span><br><span class="line">info a;</span><br><span class="line">a.mSum = <span class="built_in">max</span>(&#123; left.mSum, right.mSum, left.mSuffix + right.mPrefix &#125;);</span><br><span class="line">a.mPrefix = <span class="built_in">max</span>(left.mPrefix, left.s + right.mPrefix);</span><br><span class="line">a.mSuffix = <span class="built_in">max</span>(right.mSuffix, right.s + left.mSuffix);</span><br><span class="line">a.s = left.s + right.s;</span><br><span class="line"><span class="keyword">return</span> a;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">Node</span> &#123;</span><br><span class="line">info val;</span><br><span class="line">&#125;tree[<span class="number">4</span> * MAX];</span><br><span class="line"></span><br><span class="line"><span class="comment">//更新数据</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">update</span><span class="params">(<span class="type">int</span> id)</span> </span>&#123;</span><br><span class="line">tree[id].val = tree[id * <span class="number">2</span>].val + tree[id * <span class="number">2</span> + <span class="number">1</span>].val;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//建树</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">build</span><span class="params">(<span class="type">int</span> id, <span class="type">int</span> l, <span class="type">int</span> r)</span> </span>&#123;</span><br><span class="line"><span class="keyword">if</span> (l == r) &#123;</span><br><span class="line">tree[id].val = <span class="built_in">info</span>(a[l]);</span><br><span class="line"><span class="keyword">return</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span> &#123;</span><br><span class="line"><span class="type">int</span> mid = (l + r) / <span class="number">2</span>;</span><br><span class="line"><span class="built_in">build</span>(id * <span class="number">2</span>, l, mid);</span><br><span class="line"><span class="built_in">build</span>(id * <span class="number">2</span>+<span class="number">1</span>, mid+<span class="number">1</span>, r);</span><br><span class="line"><span class="built_in">update</span>(id);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//节点为id，将区间[l,r]的数据，a[pos]修改为val</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">change</span><span class="params">(<span class="type">int</span> id, <span class="type">int</span> l, <span class="type">int</span> r, <span class="type">int</span> pos, <span class="type">int</span> val)</span> </span>&#123;</span><br><span class="line"><span class="keyword">if</span> (l == r) &#123;</span><br><span class="line">tree[id].val = <span class="built_in">info</span>(val);</span><br><span class="line"><span class="keyword">return</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span> &#123;</span><br><span class="line"><span class="type">int</span> mid = (l + r) / <span class="number">2</span>;</span><br><span class="line"><span class="keyword">if</span> (pos &lt;= mid)</span><br><span class="line"><span class="built_in">change</span>(id * <span class="number">2</span>, l, mid, pos, val);</span><br><span class="line"><span class="keyword">else</span> </span><br><span class="line"><span class="built_in">change</span>(id * <span class="number">2</span> + <span class="number">1</span>, mid + <span class="number">1</span>, r, pos, val);</span><br><span class="line"><span class="built_in">update</span>(id);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//[dl,dr]表示要查询的区间</span></span><br><span class="line"><span class="function">info <span class="title">query</span><span class="params">(<span class="type">int</span> id, <span class="type">int</span> l, <span class="type">int</span> r, <span class="type">int</span> dl, <span class="type">int</span> dr)</span> </span>&#123;</span><br><span class="line"><span class="keyword">if</span> (l == dl &amp;&amp; r == dr)</span><br><span class="line"><span class="keyword">return</span> tree[id].val;</span><br><span class="line"><span class="type">int</span> mid = (l + r) / <span class="number">2</span>;</span><br><span class="line"><span class="comment">//[l,mid],[mid+1,r];</span></span><br><span class="line"><span class="keyword">if</span> (dr &lt;= mid)</span><br><span class="line"><span class="keyword">return</span> <span class="built_in">query</span>(<span class="number">2</span> * id, l, mid, dl, dr);</span><br><span class="line"><span class="keyword">else</span> <span class="keyword">if</span> (dl &gt; mid)</span><br><span class="line"><span class="keyword">return</span> <span class="built_in">query</span>(<span class="number">2</span> * id + <span class="number">1</span>, mid + <span class="number">1</span>, r, dl, dr);</span><br><span class="line"><span class="keyword">else</span> &#123;</span><br><span class="line"><span class="comment">// dr&gt; mid, dl&lt;=mid</span></span><br><span class="line"><span class="comment">//[ql,mid],[mid+1,dr];</span></span><br><span class="line"><span class="keyword">return</span> <span class="built_in">query</span>(id * <span class="number">2</span>, l, mid, dl, mid)+<span class="built_in">query</span>(id * <span class="number">2</span> + <span class="number">1</span>, mid + <span class="number">1</span>, r, mid+<span class="number">1</span>, dr);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> 5 5</span></span><br><span class="line"><span class="comment">-1 2 -3 4 -5</span></span><br><span class="line"><span class="comment">2 4 5</span></span><br><span class="line"><span class="comment">1 2 4</span></span><br><span class="line"><span class="comment">2 1 5</span></span><br><span class="line"><span class="comment">1 4 -1</span></span><br><span class="line"><span class="comment">2 2 4</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line">std::ios::<span class="built_in">sync_with_stdio</span>(<span class="literal">false</span>); </span><br><span class="line">cin.<span class="built_in">tie</span>(<span class="number">0</span>); cout.<span class="built_in">tie</span>(<span class="number">0</span>);</span><br><span class="line"><span class="type">int</span> n,q; cin &gt;&gt; n&gt;&gt;q;</span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt;= n; i++)</span><br><span class="line">cin &gt;&gt; a[i];</span><br><span class="line"><span class="built_in">build</span>(<span class="number">1</span>, <span class="number">1</span>, n);</span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; q; i++) &#123;</span><br><span class="line"><span class="type">int</span> ty; cin &gt;&gt; ty;</span><br><span class="line"><span class="keyword">if</span> (ty == <span class="number">1</span>) &#123;</span><br><span class="line"><span class="type">int</span> x, d; cin &gt;&gt; x &gt;&gt; d;</span><br><span class="line"><span class="built_in">change</span>(<span class="number">1</span>, <span class="number">1</span>, n, x, d);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span> &#123;</span><br><span class="line"><span class="type">int</span> l, r; cin &gt;&gt; l &gt;&gt; r;</span><br><span class="line"><span class="keyword">auto</span> ans = <span class="built_in">query</span>(<span class="number">1</span>, <span class="number">1</span>, n, l, r);</span><br><span class="line">cout &lt;&lt; ans.mSum &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="线段树打标记"><a href="#线段树打标记" class="headerlink" title="线段树打标记"></a>线段树打标记</h3><p>用于线段树区间修改<br>打标记：<br><strong>懒标记</strong>:懒标记的作用是记录每次、每个节点要更新的值  <br><strong>标记永久化</strong>:将标记永久记录（ 不建议）<br><strong>标记下传</strong>:因为线段树分成了一个一个区间，所以可以将某个节点的懒标记，下传给他的子结点，并且将当前节点的懒标记置为0。<br><strong>标记合并</strong>：将之前存在的相同节点的多个标记合并<br>更新信息</p><h4 id="查询区间最大值"><a href="#查询区间最大值" class="headerlink" title="查询区间最大值"></a>查询区间最大值</h4><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="keyword">typedef</span> <span class="type">long</span> <span class="type">long</span> ll;</span><br><span class="line"><span class="type">const</span> <span class="type">int</span> MAX = <span class="number">2e5</span> + <span class="number">5</span>;</span><br><span class="line"></span><br><span class="line">ll a[MAX];</span><br><span class="line"></span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">info</span> &#123;</span><br><span class="line">    ll maxv;</span><br><span class="line">    <span class="built_in">info</span>() &#123;&#125;</span><br><span class="line">    <span class="built_in">info</span>(ll x):<span class="built_in">maxv</span>(x) &#123;&#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">tag</span> &#123;</span><br><span class="line">    ll add;</span><br><span class="line">    <span class="built_in">tag</span>()&#123;&#125;</span><br><span class="line">    <span class="built_in">tag</span>(ll x) :<span class="built_in">add</span>(x) &#123;&#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">info <span class="keyword">operator</span>+(<span class="type">const</span> info&amp; left, <span class="type">const</span> info&amp; right) &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">info</span>(<span class="built_in">max</span>(left.maxv, right.maxv));</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">info <span class="keyword">operator</span>+(<span class="type">const</span> info&amp; val, <span class="type">const</span> tag&amp; t) &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">info</span>(val.maxv+t.add);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">tag <span class="keyword">operator</span>+(<span class="type">const</span> tag&amp; t1, <span class="type">const</span> tag&amp; t2) &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">tag</span>(t1.add+t2.add);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">Node</span> &#123;</span><br><span class="line">    tag t;</span><br><span class="line">    info val;</span><br><span class="line">&#125;tree[<span class="number">4</span> * MAX];</span><br><span class="line"></span><br><span class="line"><span class="comment">//更新数据</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">update</span><span class="params">(<span class="type">int</span> id)</span> </span>&#123;</span><br><span class="line">    tree[id].val = tree[id * <span class="number">2</span>].val + tree[id * <span class="number">2</span> + <span class="number">1</span>].val;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//设置懒标记</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">settag</span><span class="params">(<span class="type">int</span> id,tag t)</span> </span>&#123;</span><br><span class="line">    tree[id].val = tree[id].val + t;</span><br><span class="line">    tree[id].t = tree[id].t + t;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//下传操作</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">pushDown</span><span class="params">(<span class="type">int</span> id)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (tree[id].t.add != <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="built_in">settag</span>(id * <span class="number">2</span>, tree[id].t);</span><br><span class="line">        <span class="built_in">settag</span>(id * <span class="number">2</span>+<span class="number">1</span>, tree[id].t);</span><br><span class="line">        tree[id].t = <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//建树</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">build</span><span class="params">(<span class="type">int</span> id, <span class="type">int</span> l, <span class="type">int</span> r)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (l == r) &#123;</span><br><span class="line">        tree[id].val = <span class="built_in">info</span>(a[l]);</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="type">int</span> mid = (l + r) / <span class="number">2</span>;</span><br><span class="line">        <span class="built_in">build</span>(id * <span class="number">2</span>, l, mid);</span><br><span class="line">        <span class="built_in">build</span>(id * <span class="number">2</span> + <span class="number">1</span>, mid + <span class="number">1</span>, r);</span><br><span class="line">        <span class="built_in">update</span>(id);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//节点为id，将区间[l,r]的数据，a[pos]修改为val</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">modify</span><span class="params">(<span class="type">int</span> id, <span class="type">int</span> l, <span class="type">int</span> r, <span class="type">int</span> dl,<span class="type">int</span> dr,tag t)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (l == dl &amp;&amp; r == dr) &#123;</span><br><span class="line">        <span class="built_in">settag</span>(id, t);</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="type">int</span> mid = (l + r) / <span class="number">2</span>;</span><br><span class="line">    <span class="comment">//[l,mid],[mid+1,r];</span></span><br><span class="line">    <span class="built_in">pushDown</span>(id);</span><br><span class="line">    <span class="keyword">if</span> (dr &lt;= mid)</span><br><span class="line">      <span class="built_in">modify</span>(<span class="number">2</span> * id, l, mid, dl, dr,t);</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span> (dl &gt; mid)</span><br><span class="line">      <span class="built_in">modify</span>(<span class="number">2</span> * id + <span class="number">1</span>, mid + <span class="number">1</span>, r, dl, dr,t);</span><br><span class="line">    <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="comment">// dr&gt; mid, dl&lt;=mid</span></span><br><span class="line">        <span class="comment">//[ql,mid],[mid+1,dr];</span></span><br><span class="line">        <span class="built_in">modify</span>(id * <span class="number">2</span>, l, mid, dl, mid,t);</span><br><span class="line">        <span class="built_in">modify</span>(id * <span class="number">2</span> + <span class="number">1</span>, mid + <span class="number">1</span>, r, mid + <span class="number">1</span>, dr,t);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">update</span>(id);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//[dl,dr]表示要查询的区间</span></span><br><span class="line"><span class="function">info <span class="title">query</span><span class="params">(<span class="type">int</span> id, <span class="type">int</span> l, <span class="type">int</span> r, <span class="type">int</span> dl, <span class="type">int</span> dr)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (l == dl &amp;&amp; r == dr)</span><br><span class="line">        <span class="keyword">return</span> tree[id].val;</span><br><span class="line">    <span class="type">int</span> mid = (l + r) / <span class="number">2</span>;</span><br><span class="line">    <span class="comment">//[l,mid],[mid+1,r];</span></span><br><span class="line">    <span class="built_in">pushDown</span>(id);</span><br><span class="line">    <span class="keyword">if</span> (dr &lt;= mid)</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">query</span>(<span class="number">2</span> * id, l, mid, dl, dr);</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span> (dl &gt; mid)</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">query</span>(<span class="number">2</span> * id + <span class="number">1</span>, mid + <span class="number">1</span>, r, dl, dr);</span><br><span class="line">    <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="comment">// dr&gt; mid, dl&lt;=mid</span></span><br><span class="line">        <span class="comment">//[ql,mid],[mid+1,dr];</span></span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">query</span>(id * <span class="number">2</span>, l, mid, dl, mid) + <span class="built_in">query</span>(id * <span class="number">2</span> + <span class="number">1</span>, mid + <span class="number">1</span>, r, mid + <span class="number">1</span>, dr);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="comment">/*</span></span><br><span class="line"><span class="comment">     5 5</span></span><br><span class="line"><span class="comment">    1 2 3 4 5 </span></span><br><span class="line"><span class="comment">    2 4 5</span></span><br><span class="line"><span class="comment">    1 1 5 1 </span></span><br><span class="line"><span class="comment">    2 1 4</span></span><br><span class="line"><span class="comment">    1 2 3 10</span></span><br><span class="line"><span class="comment">    2 2 4</span></span><br><span class="line"><span class="comment">    */</span></span><br><span class="line">    std::ios::<span class="built_in">sync_with_stdio</span>(<span class="literal">false</span>);</span><br><span class="line">    cin.<span class="built_in">tie</span>(<span class="number">0</span>); cout.<span class="built_in">tie</span>(<span class="number">0</span>);</span><br><span class="line">    <span class="type">int</span> n, q; cin &gt;&gt; n &gt;&gt; q;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt;= n; i++)</span><br><span class="line">        cin &gt;&gt; a[i];</span><br><span class="line">    <span class="built_in">build</span>(<span class="number">1</span>, <span class="number">1</span>, n);</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; q; i++) &#123;</span><br><span class="line">        <span class="type">int</span> ty; cin &gt;&gt; ty;</span><br><span class="line">        <span class="keyword">if</span> (ty == <span class="number">1</span>) &#123;</span><br><span class="line">            <span class="type">int</span> l,r, d; cin &gt;&gt; l&gt;&gt;r &gt;&gt; d;</span><br><span class="line">           <span class="built_in">modify</span>(<span class="number">1</span>, <span class="number">1</span>, n, l, r,<span class="built_in">tag</span>(d));</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="type">int</span> l, r; cin &gt;&gt; l &gt;&gt; r;</span><br><span class="line">            <span class="keyword">auto</span> ans = <span class="built_in">query</span>(<span class="number">1</span>, <span class="number">1</span>, n, l, r);</span><br><span class="line">            cout &lt;&lt; ans.maxv &lt;&lt; endl;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="查询区间和"><a href="#查询区间和" class="headerlink" title="查询区间和"></a>查询区间和</h4><p>可以进行区间乘和加某个数的操作</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="keyword">typedef</span> <span class="type">long</span> <span class="type">long</span> ll;</span><br><span class="line"><span class="type">const</span> <span class="type">int</span> MAX = <span class="number">1e5</span> + <span class="number">5</span>;</span><br><span class="line"></span><br><span class="line">ll a[MAX],mod;</span><br><span class="line"></span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">Node</span> &#123;</span><br><span class="line">    ll val = <span class="number">0</span>, size = <span class="number">0</span>;</span><br><span class="line">    ll mul = <span class="number">1</span>, add = <span class="number">0</span>;</span><br><span class="line">&#125;tree[<span class="number">4</span> * MAX];</span><br><span class="line"></span><br><span class="line"><span class="comment">//更新数据</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">update</span><span class="params">(<span class="type">int</span> id)</span> </span>&#123;</span><br><span class="line">    tree[id].val = (tree[id * <span class="number">2</span>].val + tree[id * <span class="number">2</span> + <span class="number">1</span>].val)%mod;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//设置懒标记</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">settag</span><span class="params">(<span class="type">int</span> id,ll add,ll mul)</span> </span>&#123;</span><br><span class="line">    tree[id].mul = (tree[id].mul * mul)%mod;</span><br><span class="line">    tree[id].add = (tree[id].add*mul+add)%mod;</span><br><span class="line">    tree[id].val = (tree[id].val*mul+tree[id].size*add)%mod ;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//下传操作</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">pushDown</span><span class="params">(<span class="type">int</span> id)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (tree[id].add != <span class="number">0</span> || tree[id].mul != <span class="number">1</span>) &#123;</span><br><span class="line">        <span class="built_in">settag</span>(id * <span class="number">2</span>, tree[id].add,tree[id].mul);</span><br><span class="line">        <span class="built_in">settag</span>(id * <span class="number">2</span>+<span class="number">1</span>, tree[id].add,tree[id].mul);</span><br><span class="line">        tree[id].add = <span class="number">0</span>;</span><br><span class="line">        tree[id].mul = <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//建树</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">build</span><span class="params">(<span class="type">int</span> id, <span class="type">int</span> l, <span class="type">int</span> r)</span> </span>&#123;</span><br><span class="line">    tree[id].size = r - l + <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">if</span> (l == r) &#123;</span><br><span class="line">        tree[id].val = a[l];</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="type">int</span> mid = (l + r) / <span class="number">2</span>;</span><br><span class="line">        <span class="built_in">build</span>(id * <span class="number">2</span>, l, mid);</span><br><span class="line">        <span class="built_in">build</span>(id * <span class="number">2</span> + <span class="number">1</span>, mid + <span class="number">1</span>, r);</span><br><span class="line">        <span class="built_in">update</span>(id);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//节点为id，将区间[l,r]的数据，增加t</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">modify</span><span class="params">(<span class="type">int</span> id, <span class="type">int</span> l, <span class="type">int</span> r, <span class="type">int</span> dl,<span class="type">int</span> dr,ll add,ll mul)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (dl == l &amp;&amp; r == dr) &#123;</span><br><span class="line">        <span class="built_in">settag</span>(id, add,mul);</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">pushDown</span>(id);</span><br><span class="line">    <span class="type">int</span> mid = (l + r) / <span class="number">2</span>;</span><br><span class="line">    <span class="comment">//[l,mid],[mid+1,r];</span></span><br><span class="line">    <span class="keyword">if</span> (dr &lt;= mid)</span><br><span class="line">       <span class="built_in">modify</span>(<span class="number">2</span> * id, l, mid, dl, dr,add,mul);</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span> (dl &gt; mid)</span><br><span class="line">       <span class="built_in">modify</span>(<span class="number">2</span> * id + <span class="number">1</span>, mid + <span class="number">1</span>, r, dl, dr,add,mul);</span><br><span class="line">    <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="comment">// dr&gt; mid, dl&lt;=mid</span></span><br><span class="line">        <span class="comment">//[ql,mid],[mid+1,dr];</span></span><br><span class="line">        <span class="built_in">modify</span>(id * <span class="number">2</span>, l, mid, dl, mid,add,mul);</span><br><span class="line">        <span class="built_in">modify</span>(id * <span class="number">2</span> + <span class="number">1</span>, mid + <span class="number">1</span>, r, mid + <span class="number">1</span>, dr, add, mul);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">update</span>(id);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//[dl,dr]表示要查询的区间</span></span><br><span class="line"><span class="function">ll <span class="title">query</span><span class="params">(<span class="type">int</span> id, <span class="type">int</span> l, <span class="type">int</span> r, <span class="type">int</span> dl, <span class="type">int</span> dr)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (dl == l &amp;&amp; r == dr)</span><br><span class="line">        <span class="keyword">return</span> tree[id].val;</span><br><span class="line">    <span class="built_in">pushDown</span>(id);</span><br><span class="line">    ll mid = (l + r) / <span class="number">2</span>;</span><br><span class="line">    <span class="comment">//[l,mid],[mid+1,r];</span></span><br><span class="line">    <span class="keyword">if</span> (dr &lt;=mid)                               </span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">query</span>(<span class="number">2</span> * id, l, mid, dl, dr);</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span> (dl &gt; mid)</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">query</span>(<span class="number">2</span> * id + <span class="number">1</span>, mid + <span class="number">1</span>, r, dl, dr);</span><br><span class="line">    <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="comment">// dr&gt; mid, dl&lt;=mid</span></span><br><span class="line">        <span class="comment">//[ql,mid],[mid+1,dr];</span></span><br><span class="line">        <span class="built_in">return</span> (<span class="built_in">query</span>(id * <span class="number">2</span>, l, mid, dl, mid) + <span class="built_in">query</span>(id * <span class="number">2</span> + <span class="number">1</span>, mid + <span class="number">1</span>, r, mid + <span class="number">1</span>, dr))%mod;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    std::ios::<span class="built_in">sync_with_stdio</span>(<span class="literal">false</span>);</span><br><span class="line">    cin.<span class="built_in">tie</span>(<span class="number">0</span>); cout.<span class="built_in">tie</span>(<span class="number">0</span>);</span><br><span class="line">    <span class="type">int</span> n, q; cin &gt;&gt; n &gt;&gt; q&gt;&gt;mod;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt;= n; i++)</span><br><span class="line">        cin &gt;&gt; a[i];</span><br><span class="line">    <span class="built_in">build</span>(<span class="number">1</span>, <span class="number">1</span>, n);</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; q; i++) &#123;</span><br><span class="line">        <span class="type">int</span> ty; cin &gt;&gt; ty;</span><br><span class="line">        <span class="keyword">if</span> (ty == <span class="number">1</span>) &#123;</span><br><span class="line">            <span class="type">int</span> l,r, k; cin &gt;&gt; l &gt;&gt; r &gt;&gt; k;</span><br><span class="line">            <span class="built_in">modify</span>(<span class="number">1</span>, <span class="number">1</span>, n, l, r, <span class="number">0</span>, k);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span>(ty==<span class="number">2</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="type">int</span> l, r, d; cin &gt;&gt; l &gt;&gt; r &gt;&gt; d;</span><br><span class="line">            <span class="built_in">modify</span>(<span class="number">1</span>, <span class="number">1</span>, n, l, r, d, <span class="number">1</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="type">int</span> l, r; cin &gt;&gt; l &gt;&gt; r;</span><br><span class="line">            <span class="keyword">auto</span> ans = <span class="built_in">query</span>(<span class="number">1</span>, <span class="number">1</span>, n, l, r);</span><br><span class="line">            cout &lt;&lt; ans &lt;&lt; endl;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="优先队列（堆）"><a href="#优先队列（堆）" class="headerlink" title="优先队列（堆）"></a>优先队列（堆）</h2><h3 id="初始化"><a href="#初始化" class="headerlink" title="初始化"></a>初始化</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">struct</span> <span class="title class_">heapStruct</span> &#123;</span><br><span class="line">    <span class="type">int</span> Capacity;<span class="comment">//规模</span></span><br><span class="line">    <span class="type">int</span> Size;<span class="comment">//数据数量</span></span><br><span class="line">    <span class="type">int</span> *data;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function">heapStruct* <span class="title">Init</span><span class="params">(<span class="type">int</span> MaxData)</span> </span>&#123;</span><br><span class="line">    heapStruct* H;</span><br><span class="line">    H = <span class="keyword">new</span> heapStruct;</span><br><span class="line">    <span class="keyword">if</span> (H == <span class="literal">NULL</span>) <span class="built_in">exit</span>(<span class="number">1</span>);</span><br><span class="line">    H-&gt;data = <span class="keyword">new</span> <span class="type">int</span>[(MaxData + <span class="number">1</span>)];</span><br><span class="line">    <span class="keyword">if</span> (H-&gt;data == <span class="literal">NULL</span>) <span class="built_in">exit</span>(<span class="number">1</span>);</span><br><span class="line">    H-&gt;Capacity = MaxData;</span><br><span class="line">    H-&gt;Size = <span class="number">0</span>;</span><br><span class="line">    H-&gt;data[<span class="number">0</span>] = INT_MIN;</span><br><span class="line">    <span class="keyword">return</span> H;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="插入"><a href="#插入" class="headerlink" title="插入"></a>插入</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">insert</span><span class="params">(<span class="type">int</span> x, heapStruct* H)</span> </span>&#123;<span class="comment">//</span></span><br><span class="line">    <span class="type">int</span> i;</span><br><span class="line">    <span class="keyword">for</span> (i = ++H-&gt;Size; H-&gt;data[i / <span class="number">2</span>] &gt; x; i /= <span class="number">2</span>)<span class="comment">//上滤操作，直到找到正确位置</span></span><br><span class="line">        H-&gt;data[i] = H-&gt;data[i / <span class="number">2</span>];</span><br><span class="line">    H-&gt;data[i] = x;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="删除最小元"><a href="#删除最小元" class="headerlink" title="删除最小元"></a>删除最小元</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">int</span> <span class="title">DeleteMin</span><span class="params">(heapStruct* H)</span> </span>&#123;</span><br><span class="line">    <span class="type">int</span> i, child;</span><br><span class="line">    <span class="type">int</span> MinData, LastData;</span><br><span class="line">    MinData = H-&gt;data[<span class="number">1</span>];</span><br><span class="line">    LastData = H-&gt;data[H-&gt;Size--];</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i * <span class="number">2</span> &lt;= H-&gt;Size; i = child) &#123;<span class="comment">//下虑操作</span></span><br><span class="line">        child = i * <span class="number">2</span>;</span><br><span class="line">        <span class="keyword">if</span> (child != H-&gt;Size &amp;&amp; H-&gt;data[child + <span class="number">1</span>] &lt; H-&gt;data[child])  child++;</span><br><span class="line">        <span class="keyword">if</span> (LastData &gt; H-&gt;data[child]) H-&gt;data[i] = H-&gt;data[child];</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    H-&gt;data[i] = LastData;</span><br><span class="line">    <span class="keyword">return</span> MinData;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="哈曼夫树"><a href="#哈曼夫树" class="headerlink" title="哈曼夫树"></a>哈曼夫树</h2><p>哈夫曼树指的就是，WPL最小的二叉树，最优二叉树。通过构建哈夫曼树，我们可以很容易的求出最小WPL。我们可以采用优先队列（堆）的方式，求出最小WPL。</p><p>P1090 [NOIP2004 提高组] 合并果子 &#x2F; [USACO06NOV] Fence Repair G - 洛谷 </p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iomanip&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;queue&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">priority_queue&lt;<span class="type">int</span>,vector&lt;<span class="type">int</span>&gt;,greater&lt;<span class="type">int</span>&gt;&gt; h;</span><br><span class="line"><span class="type">int</span> n,res=<span class="number">0</span>; cin &gt;&gt; n;</span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; n; i++)</span><br><span class="line">&#123;</span><br><span class="line"><span class="type">int</span> num;</span><br><span class="line">cin &gt;&gt; num;</span><br><span class="line">h.<span class="built_in">push</span>(num);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">while</span> (h.<span class="built_in">size</span>()&gt;<span class="number">1</span>)</span><br><span class="line">&#123;</span><br><span class="line"><span class="type">int</span> sum = <span class="number">0</span>;</span><br><span class="line">sum += h.<span class="built_in">top</span>(); h.<span class="built_in">pop</span>();</span><br><span class="line">sum += h.<span class="built_in">top</span>(); h.<span class="built_in">pop</span>();</span><br><span class="line">h.<span class="built_in">push</span>(sum);</span><br><span class="line">res += sum;</span><br><span class="line">&#125;</span><br><span class="line">cout &lt;&lt; res;</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="并查集"><a href="#并查集" class="headerlink" title="并查集"></a>并查集</h2><p>处理不相交可合并的集合关系的数据结构叫做并查集。使用前得初始化。</p><h3 id="查询"><a href="#查询" class="headerlink" title="查询"></a>查询</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">int</span> <span class="title">find</span><span class="params">(<span class="type">int</span> n)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  <span class="keyword">return</span> n==f[n]?n:(f[n]=<span class="built_in">find</span>(f[n]));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="合并"><a href="#合并" class="headerlink" title="合并"></a>合并</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">merge</span><span class="params">(<span class="type">int</span> i,<span class="type">int</span> j)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">   f[<span class="built_in">find</span>(i)]=<span class="built_in">find</span>(j);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="典例题"><a href="#典例题" class="headerlink" title="典例题"></a>典例题</h3><p>P1551 亲戚 - 洛谷 | 计算机科学教育新生态 (luogu.com.cn)</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="type">const</span> <span class="type">int</span> MAX = <span class="number">2e6</span>+<span class="number">5</span>;</span><br><span class="line"><span class="type">int</span> f[MAX];</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">init</span><span class="params">(<span class="type">int</span> *f,<span class="type">int</span> n)</span><span class="comment">//初始化并查集</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt;= n; i++)</span><br><span class="line">f[i] = i;</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">Find</span><span class="params">(<span class="type">int</span> n)</span><span class="comment">//查询父节点</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">return</span> n == f[n] ? n : (f[n] = <span class="built_in">Find</span>(f[n]));</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">merge</span><span class="params">(<span class="type">int</span> i,<span class="type">int</span> j)</span><span class="comment">//合并</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">f[<span class="built_in">Find</span>(i)] = <span class="built_in">Find</span>(j);</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="type">int</span> p1, p2;</span><br><span class="line"><span class="type">int</span> n, m, p; cin &gt;&gt; n &gt;&gt; m &gt;&gt; p;</span><br><span class="line"><span class="built_in">init</span>(f, n);</span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt;= m; i++)</span><br><span class="line">&#123;</span><br><span class="line">cin &gt;&gt; p1 &gt;&gt; p2;</span><br><span class="line"><span class="built_in">merge</span>(p1, p2);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> j = <span class="number">1</span>; j &lt;= p; j++)</span><br><span class="line">&#123;</span><br><span class="line">cin &gt;&gt; p1 &gt;&gt; p2;</span><br><span class="line"><span class="keyword">if</span> (<span class="built_in">Find</span>(p1) == <span class="built_in">Find</span>(p2))</span><br><span class="line">cout &lt;&lt; <span class="string">&quot;Yes&quot;</span> &lt;&lt; endl;</span><br><span class="line"><span class="keyword">else</span></span><br><span class="line">cout &lt;&lt; <span class="string">&quot;No&quot;</span> &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="哈希表-x2F-散列表"><a href="#哈希表-x2F-散列表" class="headerlink" title="哈希表&#x2F;散列表"></a>哈希表&#x2F;散列表</h2><h3 id="一种字符串hash："><a href="#一种字符串hash：" class="headerlink" title="一种字符串hash："></a>一种字符串hash：</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="type">unsigned</span> <span class="type">long</span> <span class="type">long</span> LL;</span><br><span class="line"><span class="type">int</span> prime = <span class="number">233317</span>;</span><br><span class="line">LL mod = <span class="number">212370440130137957ll</span>,base=<span class="number">123</span>;</span><br><span class="line"><span class="function">LL <span class="title">Hash</span><span class="params">(<span class="type">char</span> s[])</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="type">int</span> len = <span class="built_in">strlen</span>(s);</span><br><span class="line">    LL res = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; len; i++)</span><br><span class="line">        res = (res * base + (LL)s[i]) % mod + prime;</span><br><span class="line">    <span class="keyword">return</span> res;    </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="STL-hash"><a href="#STL-hash" class="headerlink" title="STL hash"></a>STL hash</h3><p>C++ STL 自带hash。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    string str = <span class="string">&quot;Cirno is the strongest&quot;</span>;</span><br><span class="line">    hash&lt;string&gt; hash_fn;</span><br><span class="line">    <span class="type">size_t</span> str_hash = <span class="built_in">hash_fn</span>(str);</span><br><span class="line">    cout &lt;&lt; str_hash;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="解决冲突的方法"><a href="#解决冲突的方法" class="headerlink" title="解决冲突的方法"></a>解决冲突的方法</h3><h4 id="分离链接法"><a href="#分离链接法" class="headerlink" title="分离链接法"></a>分离链接法</h4><h2 id="图"><a href="#图" class="headerlink" title="图"></a>图</h2><h3 id="邻接矩阵"><a href="#邻接矩阵" class="headerlink" title="邻接矩阵"></a>邻接矩阵</h3><h3 id="邻接表"><a href="#邻接表" class="headerlink" title="邻接表"></a>邻接表</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="type">const</span> <span class="type">int</span> MAX = <span class="number">1000</span>;</span><br><span class="line"><span class="type">int</span> m, n;<span class="comment">//图中m顶点，n条边。</span></span><br><span class="line">vector&lt;pair&lt;<span class="type">int</span>, <span class="type">int</span>&gt;&gt; P[MAX];</span><br><span class="line"><span class="type">int</span> v[MAX][MAX];</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">cin &gt;&gt; m &gt;&gt; n;</span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt;= m; i++)</span><br><span class="line">&#123;</span><br><span class="line"><span class="type">int</span> u, v, l; cin &gt;&gt; u &gt;&gt; v &gt;&gt; l;</span><br><span class="line">P[u].<span class="built_in">push_back</span>(&#123; v,l &#125;);</span><br><span class="line"><span class="comment">//P[v].push_back(&#123;u,l&#125;)</span></span><br><span class="line"><span class="comment">//如果是无向图，则还需要将终点，起始点颠倒过来存储一下</span></span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line"><span class="comment">//将邻接表转换为邻接矩阵</span></span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt;= m; i++)</span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> j = <span class="number">0</span>; j &lt; P[i].<span class="built_in">size</span>(); j++)</span><br><span class="line">v[i][P[i][j].first] = P[i][j].second;</span><br><span class="line"><span class="comment">//对于邻接矩阵v[i][j]，j就是终点，即为P[i][j].first，</span></span><br><span class="line"><span class="comment">//其储存的值为边权，也就是P[i][j].second</span></span><br><span class="line"> </span><br><span class="line"> </span><br><span class="line"><span class="comment">//output</span></span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt;= m; i++) &#123;</span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> j = <span class="number">1</span>; j &lt;= m; j++)</span><br><span class="line">cout &lt;&lt; v[i][j] &lt;&lt; <span class="string">&quot; &quot;</span>;</span><br><span class="line">cout &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="图的遍历"><a href="#图的遍历" class="headerlink" title="图的遍历"></a>图的遍历</h3><h4 id="DFS遍历"><a href="#DFS遍历" class="headerlink" title="DFS遍历"></a>DFS遍历</h4><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">dfs</span><span class="params">(<span class="type">int</span> x)</span> </span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">vis[x] = <span class="literal">true</span>;</span><br><span class="line">cout &lt;&lt; x &lt;&lt; <span class="string">&quot; &quot;</span>; </span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> i=<span class="number">0</span>; i&lt;P[x].<span class="built_in">size</span>(); i++)</span><br><span class="line"><span class="keyword">if</span> (!vis[P[x][i]]) </span><br><span class="line">            <span class="built_in">dfs</span>(P[x][i]);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="BFS遍历"><a href="#BFS遍历" class="headerlink" title="BFS遍历"></a>BFS遍历</h4><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">queue&lt;<span class="type">int</span>&gt; q;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">bfs</span><span class="params">(<span class="type">int</span> x)</span> </span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="built_in">memset</span>(vis, <span class="literal">false</span>, <span class="built_in">sizeof</span>(vis));</span><br><span class="line">vis[x] = <span class="literal">true</span>;</span><br><span class="line">q.<span class="built_in">push</span>(x);</span><br><span class="line"><span class="keyword">while</span> (!q.<span class="built_in">empty</span>())</span><br><span class="line">     &#123;</span><br><span class="line"><span class="type">int</span> v = q.<span class="built_in">front</span>();</span><br><span class="line">q.<span class="built_in">pop</span>();</span><br><span class="line">cout &lt;&lt; v &lt;&lt; <span class="string">&quot; &quot;</span>;</span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> i=<span class="number">0</span>; i&lt;P[v].<span class="built_in">size</span>(); i++) </span><br><span class="line"><span class="keyword">if</span> (!vis[P[v][i]]) </span><br><span class="line">            &#123;</span><br><span class="line">vis[P[v][i]] = <span class="literal">true</span>;</span><br><span class="line">q.<span class="built_in">push</span>(P[v][i]);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="DAG与拓扑排序"><a href="#DAG与拓扑排序" class="headerlink" title="DAG与拓扑排序"></a>DAG与拓扑排序</h3><p>DAG：对于一个图而言，如果这个图是没有环的，但是边是有方向的，那么就称之为有向无环图，即DAG。</p><p>拓扑排序：拓扑排序就是在DAG的基础上对点进行排序，使得在搜到点x时所有能到达点x的点y已经被搜过了。<br>其具体实现流程如下：<br>1.将所有入度为0的点加入处理队列<br>2.将处于队头的点x取出，遍历x所能到达的所有点y。<br>3. 对于每一个y，删除从点x到点y的边。<br>4.如果点y的入度减为0了，说明说明所有能到y的点都被计算过了，再将点y加入处理队列。<br>5.重复2，直到队列为空。<br>一道用到拓扑排序的经典例题：<br>P4017 最大食物链计数 - 洛谷 | 计算机科学教育新生态 (luogu.com.cn)</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="type">const</span> <span class="type">int</span> MAX = <span class="number">5e5</span> + <span class="number">10</span>;</span><br><span class="line"><span class="type">const</span> <span class="type">int</span> MOD = <span class="number">80112002</span>;</span><br><span class="line">vector&lt;<span class="type">int</span>&gt; V[MAX];</span><br><span class="line">queue&lt;<span class="type">int</span>&gt; Q;</span><br><span class="line"><span class="type">int</span> ind[MAX], outd[MAX], f[MAX];<span class="comment">//入度，出度，食物链数</span></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="type">int</span> n, m, res = <span class="number">0</span>; cin &gt;&gt; n &gt;&gt; m;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; m; i++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="type">int</span> x, y; cin &gt;&gt; x &gt;&gt; y;</span><br><span class="line">        outd[x]++; ind[y]++;</span><br><span class="line">        V[x].<span class="built_in">push_back</span>(y);</span><br><span class="line">    &#125;</span><br><span class="line"> </span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt;= n; i++) &#123;</span><br><span class="line">        <span class="keyword">if</span> (ind[i] == <span class="number">0</span>)</span><br><span class="line">            Q.<span class="built_in">push</span>(i),f[i]=<span class="number">1</span>;</span><br><span class="line">    &#125;<span class="comment">//将入度为0的数据入队</span></span><br><span class="line"> </span><br><span class="line">    <span class="keyword">while</span> (!Q.<span class="built_in">empty</span>()) &#123;</span><br><span class="line">        <span class="type">int</span> x = Q.<span class="built_in">front</span>(); Q.<span class="built_in">pop</span>();</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; V[x].<span class="built_in">size</span>(); i++) &#123;</span><br><span class="line">            <span class="type">int</span> y = V[x][i];</span><br><span class="line">            f[y] = (f[x] + f[y]) % MOD;</span><br><span class="line">            ind[y]--;</span><br><span class="line">            <span class="keyword">if</span> (ind[y] == <span class="number">0</span>)</span><br><span class="line">                Q.<span class="built_in">push</span>(y);<span class="comment">//入度为0，就入队</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"> </span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt;= n; i++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span> (outd[i] == <span class="number">0</span>)</span><br><span class="line">            res = (res + f[i]) % MOD;</span><br><span class="line">    &#125;</span><br><span class="line">    cout &lt;&lt; res;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="最短路问题"><a href="#最短路问题" class="headerlink" title="最短路问题"></a>最短路问题</h3><h4 id="无权最短路问题"><a href="#无权最短路问题" class="headerlink" title="无权最短路问题"></a>无权最短路问题</h4><p>运用到了BFS ，没有访问到的标记为INF。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="type">const</span> <span class="type">int</span> MAX = <span class="number">1e6</span>;</span><br><span class="line"><span class="type">const</span> <span class="type">int</span> MOD = <span class="number">100003</span>;</span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">Node</span> &#123;</span><br><span class="line">    <span class="type">bool</span> vis=<span class="literal">false</span>;</span><br><span class="line">    <span class="type">int</span> Dist = INFINITY;</span><br><span class="line">    <span class="type">int</span> path;</span><br><span class="line">&#125;;</span><br><span class="line">vector&lt;<span class="type">int</span>&gt; V[MAX];</span><br><span class="line">queue&lt;<span class="type">int</span>&gt; Q;</span><br><span class="line">Node NodeArr[MAX];</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="type">int</span> m, n; cin &gt;&gt; m &gt;&gt; n;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt;= n; i++) &#123;</span><br><span class="line">        <span class="type">int</span> x, y; cin &gt;&gt; x &gt;&gt; y;</span><br><span class="line">        V[x].<span class="built_in">push_back</span>(y);</span><br><span class="line">        V[y].<span class="built_in">push_back</span>(x);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt;= m; i++) &#123;</span><br><span class="line">        NodeArr[i].vis = <span class="literal">false</span>;</span><br><span class="line">        NodeArr[i].Dist = INFINITY;</span><br><span class="line">    &#125;</span><br><span class="line">    Q.<span class="built_in">push</span>(<span class="number">1</span>); NodeArr[<span class="number">1</span>].Dist = <span class="number">0</span>; NodeArr[<span class="number">1</span>].vis = <span class="literal">true</span>;</span><br><span class="line">    <span class="keyword">while</span> (!Q.<span class="built_in">empty</span>()) &#123;</span><br><span class="line">        <span class="type">int</span> x = Q.<span class="built_in">front</span>(); Q.<span class="built_in">pop</span>();</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; V[x].<span class="built_in">size</span>(); i++) &#123;</span><br><span class="line">            <span class="keyword">if</span> (NodeArr[V[x][i]].vis==<span class="literal">false</span>) &#123;</span><br><span class="line">                NodeArr[V[x][i]].vis = <span class="literal">true</span>;</span><br><span class="line">                NodeArr[V[x][i]].Dist = NodeArr[x].Dist + <span class="number">1</span>;</span><br><span class="line">                NodeArr[V[x][i]].path = x;</span><br><span class="line">                Q.<span class="built_in">push</span>(V[x][i]);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt;= m; i++)</span><br><span class="line">        cout &lt;&lt; NodeArr[i].Dist &lt;&lt; endl;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>P1144 最短路计数 - 洛谷 | 计算机科学教育新生态 (luogu.com.cn)<br>以下为这题题解，这题除了可以求出1到各个结点的无权最短路长度以外，还可以求出到不同结点一共有多少种最短路情况。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="type">const</span> <span class="type">int</span> MAX = <span class="number">1e6</span>;</span><br><span class="line"><span class="type">const</span> <span class="type">int</span> MOD = <span class="number">100003</span>;</span><br><span class="line">vector&lt;<span class="type">int</span>&gt; V[MAX];</span><br><span class="line">queue&lt;<span class="type">int</span>&gt; Q;</span><br><span class="line"><span class="type">bool</span> judge[MAX];</span><br><span class="line"><span class="type">int</span> cnt[MAX],depth[MAX];</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line"><span class="type">int</span> m, n; cin &gt;&gt; m &gt;&gt; n;</span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt;= n; i++) &#123;</span><br><span class="line"><span class="type">int</span> x, y; cin &gt;&gt; x &gt;&gt; y;</span><br><span class="line">V[x].<span class="built_in">push_back</span>(y);</span><br><span class="line">V[y].<span class="built_in">push_back</span>(x);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt;= m; i++) <span class="built_in">sort</span>(V[i].<span class="built_in">begin</span>(), V[i].<span class="built_in">end</span>());</span><br><span class="line">Q.<span class="built_in">push</span>(<span class="number">1</span>); judge[<span class="number">1</span>] = <span class="number">1</span>; cnt[<span class="number">1</span>] = <span class="number">1</span>;</span><br><span class="line"><span class="keyword">while</span> (!Q.<span class="built_in">empty</span>()) &#123;</span><br><span class="line"><span class="type">int</span> x = Q.<span class="built_in">front</span>(); Q.<span class="built_in">pop</span>();</span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; V[x].<span class="built_in">size</span>(); i++) &#123;</span><br><span class="line"><span class="type">int</span> n = V[x][i];</span><br><span class="line"><span class="keyword">if</span> (!judge[n]) &#123;</span><br><span class="line">judge[n] = <span class="number">1</span>;</span><br><span class="line">depth[n] = depth[x] + <span class="number">1</span>;</span><br><span class="line">Q.<span class="built_in">push</span>(n);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">if</span>(depth[n]==depth[x]+<span class="number">1</span>) cnt[n]=(cnt[n]+cnt[x])%MOD;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt;= m; i++)</span><br><span class="line">cout &lt;&lt; cnt[i] &lt;&lt; endl;</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="Dijkstra算法"><a href="#Dijkstra算法" class="headerlink" title="Dijkstra算法"></a>Dijkstra算法</h4><p>基于贪心思想，使用堆优化，可以求得有权最短路径的结果</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="type">const</span> <span class="type">int</span> MAX = <span class="number">2e5</span>+<span class="number">5</span>;</span><br><span class="line"><span class="type">const</span> <span class="type">int</span> INF = <span class="number">2147483647</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">Node</span> &#123;</span><br><span class="line">    <span class="type">int</span> dist = INF;</span><br><span class="line">    <span class="type">bool</span> vis = <span class="literal">false</span>;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> pair&lt;<span class="type">int</span>, <span class="type">int</span>&gt; pll;</span><br><span class="line"></span><br><span class="line">Node NodeArr[MAX];</span><br><span class="line">vector&lt;pll&gt; V[MAX];</span><br><span class="line">priority_queue&lt;pll,vector&lt;pll&gt;,greater&lt;pll&gt;&gt; Q;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">Dijkstra</span><span class="params">(vector&lt;pair&lt;<span class="type">int</span>, <span class="type">int</span>&gt;&gt; V[], <span class="type">int</span> start)</span> </span>&#123;</span><br><span class="line">    NodeArr[start].dist = <span class="number">0</span>;</span><br><span class="line">    Q.<span class="built_in">push</span>(&#123; <span class="number">0</span>,start &#125;); </span><br><span class="line">    <span class="keyword">while</span> (!Q.<span class="built_in">empty</span>()) &#123;</span><br><span class="line">        <span class="type">int</span> x = Q.<span class="built_in">top</span>().second; Q.<span class="built_in">pop</span>();</span><br><span class="line">        <span class="keyword">if</span> (NodeArr[x].vis)</span><br><span class="line">            <span class="keyword">continue</span>;</span><br><span class="line">        NodeArr[x].vis = <span class="literal">true</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; V[x].<span class="built_in">size</span>(); i++)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="type">int</span> temp = NodeArr[x].dist + V[x][i].first;</span><br><span class="line">            <span class="keyword">if</span> (NodeArr[V[x][i].second].dist &gt; temp)</span><br><span class="line">                NodeArr[V[x][i].second].dist = temp,Q.<span class="built_in">push</span>(&#123; NodeArr[V[x][i].second].dist, V[x][i].second &#125;);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;.</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="type">int</span> n, m, s; cin &gt;&gt; n &gt;&gt; m &gt;&gt; s;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt;= m; i++) &#123;</span><br><span class="line">        <span class="type">int</span> x, y, l; <span class="built_in">scanf</span>(<span class="string">&quot;%d%d%d&quot;</span>, &amp;x, &amp;y, &amp;l);</span><br><span class="line">            V[x].<span class="built_in">push_back</span>(&#123; l, y &#125;);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">Dijkstra</span>(V, s);</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt;= n; i++)</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;%d &quot;</span>, NodeArr[i].dist);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="floyd算法"><a href="#floyd算法" class="headerlink" title="floyd算法"></a>floyd算法</h4><p>可以求出任意两节点之间的最短路径，因此它是比Dijkstra更一般的算法。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="type">const</span> <span class="type">int</span> MAX = <span class="number">5e3</span> + <span class="number">5</span>;</span><br><span class="line"><span class="type">const</span> <span class="type">int</span> INF = <span class="number">2e5</span>;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> Martix[MAX][MAX];</span><br><span class="line"><span class="type">int</span> n, m;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> pathMatirx[MAX][MAX];<span class="comment">//存储中间点</span></span><br><span class="line"><span class="type">int</span> shortPath[MAX][MAX];<span class="comment">//存储两边之间最小值</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">floyd</span><span class="params">(<span class="type">int</span> x,<span class="type">int</span> y)</span> </span>&#123;<span class="comment">//起点，终点</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//init</span></span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt;= n; i++)</span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> j = <span class="number">1</span>; j &lt;= n; j++) &#123;</span><br><span class="line">pathMatirx[i][j] = j;</span><br><span class="line">shortPath[i][j] = Martix[i][j];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt;= n; i++)</span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> j = <span class="number">1</span>; j &lt;= n; j++)</span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> k = <span class="number">1</span>; k &lt;= n; k++) &#123;</span><br><span class="line"><span class="keyword">if</span> (shortPath[j][k] &gt; (shortPath[j][i] + shortPath[i][k])) &#123;</span><br><span class="line">shortPath[j][k] = shortPath[j][i] + shortPath[i][k];</span><br><span class="line">pathMatirx[j][k] = pathMatirx[j][i];</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt;= n; i++) &#123;</span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> j = <span class="number">1</span>; j &lt;= n; j++)</span><br><span class="line">cout &lt;&lt; shortPath[i][j] &lt;&lt; <span class="string">&quot; &quot;</span>;</span><br><span class="line">cout &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">cout &lt;&lt; x &lt;&lt; <span class="string">&quot; &quot;</span>;</span><br><span class="line"><span class="type">int</span> k = pathMatirx[x][y];</span><br><span class="line"><span class="keyword">while</span> (k != y) &#123;</span><br><span class="line">cout &lt;&lt; k &lt;&lt; <span class="string">&quot; &quot;</span>;</span><br><span class="line">k = pathMatirx[k][y];</span><br><span class="line">&#125;</span><br><span class="line">cout &lt;&lt; y &lt;&lt; endl;</span><br><span class="line">cout &lt;&lt; shortPath[x][y] &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">std::ios::<span class="built_in">sync_with_stdio</span>(<span class="literal">false</span>);</span><br><span class="line">cin.<span class="built_in">tie</span>(<span class="number">0</span>);</span><br><span class="line">cin &gt;&gt; n &gt;&gt; m;</span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt;= n; i++)</span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> j = <span class="number">1</span>; j &lt;= n; j++) &#123;</span><br><span class="line"><span class="keyword">if</span> (i == j)</span><br><span class="line">Martix[i][j] = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">else</span></span><br><span class="line">Martix[i][j] = INF;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt;= m; i++) &#123;</span><br><span class="line"><span class="type">int</span> x, y, v; cin &gt;&gt; x &gt;&gt; y &gt;&gt; v;</span><br><span class="line">Martix[x][y] = v;</span><br><span class="line">Martix[y][x] = v;</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">floyd</span>(<span class="number">1</span>,<span class="number">2</span>);</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="最小生成树"><a href="#最小生成树" class="headerlink" title="最小生成树"></a>最小生成树</h3><h4 id="Prim算法"><a href="#Prim算法" class="headerlink" title="Prim算法"></a>Prim算法</h4><p>算法和dijkstra非常像，甚至可以说是一模一样.</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="type">const</span> <span class="type">int</span> MAX = <span class="number">2e5</span> + <span class="number">5</span>;</span><br><span class="line"><span class="type">const</span> <span class="type">int</span> INF = <span class="number">1</span>&lt;&lt;<span class="number">30</span>;</span><br><span class="line"><span class="keyword">typedef</span> pair&lt;<span class="type">long</span> , <span class="type">long</span> &gt; pll;<span class="comment">//权重，终点</span></span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">Node</span> &#123;</span><br><span class="line"><span class="type">long</span> <span class="type">long</span> dist = INF;</span><br><span class="line"><span class="type">bool</span> vis = <span class="literal">false</span>;</span><br><span class="line">&#125; node[MAX];</span><br><span class="line"></span><br><span class="line">priority_queue&lt;pll, vector&lt;pll&gt;, greater&lt;pll&gt;&gt; q;</span><br><span class="line">vector&lt;pll&gt; V[MAX];</span><br><span class="line"><span class="type">int</span> N, M;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">prim</span><span class="params">()</span> </span>&#123;</span><br><span class="line"><span class="type">int</span> ans = <span class="number">0</span>, tot = <span class="number">0</span>;</span><br><span class="line">q.<span class="built_in">push</span>(&#123; <span class="number">0</span>,<span class="number">1</span> &#125;);</span><br><span class="line">node[<span class="number">1</span>].dist = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">while</span> (!q.<span class="built_in">empty</span>()) &#123;</span><br><span class="line">pll x = q.<span class="built_in">top</span>();</span><br><span class="line">q.<span class="built_in">pop</span>();</span><br><span class="line"><span class="keyword">if</span> (node[x.second].vis)</span><br><span class="line"><span class="keyword">continue</span>;</span><br><span class="line">tot++;</span><br><span class="line">ans += node[x.second].dist;</span><br><span class="line">node[x.second].vis = <span class="literal">true</span>;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">auto</span> i : V[x.second]) &#123;</span><br><span class="line"><span class="keyword">if</span> (!node[i.second].vis &amp;&amp; i.first &lt; node[i.second].dist) &#123;</span><br><span class="line">node[i.second].dist = i.first;</span><br><span class="line">q.<span class="built_in">push</span>(&#123; node[i.second].dist,i.second &#125;);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">if</span> (tot != N)</span><br><span class="line">cout &lt;&lt; <span class="string">&quot;orz&quot;</span> &lt;&lt; endl;</span><br><span class="line"><span class="keyword">else</span></span><br><span class="line">cout &lt;&lt; ans &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">(<span class="type">void</span>)</span> </span>&#123;</span><br><span class="line">std::ios::<span class="built_in">sync_with_stdio</span>(<span class="literal">false</span>);</span><br><span class="line">cin.<span class="built_in">tie</span>(<span class="number">0</span>); cout.<span class="built_in">tie</span>(<span class="number">0</span>);</span><br><span class="line">cin &gt;&gt; N &gt;&gt; M;</span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt;= M; i++) &#123;</span><br><span class="line"><span class="type">int</span> x, y, l;</span><br><span class="line">cin &gt;&gt; x &gt;&gt; y &gt;&gt; l;</span><br><span class="line">V[x].<span class="built_in">push_back</span>(&#123; l,y &#125;);</span><br><span class="line">V[y].<span class="built_in">push_back</span>(&#123; l,x &#125;);</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">prim</span>();</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="Kruskal算法"><a href="#Kruskal算法" class="headerlink" title="Kruskal算法"></a>Kruskal算法</h4><p>也是一种求最小生成树的算法，使用到了并查集的知识，将结点根据权值有小到大进行排列，从第一个结点开始遍历，如果结点起点和终点不属于同一个集合，则将两点合并到同一个集合，并且使计数cnt–，ans增加起点到终点的权值，最后可以到达求最小生成树的目的。其基本思想是贪心。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="type">const</span> <span class="type">int</span> MAX=<span class="number">2e5</span>+<span class="number">5</span>;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> m,n,f[MAX];</span><br><span class="line"></span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">Node</span>&#123;</span><br><span class="line"><span class="type">int</span> x,y,v;</span><br><span class="line"><span class="type">bool</span> <span class="keyword">operator</span>&lt;(<span class="type">const</span> Node&amp; a) <span class="type">const</span>&#123;</span><br><span class="line"><span class="keyword">return</span> v&lt;a.v;</span><br><span class="line">&#125;</span><br><span class="line">&#125; M[MAX];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">find</span><span class="params">(<span class="type">int</span> n)</span></span>&#123;</span><br><span class="line"><span class="keyword">return</span> n==f[n]?n:(f[n]=<span class="built_in">find</span>(f[n]));</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">merge</span><span class="params">(<span class="type">int</span> x,<span class="type">int</span> y)</span></span>&#123;</span><br><span class="line">f[<span class="built_in">find</span>(x)]=<span class="built_in">find</span>(y);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">init</span><span class="params">(<span class="type">int</span> n)</span></span>&#123;</span><br><span class="line"><span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=n;i++)</span><br><span class="line">f[i]=i;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">Kurskal</span><span class="params">()</span></span>&#123;</span><br><span class="line"><span class="built_in">init</span>(m);</span><br><span class="line"><span class="built_in">sort</span>(M+<span class="number">1</span>,M+<span class="number">1</span>+n);</span><br><span class="line"><span class="type">int</span> ans=<span class="number">0</span>,cnt=m;</span><br><span class="line"><span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=n;i++)&#123;</span><br><span class="line"><span class="type">int</span> x=<span class="built_in">find</span>(M[i].x),y=<span class="built_in">find</span>(M[i].y);</span><br><span class="line"><span class="keyword">if</span>(x!=y)&#123;</span><br><span class="line"><span class="built_in">merge</span>(x,y);</span><br><span class="line">ans+=M[i].v;</span><br><span class="line">cnt--;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">if</span>(cnt==<span class="number">1</span>)</span><br><span class="line"><span class="keyword">break</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">if</span>(cnt!=<span class="number">1</span>)</span><br><span class="line">cout&lt;&lt;<span class="string">&quot;orz&quot;</span>&lt;&lt;endl;</span><br><span class="line"><span class="keyword">else</span> </span><br><span class="line">cout&lt;&lt;ans&lt;&lt;endl;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">cin&gt;&gt;m&gt;&gt;n;</span><br><span class="line"><span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=n;i++)&#123;</span><br><span class="line">cin&gt;&gt;M[i].x&gt;&gt;M[i].y&gt;&gt;M[i].v;</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">Kurskal</span>();</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="java快读类"><a href="#java快读类" class="headerlink" title="java快读类"></a>java快读类</h1><p>  鉴定为十分有用</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/** 快速输入类 */</span></span><br><span class="line"><span class="keyword">static</span> <span class="keyword">class</span> <span class="title class_">Reader</span> &#123;</span><br><span class="line">    <span class="keyword">static</span> <span class="type">BufferedReader</span> <span class="variable">reader</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">BufferedReader</span>(<span class="keyword">new</span> <span class="title class_">InputStreamReader</span>(System.in));</span><br><span class="line">    <span class="keyword">static</span> <span class="type">StringTokenizer</span> <span class="variable">tokenizer</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">StringTokenizer</span>(<span class="string">&quot;&quot;</span>);</span><br><span class="line">    <span class="comment">/** 获取下一段文本 */</span></span><br><span class="line">    <span class="keyword">static</span> String <span class="title function_">next</span><span class="params">()</span> <span class="keyword">throws</span> IOException &#123;</span><br><span class="line">        <span class="keyword">while</span> ( ! tokenizer.hasMoreTokens() ) &#123;</span><br><span class="line">            tokenizer = <span class="keyword">new</span> <span class="title class_">StringTokenizer</span>(reader.readLine());</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> tokenizer.nextToken();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">static</span> <span class="type">int</span> <span class="title function_">nextInt</span><span class="params">()</span> <span class="keyword">throws</span> IOException &#123;</span><br><span class="line">        <span class="keyword">return</span> Integer.parseInt( next() );</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">static</span> <span class="type">double</span> <span class="title function_">nextDouble</span><span class="params">()</span> <span class="keyword">throws</span> IOException &#123;</span><br><span class="line">        <span class="keyword">return</span> Double.parseDouble( next() );</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> ACM算法 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>Welcome to Cirno&#39;s Blog!!</title>
      <link href="/2023/07/01/Welcome%20to%20My%20blog/"/>
      <url>/2023/07/01/Welcome%20to%20My%20blog/</url>
      
        <content type="html"><![CDATA[<p>欢迎来到我的博客！本人会在该博客内发布近期的学习内容笔记</p>]]></content>
      
      
      
    </entry>
    
    
  
  
</search>
