<!DOCTYPE html><html lang="zh-CN" data-theme="light"><head><meta charset="UTF-8"><meta http-equiv="X-UA-Compatible" content="IE=edge"><meta name="viewport" content="width=device-width, initial-scale=1.0,viewport-fit=cover"><title>算法板子 | Cirno's Blog</title><meta name="author" content="TheWiseCirno"><meta name="copyright" content="TheWiseCirno"><meta name="format-detection" content="telephone=no"><meta name="theme-color" content="#ffffff"><meta name="description" content="排序算法计数排序123456789101112void countsort(int* a, int n)&#x2F;&#x2F;计数排序&amp;#123;    for (int i &#x3D; 1; i &lt;&#x3D; n; i++)    &amp;#123;        cnt[a[i]]++;    &amp;#125;    for (int j &#x3D; 1; j &lt;&#x3D; Max; j++)    &amp;#123;        for (i">
<meta property="og:type" content="article">
<meta property="og:title" content="算法板子">
<meta property="og:url" content="http://example.com/2023/07/01/%E7%AE%97%E6%B3%95%E6%9D%BF%E5%AD%90%E6%B1%87%E6%80%BB/index.html">
<meta property="og:site_name" content="Cirno&#39;s Blog">
<meta property="og:description" content="排序算法计数排序123456789101112void countsort(int* a, int n)&#x2F;&#x2F;计数排序&amp;#123;    for (int i &#x3D; 1; i &lt;&#x3D; n; i++)    &amp;#123;        cnt[a[i]]++;    &amp;#125;    for (int j &#x3D; 1; j &lt;&#x3D; Max; j++)    &amp;#123;        for (i">
<meta property="og:locale" content="zh_CN">
<meta property="og:image" content="http://example.com/img/avatar.jpg">
<meta property="article:published_time" content="2023-07-01T09:18:26.496Z">
<meta property="article:modified_time" content="2023-07-01T08:13:01.790Z">
<meta property="article:author" content="TheWiseCirno">
<meta property="article:tag" content="算法,C++,Java">
<meta name="twitter:card" content="summary">
<meta name="twitter:image" content="http://example.com/img/avatar.jpg"><link rel="shortcut icon" href="/img/favicon.png"><link rel="canonical" href="http://example.com/2023/07/01/%E7%AE%97%E6%B3%95%E6%9D%BF%E5%AD%90%E6%B1%87%E6%80%BB/index.html"><link rel="preconnect" href="//cdn.jsdelivr.net"/><link rel="preconnect" href="//busuanzi.ibruce.info"/><link rel="stylesheet" href="/css/index.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fortawesome/fontawesome-free/css/all.min.css" media="print" onload="this.media='all'"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fancyapps/ui/dist/fancybox/fancybox.min.css" media="print" onload="this.media='all'"><script>const GLOBAL_CONFIG = {
  root: '/',
  algolia: undefined,
  localSearch: undefined,
  translate: undefined,
  noticeOutdate: undefined,
  highlight: {"plugin":"highlighjs","highlightCopy":true,"highlightLang":true,"highlightHeightLimit":false},
  copy: {
    success: '复制成功',
    error: '复制错误',
    noSupport: '浏览器不支持'
  },
  relativeDate: {
    homepage: false,
    post: false
  },
  runtime: '',
  dateSuffix: {
    just: '刚刚',
    min: '分钟前',
    hour: '小时前',
    day: '天前',
    month: '个月前'
  },
  copyright: undefined,
  lightbox: 'fancybox',
  Snackbar: undefined,
  source: {
    justifiedGallery: {
      js: 'https://cdn.jsdelivr.net/npm/flickr-justified-gallery/dist/fjGallery.min.js',
      css: 'https://cdn.jsdelivr.net/npm/flickr-justified-gallery/dist/fjGallery.min.css'
    }
  },
  isPhotoFigcaption: false,
  islazyload: false,
  isAnchor: false,
  percent: {
    toc: true,
    rightside: false,
  },
  autoDarkmode: false
}</script><script id="config-diff">var GLOBAL_CONFIG_SITE = {
  title: '算法板子',
  isPost: true,
  isHome: false,
  isHighlightShrink: false,
  isToc: true,
  postUpdate: '2023-07-01 16:13:01'
}</script><noscript><style type="text/css">
  #nav {
    opacity: 1
  }
  .justified-gallery img {
    opacity: 1
  }

  #recent-posts time,
  #post-meta time {
    display: inline !important
  }
</style></noscript><script>(win=>{
    win.saveToLocal = {
      set: function setWithExpiry(key, value, ttl) {
        if (ttl === 0) return
        const now = new Date()
        const expiryDay = ttl * 86400000
        const item = {
          value: value,
          expiry: now.getTime() + expiryDay,
        }
        localStorage.setItem(key, JSON.stringify(item))
      },

      get: function getWithExpiry(key) {
        const itemStr = localStorage.getItem(key)

        if (!itemStr) {
          return undefined
        }
        const item = JSON.parse(itemStr)
        const now = new Date()

        if (now.getTime() > item.expiry) {
          localStorage.removeItem(key)
          return undefined
        }
        return item.value
      }
    }
  
    win.getScript = url => new Promise((resolve, reject) => {
      const script = document.createElement('script')
      script.src = url
      script.async = true
      script.onerror = reject
      script.onload = script.onreadystatechange = function() {
        const loadState = this.readyState
        if (loadState && loadState !== 'loaded' && loadState !== 'complete') return
        script.onload = script.onreadystatechange = null
        resolve()
      }
      document.head.appendChild(script)
    })
  
    win.getCSS = (url,id = false) => new Promise((resolve, reject) => {
      const link = document.createElement('link')
      link.rel = 'stylesheet'
      link.href = url
      if (id) link.id = id
      link.onerror = reject
      link.onload = link.onreadystatechange = function() {
        const loadState = this.readyState
        if (loadState && loadState !== 'loaded' && loadState !== 'complete') return
        link.onload = link.onreadystatechange = null
        resolve()
      }
      document.head.appendChild(link)
    })
  
      win.activateDarkMode = function () {
        document.documentElement.setAttribute('data-theme', 'dark')
        if (document.querySelector('meta[name="theme-color"]') !== null) {
          document.querySelector('meta[name="theme-color"]').setAttribute('content', '#0d0d0d')
        }
      }
      win.activateLightMode = function () {
        document.documentElement.setAttribute('data-theme', 'light')
        if (document.querySelector('meta[name="theme-color"]') !== null) {
          document.querySelector('meta[name="theme-color"]').setAttribute('content', '#ffffff')
        }
      }
      const t = saveToLocal.get('theme')
    
          if (t === 'dark') activateDarkMode()
          else if (t === 'light') activateLightMode()
        
      const asideStatus = saveToLocal.get('aside-status')
      if (asideStatus !== undefined) {
        if (asideStatus === 'hide') {
          document.documentElement.classList.add('hide-aside')
        } else {
          document.documentElement.classList.remove('hide-aside')
        }
      }
    
    const detectApple = () => {
      if(/iPad|iPhone|iPod|Macintosh/.test(navigator.userAgent)){
        document.documentElement.classList.add('apple')
      }
    }
    detectApple()
    })(window)</script><!-- hexo injector head_end start -->
<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/katex@0.12.0/dist/katex.min.css">
<!-- hexo injector head_end end --><meta name="generator" content="Hexo 6.3.0"></head><body><div id="sidebar"><div id="menu-mask"></div><div id="sidebar-menus"><div class="avatar-img is-center"><img src="/img/avatar.jpg" onerror="onerror=null;src='/img/friend_404.gif'" alt="avatar"/></div><div class="sidebar-site-data site-data is-center"><a href="/archives/"><div class="headline">文章</div><div class="length-num">2</div></a><a href="/tags/"><div class="headline">标签</div><div class="length-num">1</div></a><a href="/categories/"><div class="headline">分类</div><div class="length-num">0</div></a></div><hr class="custom-hr"/><div class="menus_items"><div class="menus_item"><a class="site-page" href="/"><i class="fa-fw fas fa-home"></i><span> 主页</span></a></div><div class="menus_item"><a class="site-page" href="/categories/"><i class="fa-fw fa fa-archive"></i><span> 分类</span></a></div><div class="menus_item"><a class="site-page" href="/tags/"><i class="fa-fw fa fa-tags"></i><span> 标签</span></a></div><div class="menus_item"><a class="site-page" href="/archives/"><i class="fa-fw fa fa-folder-open"></i><span> 归档</span></a></div><div class="menus_item"><a class="site-page" href="/about/"><i class="fa-fw fas fa-heart"></i><span> 关于笔者</span></a></div></div></div></div><div class="post" id="body-wrap"><header class="post-bg" id="page-header" style="background-image: url('/img/background.jpg')"><nav id="nav"><span id="blog-info"><a href="/" title="Cirno's Blog"><span class="site-name">Cirno's Blog</span></a></span><div id="menus"><div class="menus_items"><div class="menus_item"><a class="site-page" href="/"><i class="fa-fw fas fa-home"></i><span> 主页</span></a></div><div class="menus_item"><a class="site-page" href="/categories/"><i class="fa-fw fa fa-archive"></i><span> 分类</span></a></div><div class="menus_item"><a class="site-page" href="/tags/"><i class="fa-fw fa fa-tags"></i><span> 标签</span></a></div><div class="menus_item"><a class="site-page" href="/archives/"><i class="fa-fw fa fa-folder-open"></i><span> 归档</span></a></div><div class="menus_item"><a class="site-page" href="/about/"><i class="fa-fw fas fa-heart"></i><span> 关于笔者</span></a></div></div><div id="toggle-menu"><a class="site-page" href="javascript:void(0);"><i class="fas fa-bars fa-fw"></i></a></div></div></nav><div id="post-info"><h1 class="post-title">算法板子</h1><div id="post-meta"><div class="meta-firstline"><span class="post-meta-date"><i class="far fa-calendar-alt fa-fw post-meta-icon"></i><span class="post-meta-label">发表于</span><time class="post-meta-date-created" datetime="2023-07-01T09:18:26.496Z" title="发表于 2023-07-01 17:18:26">2023-07-01</time><span class="post-meta-separator">|</span><i class="fas fa-history fa-fw post-meta-icon"></i><span class="post-meta-label">更新于</span><time class="post-meta-date-updated" datetime="2023-07-01T08:13:01.790Z" title="更新于 2023-07-01 16:13:01">2023-07-01</time></span></div><div class="meta-secondline"><span class="post-meta-separator">|</span><span class="post-meta-pv-cv" id="" data-flag-title="算法板子"><i class="far fa-eye fa-fw post-meta-icon"></i><span class="post-meta-label">阅读量:</span><span id="busuanzi_value_page_pv"><i class="fa-solid fa-spinner fa-spin"></i></span></span></div></div></div></header><main class="layout" id="content-inner"><div id="post"><article class="post-content" id="article-container"><h1 id="排序算法"><a href="#排序算法" class="headerlink" title="排序算法"></a>排序算法</h1><h2 id="计数排序"><a href="#计数排序" class="headerlink" title="计数排序"></a>计数排序</h2><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">countsort</span><span class="params">(<span class="type">int</span>* a, <span class="type">int</span> n)</span><span class="comment">//计数排序</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt;= n; i++)</span><br><span class="line">    &#123;</span><br><span class="line">        cnt[a[i]]++;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> j = <span class="number">1</span>; j &lt;= Max; j++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> k = <span class="number">0</span>; k &lt; cnt[j]; k++)</span><br><span class="line">            cout &lt;&lt; j &lt;&lt; <span class="string">&quot; &quot;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="希尔排序"><a href="#希尔排序" class="headerlink" title="希尔排序"></a>希尔排序</h2><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">ShellSort</span><span class="params">(<span class="type">int</span>* arr, <span class="type">int</span> n)</span></span></span><br><span class="line"><span class="function"><span class="comment">//shell排序，基本思想：有点类似于分组排序，数组下标为i的值与下标为i+shell(如果n为奇数，还存在与i+2*shelll进行比较的情况）的值进行比较，如果比他大就交换，反之就小，i从0遍历到n-shell（想想也知道只用遍历一半吧）</span></span></span><br><span class="line"><span class="function"><span class="comment">//然后shell自除以2，再重复上述操作。</span></span></span><br><span class="line"><span class="function"><span class="comment">//最后当shell为0时，数组便排列好了。</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="type">int</span> shell=n;</span><br><span class="line">    <span class="keyword">while</span> (shell &gt; <span class="number">0</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        shell /= <span class="number">2</span>;<span class="comment">//希尔增量，shell=shell/3+1也可以</span></span><br><span class="line">        <span class="type">int</span> i = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; n - shell; i++)<span class="comment">//折半，所以遍历原数组长度的一半就行</span></span><br><span class="line">        &#123;</span><br><span class="line">            <span class="type">int</span> end = i;</span><br><span class="line">            <span class="type">int</span> temp = arr[end + shell];</span><br><span class="line">            <span class="keyword">while</span> (end &gt;= <span class="number">0</span>)</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="keyword">if</span> (temp &lt; arr[end])</span><br><span class="line">                &#123;</span><br><span class="line">                    arr[end + shell] = arr[end];</span><br><span class="line">                    end -= shell;<span class="comment">//这个位置很关键，这样才能分别比较三项及以上的数，并且交换位置。</span></span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">else</span></span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            arr[end+shell] = temp;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="归并排序"><a href="#归并排序" class="headerlink" title="归并排序"></a>归并排序</h2><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">msort</span><span class="params">(<span class="type">int</span> l,  <span class="type">int</span> r)</span></span></span><br><span class="line"><span class="function"><span class="comment">//归并排序，基本思想：左端点指针与右端点指针，将其从中间分割，对左半部分进行递归，右半部分进行递归，</span></span></span><br><span class="line"><span class="function"><span class="comment">//然后从头分别遍历左半部分与右半部分，哪边小就把哪边的数追加到新的数组之中，如果左右半边数组有没有被遍历到的情况，则直接将后面的元素全部追加到新数组后面；</span></span></span><br><span class="line"><span class="function"><span class="comment">//最后通过新的已经排好的数组更新原来的数组，</span></span></span><br><span class="line"><span class="function"><span class="comment">//递归，后面由边界到抽象，逐渐合并为一个已经排好的数组。</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (l == r)  <span class="keyword">return</span>;</span><br><span class="line">    <span class="type">int</span> m = (l + r) / <span class="number">2</span>;</span><br><span class="line">    <span class="built_in">msort</span>(l, m);<span class="comment">//对左半部分递归</span></span><br><span class="line">    <span class="built_in">msort</span>(m + <span class="number">1</span>, r);<span class="comment">//对右半部分递归</span></span><br><span class="line">    <span class="built_in">merge</span>(l, m, r); <span class="comment">//合并数组</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">merge</span><span class="params">(<span class="type">int</span> l, <span class="type">int</span> m, <span class="type">int</span> r)</span><span class="comment">//合并数组</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="type">int</span> i = l, j = m + <span class="number">1</span>,k=l;</span><br><span class="line">    <span class="keyword">while</span> (i &lt;= m &amp;&amp; j &lt;= r)<span class="comment">//从头遍历数组的左半部分和右半部分，哪边小就把哪边的数组加到新数组中</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span> (arr[i] &gt; arr[j])</span><br><span class="line">            arr1[k++] = arr[j++];</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">            arr1[k++] = arr[i++];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//后面是考虑左右半边数组有没被遍历到的情况，如果有就直接添加到新数组后面</span></span><br><span class="line">    <span class="keyword">while</span> (i &lt;= m)</span><br><span class="line">        arr1[k++] = arr[i++];</span><br><span class="line">    <span class="keyword">while</span> (j &lt;= r)</span><br><span class="line">        arr1[k++] = arr[j++];</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = l; i &lt;= r; i++)<span class="comment">//将已经排好的数组重新添加到原数组中</span></span><br><span class="line">        arr[i] = arr1[i];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="插入排序"><a href="#插入排序" class="headerlink" title="插入排序"></a>插入排序</h2><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">insertsort</span><span class="params">(<span class="type">int</span> a[],<span class="type">int</span> n)</span></span></span><br><span class="line"><span class="function"><span class="comment">//插入排序，基本思想：左半部分为有序区，右半部分为无序区，从有序区右端依次向左与无序区第一个值进行比较，</span></span></span><br><span class="line"><span class="function"><span class="comment">//如果比这个值大，则该值向右移，如果比这个值小，则插入这个值的右端，合并为新的有序区</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt; n; i++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="type">int</span> now = a[i];</span><br><span class="line">        <span class="type">int</span> j;</span><br><span class="line">        <span class="keyword">for</span> (j = i - <span class="number">1</span>; j &gt;= <span class="number">0</span>; j--)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span> (now &lt; a[j]) a[j + <span class="number">1</span>] = a[j];<span class="comment">//若a[j]大于now，则往前移，直到不大于</span></span><br><span class="line">            <span class="keyword">else</span></span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        a[j + <span class="number">1</span>] = now;<span class="comment">//因为j--，所以这里是j+1；</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="快速排序"><a href="#快速排序" class="headerlink" title="快速排序"></a>快速排序</h2><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">quicksort</span><span class="params">(<span class="type">int</span> a[], <span class="type">int</span> l, <span class="type">int</span> r)</span></span></span><br><span class="line"><span class="function"><span class="comment">//快速排序:基本思想为找到一个“哨兵”值，起始端和终止端各有一个指针i，j，</span></span></span><br><span class="line"><span class="function"><span class="comment">//如果指针i指向的值大于哨兵值，j指向的值小于哨兵值，则进行交换，直到左半部分的值全部小于哨兵值，右半部分的值全部大于哨兵值，然后对左右半部分进行递归，最后可以排序成功</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="type">int</span> i = l, j = r, tag = a[(l + r) / <span class="number">2</span>],temp;</span><br><span class="line">    <span class="keyword">do</span> &#123;</span><br><span class="line">        <span class="keyword">while</span> (a[i] &lt; tag) i++;</span><br><span class="line">        <span class="keyword">while</span> (a[j] &gt; tag) j--;</span><br><span class="line">        <span class="keyword">if</span> (i &lt;= j)</span><br><span class="line">        &#123;</span><br><span class="line">            temp = a[i];</span><br><span class="line">            a[i] = a[j];</span><br><span class="line">            a[j] = temp;</span><br><span class="line">            i++; j--;<span class="comment">//交换值，并且将两端指针各往前挪一格，方便之后继续进行交换操作</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125; <span class="keyword">while</span> (i &lt;= j);</span><br><span class="line">    <span class="keyword">if</span> (l &lt; j) <span class="built_in">quicksort</span>(a, l, j);<span class="comment">//左半部分进行递归</span></span><br><span class="line">    <span class="keyword">if</span> (r &gt; i) <span class="built_in">quicksort</span>(a, i, r);<span class="comment">//右半部分进行递归</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="基数排序"><a href="#基数排序" class="headerlink" title="基数排序"></a>基数排序</h2><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">int</span> <span class="title">maxbit</span><span class="params">(<span class="type">int</span> data[], <span class="type">int</span> n)</span> </span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="type">int</span> maxData = data[<span class="number">0</span>];             </span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt; n; ++i)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span> (maxData &lt; data[i])</span><br><span class="line">            maxData = data[i];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="type">int</span> d = <span class="number">1</span>;</span><br><span class="line">    <span class="type">int</span> p = <span class="number">10</span>;</span><br><span class="line">    <span class="keyword">while</span> (maxData &gt;= p)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="comment">//p *= 10; // Maybe overflow</span></span><br><span class="line">        maxData /= <span class="number">10</span>;</span><br><span class="line">        ++d;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> d;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">radixsort</span><span class="params">(<span class="type">int</span> data[], <span class="type">int</span> n)</span> </span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="type">int</span> d = <span class="built_in">maxbit</span>(data, n);</span><br><span class="line">    <span class="type">int</span> *tmp = <span class="keyword">new</span> <span class="type">int</span>[n];</span><br><span class="line">    <span class="type">int</span> *count = <span class="keyword">new</span> <span class="type">int</span>[<span class="number">10</span>]; </span><br><span class="line">    <span class="type">int</span> i, j, k;</span><br><span class="line">    <span class="type">int</span> radix = <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">for</span>(i = <span class="number">1</span>; i &lt;= d; i++) </span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">for</span>(j = <span class="number">0</span>; j &lt; <span class="number">10</span>; j++)</span><br><span class="line">            count[j] = <span class="number">0</span>; </span><br><span class="line">        <span class="keyword">for</span>(j = <span class="number">0</span>; j &lt; n; j++)</span><br><span class="line">        &#123;</span><br><span class="line">            k = (data[j] / radix) % <span class="number">10</span>; </span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span>(j = <span class="number">1</span>; j &lt; <span class="number">10</span>; j++)</span><br><span class="line">            count[j] = count[j - <span class="number">1</span>] + count[j]; </span><br><span class="line">        <span class="keyword">for</span>(j = n - <span class="number">1</span>; j &gt;= <span class="number">0</span>; j--) </span><br><span class="line">        &#123;</span><br><span class="line">            k = (data[j] / radix) % <span class="number">10</span>;</span><br><span class="line">            tmp[count[k] - <span class="number">1</span>] = data[j];</span><br><span class="line">            count[k]--;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span>(j = <span class="number">0</span>; j &lt; n; j++)</span><br><span class="line">            data[j] = tmp[j];</span><br><span class="line">        radix = radix * <span class="number">10</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">delete</span> []tmp;</span><br><span class="line">    <span class="keyword">delete</span> []count;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="堆排序"><a href="#堆排序" class="headerlink" title="堆排序"></a>堆排序</h2><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">max_heapify</span><span class="params">(<span class="type">int</span> arr[], <span class="type">int</span> start, <span class="type">int</span> end)</span> </span>&#123;</span><br><span class="line">    <span class="type">int</span> dad = start;</span><br><span class="line">    <span class="type">int</span> son = dad * <span class="number">2</span> + <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">while</span> (son &lt;= end) &#123;</span><br><span class="line">        <span class="keyword">if</span> (son + <span class="number">1</span> &lt;= end &amp;&amp; arr[son] &lt; arr[son + <span class="number">1</span>])</span><br><span class="line">            son++;</span><br><span class="line">        <span class="keyword">if</span> (arr[dad] &gt; arr[son])</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="built_in">swap</span>(arr[dad], arr[son]);</span><br><span class="line">            dad = son;</span><br><span class="line">            son = dad * <span class="number">2</span> + <span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">heap_sort</span><span class="params">(<span class="type">int</span> arr[], <span class="type">int</span> len)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = len / <span class="number">2</span> - <span class="number">1</span>; i &gt;= <span class="number">0</span>; i--)</span><br><span class="line">        <span class="built_in">max_heapify</span>(arr, i, len - <span class="number">1</span>);</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = len - <span class="number">1</span>; i &gt; <span class="number">0</span>; i--) &#123;</span><br><span class="line">        <span class="built_in">swap</span>(arr[<span class="number">0</span>], arr[i]);</span><br><span class="line">        <span class="built_in">max_heapify</span>(arr, <span class="number">0</span>, i - <span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>另外还有桶排序，这里就不列举了。</p>
<h1 id="差分与前缀和"><a href="#差分与前缀和" class="headerlink" title="差分与前缀和"></a>差分与前缀和</h1><p>差分与前缀和是相对的，差分的本质就是前缀和的逆运算，相比前缀和要抽象一点，这里不详细介绍前缀和</p>
<p>对于一个一维数组a，其差分数组b，两者关系有：</p>
<p>$ b[n]&#x3D;a[n]-a[n-1]; $</p>
<p>对于一个二维数组a，其差分矩阵b，两者关系有：</p>
<p>$ b[i][j] &#x3D; a[i][j] - a[i][j-1] - a[i-1][j] + a[i-1][j-1]; $</p>
<p>实现An中从$(x1,y1)$到$(x2,y2)$子矩阵同时加上或者减去常数C<br>通过对差分矩阵元素的的改变进而改变前缀和矩阵元素的值，代码实现形式：</p>
<p>$ b[x1][y1] +&#x3D; c; $</p>
<p>$ b[x1][y2+1] -&#x3D; c; $</p>
<p>$ b[x2+1][y1] -&#x3D; c; $</p>
<p>$ b[x2+1][y2+1] +&#x3D; c; $</p>
<p>对于一维数组a，其有差分数组b，若想在一维数组 a  l  到  r 这个区间加上c，则对于差分数组b有：</p>
<p>$ b[l] +&#x3D; c; $<br>$ b[r+1] -&#x3D; c; $</p>
<p><a target="_blank" rel="noopener" href="https://www.luogu.com.cn/problem/P3397">https://www.luogu.com.cn/problem/P3397</a></p>
<h1 id="高精度算法"><a href="#高精度算法" class="headerlink" title="高精度算法"></a>高精度算法</h1><h2 id="高精加"><a href="#高精加" class="headerlink" title="高精加"></a>高精加</h2><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;tuple&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> LL long long</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> MAX 100000</span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="type">int</span> a[MAX], b[MAX], c[MAX]&#123; <span class="number">0</span> &#125;;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">        string num1, num2;</span><br><span class="line">        cin &gt;&gt; num1 &gt;&gt; num2;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = num1.<span class="built_in">size</span>()<span class="number">-1</span>,j=<span class="number">0</span>; i &gt;=<span class="number">0</span> ; i--,j++)</span><br><span class="line">            a[j] = num1[i] - <span class="string">&#x27;0&#x27;</span>;</span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span> i = num2.<span class="built_in">size</span>()<span class="number">-1</span>,j=<span class="number">0</span>; i &gt;=<span class="number">0</span> ; i--,j++)</span><br><span class="line">            b[j] = num2[i] - <span class="string">&#x27;0&#x27;</span>;</span><br><span class="line">        <span class="type">int</span> max = num1.<span class="built_in">size</span>() &gt; num2.<span class="built_in">size</span>() ? num1.<span class="built_in">size</span>() : num2.<span class="built_in">size</span>();</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; max; i++)</span><br><span class="line">        &#123;</span><br><span class="line">            c[i] += a[i] + b[i];</span><br><span class="line">            c[i + <span class="number">1</span>] = c[i] / <span class="number">10</span>;</span><br><span class="line">            c[i] %= <span class="number">10</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        max--;</span><br><span class="line">        <span class="keyword">while</span> (c[max+<span class="number">1</span>])</span><br><span class="line">        &#123;</span><br><span class="line">            max++;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = max; i &gt;=<span class="number">0</span>; i--)</span><br><span class="line">            cout &lt;&lt; c[i];</span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="高精乘"><a href="#高精乘" class="headerlink" title="高精乘"></a>高精乘</h2><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;tuple&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> LL long long</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> MAX 100000</span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="type">int</span> a[MAX], b[MAX], c[MAX]&#123; <span class="number">0</span> &#125;;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">            string num1, num2;</span><br><span class="line">            cin &gt;&gt; num1 &gt;&gt; num2;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = num1.<span class="built_in">size</span>()<span class="number">-1</span>,j=<span class="number">1</span>; i &gt;=<span class="number">0</span> ; i--,j++)</span><br><span class="line">            a[j] = num1[i] - <span class="string">&#x27;0&#x27;</span>;</span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span> i = num2.<span class="built_in">size</span>()<span class="number">-1</span>,j=<span class="number">1</span>; i &gt;=<span class="number">0</span> ; i--,j++)</span><br><span class="line">            b[j] = num2[i] - <span class="string">&#x27;0&#x27;</span>;</span><br><span class="line">            <span class="type">int</span> max = num1.<span class="built_in">size</span>() &gt; num2.<span class="built_in">size</span>() ? num1.<span class="built_in">size</span>() : num2.<span class="built_in">size</span>();</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt;= num1.<span class="built_in">size</span>(); i++)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span> j = <span class="number">1</span>; j &lt;= num2.<span class="built_in">size</span>(); j++)</span><br><span class="line">            &#123;</span><br><span class="line">                c[j + i - <span class="number">1</span>] += a[i] * b[j];</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="type">int</span> len = num1.<span class="built_in">size</span>() + num2.<span class="built_in">size</span>();</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt;= len; i++)</span><br><span class="line">        &#123;</span><br><span class="line">            c[i + <span class="number">1</span>] += c[i] / <span class="number">10</span>;</span><br><span class="line">            c[i] %= <span class="number">10</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="type">int</span> cnt = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt;= len; i++)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span> (c[i] == <span class="number">0</span>)</span><br><span class="line">                cnt++;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (cnt == len) cout &lt;&lt; <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">while</span> (!c[len]) len--;</span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span> i = len; i &gt;= <span class="number">1</span>; i--)</span><br><span class="line">                cout &lt;&lt; c[i];</span><br><span class="line">            &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h1 id="枚举"><a href="#枚举" class="headerlink" title="枚举"></a>枚举</h1><h2 id="二进制枚举"><a href="#二进制枚举" class="headerlink" title="二进制枚举"></a>二进制枚举</h2><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="type">int</span> n;</span><br><span class="line">    cin &gt;&gt; n;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">0</span>; i &lt; (<span class="number">1</span>&lt;&lt;n); i++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> j = <span class="number">0</span>; j &lt; n; j++) </span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span>(i &amp; (<span class="number">1</span> &lt;&lt; j))</span><br><span class="line"></span><br><span class="line">               cout&lt;&lt;j;</span><br><span class="line"></span><br><span class="line">        &#125;</span><br><span class="line">        cout&lt;&lt;endl;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h1 id="动态规划"><a href="#动态规划" class="headerlink" title="动态规划"></a>动态规划</h1><h2 id="背包dp"><a href="#背包dp" class="headerlink" title="背包dp"></a>背包dp</h2><h3 id="01背包"><a href="#01背包" class="headerlink" title="01背包"></a>01背包</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"> <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">1</span>; i &lt;= n; i++) </span><br><span class="line">     <span class="keyword">for</span>(<span class="type">int</span> j = <span class="number">1</span>; j &lt;= m; j++)</span><br><span class="line">         <span class="keyword">if</span>(j &lt; v[i]) </span><br><span class="line">             f[i][j] = f[i - <span class="number">1</span>][j];</span><br><span class="line">         <span class="keyword">else</span>    </span><br><span class="line">             f[i][j] = <span class="built_in">max</span>(f[i - <span class="number">1</span>][j], f[i - <span class="number">1</span>][j - v[i]] + w[i]);</span><br><span class="line">             </span><br><span class="line">               </span><br><span class="line"><span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">1</span>; i &lt;= n; i++)</span><br><span class="line">     <span class="keyword">for</span>(<span class="type">int</span> j = m; j &gt;= v; j--)</span><br><span class="line">         f[j] = <span class="built_in">max</span>(f[j], f[j - v] + w);                                                                                                                                          </span><br><span class="line">                                                           </span><br></pre></td></tr></table></figure>

<h3 id="完全背包"><a href="#完全背包" class="headerlink" title="完全背包"></a>完全背包</h3><p>可以无限拿取背包内的东西</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">1</span> ; i &lt;= n ; i++)</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> j = <span class="number">0</span> ; j &lt;= m ; j ++)</span><br><span class="line">        &#123;</span><br><span class="line">           f[i][j] = f[i<span class="number">-1</span>][j];</span><br><span class="line">                 <span class="keyword">if</span>(j-v[i]&gt;=<span class="number">0</span>)</span><br><span class="line">           f[i][j] = <span class="built_in">max</span>(f[i][j],f[i<span class="number">-1</span>][j-v[i]]+w[i]);</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">         </span><br><span class="line"><span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">1</span> ; i&lt;=n ;i++)</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> j = v[i] ; j&lt;=m ;j++)<span class="comment">//注意了，这里的j是从小到大枚举，和01背包不一样</span></span><br><span class="line">    &#123;</span><br><span class="line">            f[j] = <span class="built_in">max</span>(f[j],f[j-v[i]]+w[i]);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h3 id="多重背包"><a href="#多重背包" class="headerlink" title="多重背包"></a>多重背包</h3><p>将背包拆出来，然后转化成01背包问题即可</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">   ll n,m;</span><br><span class="line">ll cnt=<span class="number">1</span>;</span><br><span class="line">ll a,b,c;</span><br><span class="line"><span class="keyword">for</span>(ll i=<span class="number">1</span>;i&lt;=n;i++)</span><br><span class="line">&#123;</span><br><span class="line">    cin&gt;&gt;a&gt;&gt;b&gt;&gt;c;</span><br><span class="line">    <span class="keyword">for</span>(ll j=<span class="number">1</span>;j&lt;=c;j++)</span><br><span class="line">    &#123;</span><br><span class="line">        v[cnt]=a;</span><br><span class="line">        w[cnt]=b;</span><br><span class="line">        cnt++;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">for</span>(ll i=<span class="number">1</span>;i&lt;=cnt;i++)</span><br><span class="line">    <span class="keyword">for</span>(ll j=m;j&gt;=v[i];j--)</span><br><span class="line">        f[j]=<span class="built_in">max</span>(f[j],f[j-v[i]]+w[i]);</span><br></pre></td></tr></table></figure>
<p>如果数据范围较大可能会导致超时，此时需要进行优化</p>
<h4 id="二进制优化"><a href="#二进制优化" class="headerlink" title="二进制优化"></a>二进制优化</h4><p>如果不采用动态规划的做法, 就像普通的遍历问题那样, 是否采用二进制的计数方法对时间复杂度的优化没有任何关系。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt;= n; i ++)</span><br><span class="line">   &#123;</span><br><span class="line">       <span class="type">int</span> a, b, s;</span><br><span class="line">       <span class="type">int</span> k = <span class="number">1</span>; </span><br><span class="line">       <span class="keyword">while</span> (k &lt;= s)</span><br><span class="line">       &#123;</span><br><span class="line">           cnt ++;</span><br><span class="line">           v[cnt] = a * k; </span><br><span class="line">           w[cnt] = b * k; </span><br><span class="line">           s -= k;</span><br><span class="line">           k *= <span class="number">2</span>;  </span><br><span class="line">       &#125;</span><br><span class="line">       <span class="keyword">if</span> (s &gt; <span class="number">0</span>)   </span><br><span class="line">       &#123;</span><br><span class="line">           cnt ++;</span><br><span class="line">           v[cnt] = a * s;</span><br><span class="line">           w[cnt] = b * s;</span><br><span class="line">       &#125;</span><br><span class="line">   &#125;</span><br><span class="line"></span><br><span class="line">   n = cnt;  </span><br><span class="line"></span><br></pre></td></tr></table></figure>
<h3 id="混合背包"><a href="#混合背包" class="headerlink" title="混合背包"></a>混合背包</h3><p>就是将上面三种混合起来，没什么好说的</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span> (循环物品种类) &#123;</span><br><span class="line">  <span class="keyword">if</span> (是 <span class="number">0</span> - <span class="number">1</span> 背包)</span><br><span class="line">     <span class="number">0</span> - <span class="number">1</span> 背包代码;</span><br><span class="line">  <span class="keyword">else</span> <span class="keyword">if</span> (是完全背包)</span><br><span class="line">    完全背包代码;</span><br><span class="line">  <span class="keyword">else</span> <span class="keyword">if</span> (是多重背包)</span><br><span class="line">    多重背包代码;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="分组背包"><a href="#分组背包" class="headerlink" title="分组背包"></a>分组背包</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=n;i++)&#123;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> j=<span class="number">0</span>;j&lt;=m;j++)&#123;</span><br><span class="line">            f[i][j]=f[i<span class="number">-1</span>][j]; </span><br><span class="line">            <span class="keyword">for</span>(<span class="type">int</span> k=<span class="number">0</span>;k&lt;s[i];k++)&#123;</span><br><span class="line">                <span class="keyword">if</span>(j&gt;=v[i][k])     f[i][j]=<span class="built_in">max</span>(f[i][j],f[i<span class="number">-1</span>][j-v[i][k]]+w[i][k]);  </span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">     &#125;</span><br></pre></td></tr></table></figure>
<h3 id="单调队列优化"><a href="#单调队列优化" class="headerlink" title="单调队列优化"></a>单调队列优化</h3><p>因为单调队列的单调性，所以我们可以用它来进行降低DP维数，进行时间和空间的优化。<br>这里以优化多重背包问题为例，<br>转移只会发生在「对当前物品体积取余相同」的状态之间。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">     </span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> j = <span class="number">0</span>; j &lt; vi; j++) &#123;</span><br><span class="line">    <span class="type">int</span> head = <span class="number">0</span>, tail = <span class="number">-1</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> k = j; k &lt;= C; k+=vi) &#123;</span><br><span class="line">        dp[k] = g[k];</span><br><span class="line">        <span class="comment">// 将不在窗口范围内的值弹出</span></span><br><span class="line">        <span class="keyword">if</span> (head &lt;= tail &amp;&amp; q[head] &lt; k - si * vi) head++;</span><br><span class="line">        <span class="comment">// 如果队列中存在元素，直接使用队头来更新</span></span><br><span class="line">        <span class="keyword">if</span> (head &lt;= tail) dp[k] = <span class="built_in">max</span>(dp[k], g[q[head]] + (k - q[head]) / vi * wi);</span><br><span class="line">        <span class="comment">// 当前值比对尾值更优，队尾元素没有存在必要，队尾出队</span></span><br><span class="line">        <span class="keyword">while</span> (head &lt;= tail &amp;&amp; g[q[tail]] - (q[tail] - j) / vi * wi &lt;= g[k] - (k - j) / vi * wi) tail--;</span><br><span class="line">        <span class="comment">// 将新下标入队 </span></span><br><span class="line">        q[++tail] = k;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="区间dp"><a href="#区间dp" class="headerlink" title="区间dp"></a>区间dp</h2><p>就是对区间进行动态规划<br>P1880 [NOI1995] 石子合并 - 洛谷 </p>
<p>这题汇总了对于区间dp，求最大值，最小值以及形成一个圈的所有情况。<br>其中$dp[j][j+i]$代表，以j为起点，j+i为终点，区间的最优解情况<br>状态转移方程：</p>
<p> $ dp1[j][j+i]&#x3D;min&#x2F;max(dp1[j][j+i],dp1[j][k]+dp1[k+1][j+i]+s[j+i]-s[j-1]); $</p>
<p>$ s[j+i]-s[j-1] $代表j到j+i这个区间的所有元素的和，之所以要加上区间所有元素的和，是因为单纯将$ dp1[j][k]，dp1[k+1][j+i] $相加，其实少加了一次j到j+i这个区间的所有元素的。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="type">int</span> dp1[<span class="number">501</span>][<span class="number">501</span>],dp2[<span class="number">501</span>][<span class="number">501</span>],n,a[<span class="number">501</span>],s[<span class="number">501</span>];</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    std::ios::<span class="built_in">sync_with_stdio</span>(<span class="literal">false</span>);</span><br><span class="line">    cin.<span class="built_in">tie</span>(<span class="number">0</span>);</span><br><span class="line">    cin&gt;&gt;n;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=n;i++)&#123;</span><br><span class="line">        cin&gt;&gt;a[i];</span><br><span class="line">        a[n+i]=a[i];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">memset</span>(dp1,<span class="number">127</span>,<span class="built_in">sizeof</span>(dp1));</span><br><span class="line">    <span class="built_in">memset</span>(dp2,<span class="number">0</span>,<span class="built_in">sizeof</span>(dp2));</span><br><span class="line">    n*=<span class="number">2</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=n;i++)</span><br><span class="line">        s[i]=s[i<span class="number">-1</span>]+a[i];</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=n;i++)&#123;</span><br><span class="line">        dp1[i][i]=<span class="number">0</span>;</span><br><span class="line">        dp2[i][i]=<span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;n;i++)</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> j=<span class="number">1</span>;j&lt;n-i;j++)</span><br><span class="line">            <span class="keyword">for</span>(<span class="type">int</span> k=j;k&lt;j+i;k++)&#123;</span><br><span class="line">                dp1[j][j+i]=<span class="built_in">min</span>(dp1[j][j+i],dp1[j][k]+dp1[k+<span class="number">1</span>][j+i]+s[j+i]-s[j<span class="number">-1</span>]);</span><br><span class="line">                dp2[j][j+i]=<span class="built_in">max</span>(dp2[j][j+i],dp2[j][k]+dp2[k+<span class="number">1</span>][j+i]+s[j+i]-s[j<span class="number">-1</span>]);</span><br><span class="line">            &#125;</span><br><span class="line">    <span class="type">int</span> ans1=<span class="number">1</span>&lt;&lt;<span class="number">30</span>,ans2=<span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=n;i++)&#123;</span><br><span class="line">        ans1=<span class="built_in">min</span>(ans1,dp1[i][i+n/<span class="number">2</span><span class="number">-1</span>]);</span><br><span class="line">        ans2=<span class="built_in">max</span>(ans2,dp2[i][i+n/<span class="number">2</span><span class="number">-1</span>]);</span><br><span class="line">    &#125;</span><br><span class="line">    cout&lt;&lt;ans1&lt;&lt;endl;</span><br><span class="line">    cout&lt;&lt;ans2&lt;&lt;endl;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="树形dp"><a href="#树形dp" class="headerlink" title="树形dp"></a>树形dp</h2><p>P1352 没有上司的舞会 - 洛谷 </p>
<p>wls的板子，本题比起wls的题目，就是多了个·查找根节点的操作，其余的都是一样的，树形dp说白了就是在树结构在上进行dp，此时就需要遍历树（使用dfs或者bfs），wls的建链表（链式向前星）挺巧妙的，可以学学；</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="type">const</span> <span class="type">int</span> MAX = <span class="number">200005</span>;</span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">Node</span> &#123;</span><br><span class="line">	Node* next;</span><br><span class="line">	<span class="type">int</span> Where;</span><br><span class="line">&#125;* f[MAX],a[MAX];</span><br><span class="line"><span class="type">int</span> v[MAX], n, l;</span><br><span class="line"><span class="type">int</span> vis[MAX];</span><br><span class="line"><span class="type">long</span> <span class="type">long</span> dp[MAX][<span class="number">2</span>];</span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="type">void</span> <span class="title">makelist</span><span class="params">(<span class="type">int</span> x, <span class="type">int</span> y)</span> </span>&#123;<span class="comment">//起点，终点</span></span><br><span class="line">	a[++l].Where = y;</span><br><span class="line">	a[l].next = f[x];</span><br><span class="line">	f[x] = &amp;a[l];</span><br><span class="line">	vis[y] = <span class="number">1</span>;</span><br><span class="line">&#125; </span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="type">void</span> <span class="title">solve</span><span class="params">(<span class="type">int</span> d)</span> </span>&#123;</span><br><span class="line">	dp[d][<span class="number">1</span>] = v[d];</span><br><span class="line">	<span class="keyword">for</span> (Node* x=f[d]; x; x = x-&gt;next) &#123;</span><br><span class="line">		<span class="built_in">solve</span>(x-&gt;Where);</span><br><span class="line">		dp[d][<span class="number">0</span>] += <span class="built_in">max</span>(dp[x-&gt;Where][<span class="number">0</span>], dp[x-&gt;Where][<span class="number">1</span>]);</span><br><span class="line">		dp[d][<span class="number">1</span>] += dp[x-&gt;Where][<span class="number">0</span>];</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">	std::ios::<span class="built_in">sync_with_stdio</span>(<span class="literal">false</span>);</span><br><span class="line">	cin.<span class="built_in">tie</span>(<span class="number">0</span>);</span><br><span class="line">	cin &gt;&gt; n;</span><br><span class="line">	<span class="type">int</span> res = <span class="number">0</span>;</span><br><span class="line">	<span class="built_in">memset</span>(f, <span class="number">0</span>, <span class="built_in">sizeof</span>(f));</span><br><span class="line">	<span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt;= n; i++)</span><br><span class="line">		cin &gt;&gt; v[i];</span><br><span class="line">	<span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt;= n - <span class="number">1</span>; i++) &#123;</span><br><span class="line">		<span class="type">int</span> l,k; cin &gt;&gt; l&gt;&gt;k;</span><br><span class="line">		<span class="built_in">makelist</span>(k,l);</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="type">int</span> root; <span class="comment">//寻根，谁的入度为0谁就是根</span></span><br><span class="line">	<span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt;= n; i++) &#123;</span><br><span class="line">		<span class="keyword">if</span> (!vis[i]) &#123;</span><br><span class="line">			root = i;</span><br><span class="line">			<span class="keyword">break</span>;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="built_in">solve</span>(root);</span><br><span class="line">	cout &lt;&lt; <span class="built_in">max</span>(dp[root][<span class="number">1</span>],dp[root][<span class="number">0</span>]);</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="状压dp"><a href="#状压dp" class="headerlink" title="状压dp"></a>状压dp</h2><h2 id="数位dp"><a href="#数位dp" class="headerlink" title="数位dp"></a>数位dp</h2><h1 id="搜索"><a href="#搜索" class="headerlink" title="搜索"></a>搜索</h1><h2 id="DFS基本形式"><a href="#DFS基本形式" class="headerlink" title="DFS基本形式"></a>DFS基本形式</h2><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">基本模型</span></span><br><span class="line"><span class="comment">void dfs(int step)</span></span><br><span class="line"><span class="comment">&#123;</span></span><br><span class="line"><span class="comment">	if(所有空都填完了)&#123;</span></span><br><span class="line"><span class="comment">        判断最优解或者记录答案；</span></span><br><span class="line"><span class="comment">        return;</span></span><br><span class="line"><span class="comment">      &#123;</span></span><br><span class="line"><span class="comment">    for(枚举所有的情况)&#123;</span></span><br><span class="line"><span class="comment">        if(该选项是合法的)</span></span><br><span class="line"><span class="comment">           记录下这个空；</span></span><br><span class="line"><span class="comment">           dfs(step+1);</span></span><br><span class="line"><span class="comment">           取消这个空</span></span><br><span class="line"><span class="comment">        &#125;</span></span><br><span class="line"><span class="comment">&#125;              </span></span><br><span class="line"><span class="comment">*/</span></span><br></pre></td></tr></table></figure>
<h2 id="DFS基本运用：N皇后问题"><a href="#DFS基本运用：N皇后问题" class="headerlink" title="DFS基本运用：N皇后问题"></a>DFS基本运用：N皇后问题</h2><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="type">const</span> <span class="type">int</span> N = <span class="number">1000</span>;</span><br><span class="line"><span class="type">int</span> n,res;</span><br><span class="line"><span class="type">int</span> a[N], b[N], c[N];<span class="comment">//行，两个斜行，对于某一个点而言，</span></span><br><span class="line"><span class="comment">//其中一个斜行x+y固定，另一个行x-y固定；</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">dfs</span><span class="params">(<span class="type">int</span> step)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="keyword">if</span> (step &gt; n)</span><br><span class="line">	&#123;</span><br><span class="line">		res++;</span><br><span class="line">		<span class="keyword">return</span>;</span><br><span class="line"><span class="comment">//因为棋子已经摆完了，所以回溯到上一种情况继续摆放。</span></span><br><span class="line">	&#125;</span><br><span class="line"> </span><br><span class="line">	<span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt;= n; i++)</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="keyword">if</span> (a[i] == <span class="number">0</span> &amp;&amp; b[step + i] == <span class="number">0</span> &amp;&amp; c[step - i + <span class="number">20</span>] == <span class="number">0</span>)</span><br><span class="line">		&#123;</span><br><span class="line">			a[i] = <span class="number">1</span>; b[step + i] = <span class="number">1</span>; c[step - i + <span class="number">20</span>] = <span class="number">1</span>;</span><br><span class="line">			<span class="built_in">dfs</span>(step + <span class="number">1</span>);</span><br><span class="line">			a[i] = <span class="number">0</span>; b[step + i] = <span class="number">0</span>; c[step - i + <span class="number">20</span>] = <span class="number">0</span>;</span><br><span class="line"><span class="comment">//如果没有满足上述情况的位置放置，则恢复现场。</span></span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	cin &gt;&gt; n;</span><br><span class="line">	<span class="built_in">dfs</span>(<span class="number">1</span>);</span><br><span class="line">	cout &lt;&lt; res;</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h1 id="BFS基本形式"><a href="#BFS基本形式" class="headerlink" title="BFS基本形式"></a>BFS基本形式</h1><p>通常是与队列（queue）捆绑的。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">   Q.push(初始状态);</span></span><br><span class="line"><span class="comment">   while(!Q.empty())</span></span><br><span class="line"><span class="comment">   &#123;</span></span><br><span class="line"><span class="comment">     State  u  =Q.front();</span></span><br><span class="line"><span class="comment">	 Q.pop();</span></span><br><span class="line"><span class="comment">	 for(枚举所有的可能状态)</span></span><br><span class="line"><span class="comment">	    if(是合法的)</span></span><br><span class="line"><span class="comment">		   Q.push(v);</span></span><br><span class="line"><span class="comment">   &#125;</span></span><br><span class="line"><span class="comment">*/</span></span><br></pre></td></tr></table></figure>
<h2 id="BFS的基本应用："><a href="#BFS的基本应用：" class="headerlink" title="BFS的基本应用："></a>BFS的基本应用：</h2><p>P1443 马的遍历 - 洛谷 </p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="type">const</span> <span class="type">int</span> N = <span class="number">1000</span>;</span><br><span class="line"><span class="type">int</span> horse[<span class="number">8</span>][<span class="number">2</span>] = &#123;</span><br><span class="line">	&#123;<span class="number">1</span>,<span class="number">2</span>&#125;,&#123;<span class="number">2</span>,<span class="number">1</span>&#125;,&#123;<span class="number">-1</span>,<span class="number">2</span>&#125;,&#123;<span class="number">-2</span>,<span class="number">1</span>&#125;,&#123;<span class="number">-1</span>,<span class="number">-2</span>&#125;,&#123;<span class="number">-2</span>,<span class="number">-1</span>&#125;,&#123;<span class="number">1</span>,<span class="number">-2</span>&#125;,&#123;<span class="number">2</span>,<span class="number">-1</span>&#125;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="type">int</span> ans[N][N];</span><br><span class="line">queue&lt;pair&lt;<span class="type">int</span>, <span class="type">int</span>&gt;&gt; temp;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="built_in">memset</span>(ans, <span class="number">-1</span>, <span class="built_in">sizeof</span>(ans));</span><br><span class="line">	<span class="type">int</span> n, m, dx, dy;</span><br><span class="line">	cin &gt;&gt; n &gt;&gt; m &gt;&gt; dx &gt;&gt; dy;</span><br><span class="line">	ans[dx][dy] = <span class="number">0</span>;</span><br><span class="line">	temp.<span class="built_in">push</span>(&#123; dx,dy &#125;);</span><br><span class="line">	<span class="keyword">while</span> (!temp.<span class="built_in">empty</span>()) </span><br><span class="line">	&#123;</span><br><span class="line">		pair&lt;<span class="type">int</span>, <span class="type">int</span>&gt; Top = temp.<span class="built_in">front</span>();<span class="comment">//标记原点</span></span><br><span class="line">		temp.<span class="built_in">pop</span>();</span><br><span class="line">		<span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; <span class="number">8</span>; i++) &#123;</span><br><span class="line">			<span class="type">int</span> dx1 = Top.first + horse[i][<span class="number">0</span>];</span><br><span class="line">			<span class="type">int</span> dy1 = Top.second + horse[i][<span class="number">1</span>];</span><br><span class="line">			<span class="keyword">if</span> (dx1 &lt; <span class="number">1</span> || dx1 &gt; n || dy1 &lt; <span class="number">1</span> || dy1 &gt; m || ans[dx1][dy1] != <span class="number">-1</span>)</span><br><span class="line">				<span class="keyword">continue</span>;</span><br><span class="line">			<span class="type">int</span> temp1 = ans[Top.first][Top.second];<span class="comment">//继承原点的步数</span></span><br><span class="line">			ans[dx1][dy1] = temp1 + <span class="number">1</span>;</span><br><span class="line">			temp.<span class="built_in">push</span>(&#123; dx1,dy1 &#125;);</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt;= n; i++)</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="keyword">for</span> (<span class="type">int</span> j = <span class="number">1</span>; j &lt;= m; j++)</span><br><span class="line">			<span class="built_in">printf</span>(<span class="string">&quot;%-5d&quot;</span>, ans[i][j]);</span><br><span class="line">		<span class="built_in">printf</span>(<span class="string">&quot;\n&quot;</span>);</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h1 id="字符串算法"><a href="#字符串算法" class="headerlink" title="字符串算法"></a>字符串算法</h1><p>这里就不写暴力匹配了。</p>
<h2 id="KMP"><a href="#KMP" class="headerlink" title="KMP"></a>KMP</h2><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">const</span> <span class="type">int</span> N = <span class="number">1e5</span>;</span><br><span class="line"><span class="type">int</span> Next[N];</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">getNext</span><span class="params">(string b,<span class="type">int</span> next[])</span></span>&#123;<span class="comment">//取模式串的next数组</span></span><br><span class="line">    <span class="type">int</span> len = b.<span class="built_in">size</span>();</span><br><span class="line">    next[<span class="number">0</span>] = <span class="number">-1</span>;</span><br><span class="line">    <span class="type">int</span> k = <span class="number">-1</span>, j = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">while</span> (j &lt; len - <span class="number">1</span>) &#123;</span><br><span class="line">        <span class="keyword">if</span> (k == <span class="number">-1</span> || b[j] == b[k]) &#123;</span><br><span class="line">            k++;</span><br><span class="line">            j++;</span><br><span class="line">            <span class="keyword">if</span> (b[j] != b[k]) next[j] = k;</span><br><span class="line">            <span class="keyword">else</span></span><br><span class="line">                next[j] = next[k];</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> k = next[k];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">kmp_search</span><span class="params">(string a , string b)</span> </span>&#123;</span><br><span class="line">    <span class="type">int</span> i = <span class="number">0</span>, j = <span class="number">0</span>;</span><br><span class="line">    <span class="built_in">getNext</span>(b, Next);</span><br><span class="line">    <span class="keyword">while</span> (i &lt; a.<span class="built_in">size</span>()&amp;&amp;j&lt;b.<span class="built_in">size</span>()) &#123;</span><br><span class="line">        <span class="keyword">if</span> (j==<span class="number">-1</span>||a[i] == b[j]) i++, j++;</span><br><span class="line">        <span class="keyword">else</span>  j = Next[j];<span class="comment">//递归思想，将模式串下标返回Next[j]</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (j == b.<span class="built_in">size</span>()) </span><br><span class="line">        <span class="keyword">return</span> i - j;</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">        <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="EXkmp"><a href="#EXkmp" class="headerlink" title="EXkmp"></a>EXkmp</h2><p>$ next[i]： T[i]…T[m - 1] $与 T（模式串） 的最长相同前缀长度；</p>
<p>$ extend[i]： S[i]…S[n - 1] $ 与 T 的最长相同前缀长度。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">GetNext</span><span class="params">(string T, <span class="type">int</span> m, <span class="type">int</span> next[])</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="type">int</span> a = <span class="number">0</span>, p = <span class="number">0</span>;</span><br><span class="line">    next[<span class="number">0</span>] = m;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt; m; i++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span> (i &gt;= p || i + next[i - a] &gt;= p)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span> (i &gt;= p)</span><br><span class="line">                p = i;</span><br><span class="line">            <span class="keyword">while</span> (p &lt; m &amp;&amp; T[p] == T[p - i])</span><br><span class="line">                p++;</span><br><span class="line">            next[i] = p - i;</span><br><span class="line">            a = i;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">            next[i] = next[i - a];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">GetExtend</span><span class="params">(string S, <span class="type">int</span> n, string T, <span class="type">int</span> m, <span class="type">int</span> extend[], <span class="type">int</span> next[])</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="type">int</span> a = <span class="number">0</span>, p = <span class="number">0</span>;</span><br><span class="line">    <span class="built_in">GetNext</span>(T, m, next);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; n; i++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span> (i &gt;= p || i + next[i - a] &gt;= p) </span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span> (i &gt;= p)</span><br><span class="line">                p = i;</span><br><span class="line">            <span class="keyword">while</span> (p &lt; n &amp;&amp; p - i &lt; m &amp;&amp; S[p] == T[p - i])</span><br><span class="line">                p++;</span><br><span class="line">            extend[i] = p - i;</span><br><span class="line">            a = i;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">            extend[i] = next[i - a];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="BM算法"><a href="#BM算法" class="headerlink" title="BM算法"></a>BM算法</h2><p>bm可以看作进阶的kmp算法，效率相比kmp要高。<br>BM算法定义了两个规则：</p>
<p><em><strong>坏字符规则</strong></em>：当文本串中的某个字符跟模式串的某个字符不匹配时，我们称文本串中的这个失配字符为坏字符，此时模式串需要向右移动，移动的位数 &#x3D; 坏字符在模式串中的位置 - 坏字符在模式串中最右出现的位置。此外，如果”坏字符”不包含在模式串之中，则最右出现位置为-1。</p>
<p><em><strong>好后缀规则</strong></em>：当字符失配时，后移位数 &#x3D; 好后缀在模式串中的位置 - 好后缀在模式串上一次出现的位置，且如果好后缀在模式串中没有再次出现，则为-1。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">const</span> <span class="type">int</span> N = <span class="number">1e4</span>;</span><br><span class="line"><span class="type">int</span> BC[N],suffix[N],gs[N];</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">getBC</span><span class="params">(string pattern, <span class="type">int</span> bc[])</span> </span>&#123;<span class="comment">//BC表</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; <span class="number">256</span>; i++)</span><br><span class="line">        bc[i] = <span class="number">-1</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; pattern.<span class="built_in">size</span>(); i++)</span><br><span class="line">        bc[pattern[i]] = i;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">suffixes</span><span class="params">(string a, <span class="type">int</span> suffix[])</span> </span>&#123;<span class="comment">//构建suffix表，suffix[i] = s 表示以i为边界，与模式串后缀匹配的最大长度。</span></span><br><span class="line">    <span class="type">int</span> len = a.<span class="built_in">size</span>(),num;</span><br><span class="line">    suffix[len - <span class="number">1</span>] = len;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = len - <span class="number">2</span>; i &gt;= <span class="number">0</span>; i--) &#123;</span><br><span class="line">        <span class="keyword">for</span> (num = <span class="number">0</span>; num &lt;= i &amp;&amp; a[i - num] == a[len - num - <span class="number">1</span>]; num++)</span><br><span class="line">            suffix[i] = num;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">getGS</span><span class="params">(string a, <span class="type">int</span> gs[])</span> </span>&#123;<span class="comment">//构建gs表，记录了每次需要移动的距离。</span></span><br><span class="line">    <span class="type">int</span> len = a.<span class="built_in">size</span>(), lastindex = len - <span class="number">1</span>;</span><br><span class="line">    <span class="built_in">suffixes</span>(a, suffix);</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; len; i++)</span><br><span class="line">        gs[i] = len;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = lastindex; i &gt;= <span class="number">0</span>; i--) &#123;</span><br><span class="line">        <span class="keyword">if</span> (suffix[i] == i + <span class="number">1</span>) &#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span> j = <span class="number">0</span>; j &lt; lastindex - i; j++) &#123;</span><br><span class="line">                <span class="keyword">if</span> (gs[j] == len)</span><br><span class="line">                    gs[j] = lastindex - i;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; lastindex; i++) &#123;</span><br><span class="line">        gs[lastindex - suffix[i]] = lastindex - i;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">BMsearch</span><span class="params">(string a, string b )</span> </span>&#123;</span><br><span class="line">    <span class="built_in">memset</span>(BC, <span class="number">0</span>, N);</span><br><span class="line">    <span class="built_in">memset</span>(gs, <span class="number">0</span>, N);</span><br><span class="line">    <span class="built_in">getBC</span>(b,BC);</span><br><span class="line">    <span class="built_in">getGS</span>(b,gs);</span><br><span class="line">    <span class="type">int</span> ptr1 = <span class="number">0</span>, ptr2=<span class="number">0</span>;</span><br><span class="line">    <span class="type">int</span> len1 = a.<span class="built_in">size</span>(), len2 = b.<span class="built_in">size</span>(), maxIndex = b.<span class="built_in">size</span>() - <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">while</span> (ptr1 + len2 &lt;= len1) &#123;</span><br><span class="line">        <span class="keyword">for</span> (ptr2 = maxIndex; ptr2 &gt;= <span class="number">0</span> &amp;&amp; b[ptr2] == a[ptr1 + ptr2]; ptr2--);</span><br><span class="line">        <span class="keyword">if</span> (ptr2 == <span class="number">-1</span>) <span class="keyword">break</span>;</span><br><span class="line">        <span class="keyword">else</span> &#123;</span><br><span class="line">            ptr1 += <span class="built_in">max</span>(gs[ptr2], ptr2 - BC[a[ptr1 + ptr2]]);<span class="comment">//好后缀和怀字符规则，取移动数目较大的。</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> (ptr1 + len2 &lt;= len1) ? ptr1 : <span class="number">-1</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="最长回文子串"><a href="#最长回文子串" class="headerlink" title="最长回文子串"></a>最长回文子串</h2><h3 id="Manacher算法"><a href="#Manacher算法" class="headerlink" title="Manacher算法"></a>Manacher算法</h3><p>查找一个字符串的最长回文子串，这里使用了string，推荐还是用char数组，string操作比较耗时。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">string <span class="title">preProcess</span><span class="params">(string str)</span> </span>&#123;<span class="comment">//准备字符串</span></span><br><span class="line">	<span class="type">int</span> len = str.<span class="built_in">size</span>();</span><br><span class="line">	<span class="keyword">if</span> (len == <span class="number">0</span>) <span class="keyword">return</span> <span class="string">&quot;^$&quot;</span>;</span><br><span class="line">	string start = <span class="string">&quot;^&quot;</span>;</span><br><span class="line">	<span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; len; i++)</span><br><span class="line">		start =start + <span class="string">&quot;#&quot;</span> + str[i];</span><br><span class="line">	start += <span class="string">&quot;#$&quot;</span>;</span><br><span class="line">	<span class="keyword">return</span> start;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function">string <span class="title">manacher</span><span class="params">(string str)</span> </span>&#123;<span class="comment">//马拉车算法</span></span><br><span class="line">string str1 = <span class="built_in">preProcess</span>(str);</span><br><span class="line">	<span class="type">int</span> len = str1.<span class="built_in">size</span>();</span><br><span class="line">	<span class="type">int</span>* arr = <span class="keyword">new</span> <span class="type">int</span>[len];</span><br><span class="line">	<span class="type">int</span> C = <span class="number">0</span>, R = <span class="number">0</span>;</span><br><span class="line">	<span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt; len - <span class="number">1</span>; i++) &#123;</span><br><span class="line">		<span class="type">int</span> i_mirror = <span class="number">2</span> * C - i;</span><br><span class="line">		<span class="keyword">if</span> (R &gt; i) arr[i] = <span class="built_in">min</span>(R - i, arr[i_mirror]);<span class="comment">//防止超出R</span></span><br><span class="line">		<span class="keyword">else</span> arr[i] = <span class="number">0</span>;<span class="comment">//R=i的情况</span></span><br><span class="line">		<span class="keyword">while</span> (str1[i + <span class="number">1</span> + arr[i]] == str1[i - <span class="number">1</span> - arr[i]])                       arr[i]++;<span class="comment">//中心拓展</span></span><br><span class="line">		<span class="keyword">if</span> (i + arr[i] &gt; R) &#123;<span class="comment">//更新边界</span></span><br><span class="line">			C = i;</span><br><span class="line">			R = i + arr[i];</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="type">int</span> Max = <span class="number">0</span>, center = <span class="number">0</span>;</span><br><span class="line">	<span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt; len - <span class="number">1</span>; i++) &#123;</span><br><span class="line">		<span class="keyword">if</span> (arr[i] &gt; Max) &#123;</span><br><span class="line">			Max = arr[i];</span><br><span class="line">			center = i;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="type">int</span> start = (center - Max) / <span class="number">2</span>;</span><br><span class="line">	<span class="keyword">return</span> str.<span class="built_in">substr</span>(start,  Max);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>java代码，没事写一个</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">     <span class="keyword">public</span> <span class="keyword">static</span> String <span class="title function_">preString</span><span class="params">(String str)</span>&#123;</span><br><span class="line">        <span class="type">int</span> len=str.length();</span><br><span class="line">        <span class="keyword">if</span>(len==<span class="number">0</span>) <span class="keyword">return</span> <span class="string">&quot;^&amp;&quot;</span>;</span><br><span class="line">        String start=<span class="string">&quot;^&quot;</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;len;i++)</span><br><span class="line">            start=start+<span class="string">&quot;#&quot;</span>+str.charAt(i);</span><br><span class="line">        start+=<span class="string">&quot;#&amp;&quot;</span>;</span><br><span class="line">        <span class="keyword">return</span> start;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> String <span class="title function_">manacher</span><span class="params">(String str)</span>&#123;</span><br><span class="line">        String str1=preString(str);</span><br><span class="line">        <span class="type">int</span> len=str1.length();</span><br><span class="line">        <span class="type">int</span>[] arr=<span class="keyword">new</span> <span class="title class_">int</span>[len];</span><br><span class="line">        <span class="type">int</span> C=<span class="number">0</span>,R=<span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;len-<span class="number">1</span>;i++)&#123;</span><br><span class="line">            <span class="type">int</span> i_mirror=<span class="number">2</span>*C-i;</span><br><span class="line">           <span class="keyword">if</span>(R&gt;i) arr[i]=Math.min(arr[i_mirror],R-i);</span><br><span class="line">           <span class="keyword">else</span> arr[i]=<span class="number">0</span>;</span><br><span class="line">           <span class="keyword">while</span>(str1.charAt(i+<span class="number">1</span>+arr[i])==str1.charAt(i-<span class="number">1</span>-arr[i]))</span><br><span class="line">               arr[i]++;</span><br><span class="line">           <span class="keyword">if</span>(arr[i]+i&gt;R)&#123;</span><br><span class="line">               C=i;</span><br><span class="line">               R=i+arr[i];</span><br><span class="line">           &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="type">int</span> Max=<span class="number">0</span>,center=<span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;len-<span class="number">1</span>;i++)&#123;</span><br><span class="line">            <span class="keyword">if</span>(arr[i]&gt;Max) &#123;</span><br><span class="line">                Max = arr[i];</span><br><span class="line">                center = i;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="type">int</span> beg=(center-Max)/<span class="number">2</span>;</span><br><span class="line">        <span class="keyword">return</span> str.substring(beg,beg+Max);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">public</span> String <span class="title function_">longestPalindrome</span><span class="params">(String s)</span> &#123;</span><br><span class="line">            <span class="keyword">return</span> manacher(s);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="dp实现"><a href="#dp实现" class="headerlink" title="dp实现"></a>dp实现</h3><p>本质上就是枚举边界和长度，然后更新一下dp数组就好了</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line">       <span class="keyword">public</span> <span class="keyword">static</span> String <span class="title function_">dpSolve</span><span class="params">(String str)</span>&#123;</span><br><span class="line">        <span class="type">int</span> maxlen=<span class="number">1</span>,start=<span class="number">0</span>;</span><br><span class="line">        <span class="type">int</span> len=str.length();</span><br><span class="line">        <span class="type">boolean</span>[][] dp=<span class="keyword">new</span> <span class="title class_">boolean</span>[len][len];</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;len;i++)</span><br><span class="line">            dp[i][i]=<span class="literal">true</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> length=<span class="number">2</span>;length&lt;=len;length++) &#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; len; i++) &#123;</span><br><span class="line">                <span class="type">int</span> <span class="variable">j</span> <span class="operator">=</span> length + i - <span class="number">1</span>;</span><br><span class="line">                <span class="keyword">if</span>(j&gt;=len)</span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line">                <span class="keyword">if</span> (str.charAt(i) != str.charAt(j))</span><br><span class="line">                    dp[i][j] = <span class="literal">false</span>;</span><br><span class="line">                <span class="keyword">else</span> &#123;</span><br><span class="line">                    <span class="keyword">if</span> (j - i &lt; <span class="number">3</span>)</span><br><span class="line">                        dp[i][j] = <span class="literal">true</span>;</span><br><span class="line">                    <span class="keyword">else</span></span><br><span class="line">                        dp[i][j] = dp[i + <span class="number">1</span>][j - <span class="number">1</span>];</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">if</span> (dp[i][j] &amp;&amp; j - i + <span class="number">1</span> &gt; maxlen) &#123;</span><br><span class="line">                    maxlen = j - i + <span class="number">1</span>;</span><br><span class="line">                    start = i;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> str.substring(start,start+maxlen);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h1 id="数论"><a href="#数论" class="headerlink" title="数论"></a>数论</h1><h2 id="埃氏筛"><a href="#埃氏筛" class="headerlink" title="埃氏筛"></a>埃氏筛</h2><p>就是从质数2开始，其整数倍均不为质数，将区间内所有的2的倍数的下标，标记为false，代表不为质数，再从第二个质数开始，将其倍数标记为false，以此循环，最后留下来的都是质数。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">const</span> <span class="type">int</span> MAX = <span class="number">1e5</span>+<span class="number">1</span>;</span><br><span class="line"><span class="type">int</span> isPrime[MAX];</span><br><span class="line"><span class="type">int</span> Prime[MAX];</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">solve</span><span class="params">(<span class="type">int</span> n)</span> </span>&#123;</span><br><span class="line">	<span class="type">int</span> n,ptr=<span class="number">0</span>; cin &gt;&gt; n;</span><br><span class="line">	<span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt;= n; i++)</span><br><span class="line">		isPrime[i] = <span class="number">1</span>;</span><br><span class="line">	isPrime[<span class="number">0</span>] = isPrime[<span class="number">1</span>] = <span class="literal">false</span>;</span><br><span class="line">	<span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">2</span>; i &lt;= n; i++) &#123;</span><br><span class="line">		<span class="keyword">if</span> (isPrime[i]) &#123;</span><br><span class="line">			Prime[ptr++] = i;</span><br><span class="line">			<span class="keyword">for</span> (<span class="type">int</span> j = <span class="number">2</span> * i; j &lt;= n; j += i)</span><br><span class="line">				isPrime[j] = <span class="number">0</span>;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; ptr; i++)</span><br><span class="line">		cout &lt;&lt; Prime[i] &lt;&lt; endl;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="欧拉筛"><a href="#欧拉筛" class="headerlink" title="欧拉筛"></a>欧拉筛</h2><p>核心思想是让每一个合数被其最小质因数筛到<br>关键就在于  <em><strong>if(i%isprime[j]&#x3D;&#x3D;0)</strong></em></p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="type">const</span> <span class="type">int</span> Max = <span class="number">1e8</span> + <span class="number">5</span>;</span><br><span class="line"><span class="type">int</span> n, numPrime;</span><br><span class="line"><span class="type">int</span> prime[Max];</span><br><span class="line"><span class="type">bool</span> isPrime[Max];</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    std::ios::<span class="built_in">sync_with_stdio</span>(<span class="literal">false</span>);</span><br><span class="line">    cin.<span class="built_in">tie</span>(<span class="number">0</span>);</span><br><span class="line">    cin &gt;&gt; n;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">2</span>; i &lt;= n; i++) &#123;</span><br><span class="line">        <span class="keyword">if</span> (!isPrime[i])</span><br><span class="line">            prime[numPrime++] = i;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> j = <span class="number">0</span>; j &lt; numPrime; j++) &#123;</span><br><span class="line">            <span class="keyword">if</span> (i * prime[j] &gt; n)</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            isPrime[i * prime[j]] = <span class="literal">true</span>;</span><br><span class="line">            <span class="keyword">if</span> (i % prime[j] == <span class="number">0</span>)</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    cout &lt;&lt; numPrime;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h1 id="数据结构"><a href="#数据结构" class="headerlink" title="数据结构"></a>数据结构</h1><h2 id="单调栈"><a href="#单调栈" class="headerlink" title="单调栈"></a>单调栈</h2><p>保证栈中元素为单调递减或者递增的数据结构</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">stack&lt;<span class="type">int</span>&gt; S;</span><br><span class="line">	<span class="type">int</span> T; cin &gt;&gt; T;</span><br><span class="line">	<span class="keyword">while</span> (T--) &#123;</span><br><span class="line">		<span class="type">int</span> x; cin &gt;&gt; x;</span><br><span class="line">		<span class="keyword">while</span> (!S.<span class="built_in">empty</span>() &amp;&amp; S.<span class="built_in">top</span>() &gt; x)</span><br><span class="line">			S.<span class="built_in">pop</span>();</span><br><span class="line">		S.<span class="built_in">push</span>(x);</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">while</span> (!S.<span class="built_in">empty</span>()) &#123;</span><br><span class="line">		<span class="type">int</span> temp = S.<span class="built_in">top</span>();</span><br><span class="line">		S.<span class="built_in">pop</span>();</span><br><span class="line">		cout &lt;&lt; temp&lt;&lt;<span class="string">&quot; &quot;</span>;</span><br><span class="line">	&#125;</span><br></pre></td></tr></table></figure>
<p>模拟单调栈</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="type">unsigned</span> <span class="type">long</span> <span class="type">long</span> ull;</span><br><span class="line">ull n,top,ans,c[<span class="number">2000001</span>],s[<span class="number">2000001</span>];</span><br><span class="line"><span class="comment">//top 栈首</span></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>,&amp;n);</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=n;i++)</span><br><span class="line">        <span class="built_in">scanf</span>(<span class="string">&quot;%llu&quot;</span>,&amp;c[i]);</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=n;i++)&#123;</span><br><span class="line">        <span class="keyword">while</span>(top&amp;&amp;c[i]&gt;=c[s[top]])&#123;</span><br><span class="line">            ans^=s[top];</span><br><span class="line">            top--;</span><br><span class="line">        &#125;</span><br><span class="line">        ans^=i;</span><br><span class="line">        s[++top]=i;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;%llu\n&quot;</span>,ans);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="单调队列"><a href="#单调队列" class="headerlink" title="单调队列"></a>单调队列</h2><p>保证队列中的元素单调递增或者单调递减</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">deque&lt;<span class="type">int</span>&gt; Q; </span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; n; ++i)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">if</span> (!Q.<span class="built_in">empty</span>() &amp;&amp; i - Q.<span class="built_in">front</span>() &gt;= m)</span><br><span class="line">        Q.<span class="built_in">pop_front</span>();</span><br><span class="line">    <span class="keyword">while</span> (!Q.<span class="built_in">empty</span>() &amp;&amp; V[Q.<span class="built_in">back</span>()] &lt; V[i])</span><br><span class="line">        Q.<span class="built_in">pop_back</span>();</span><br><span class="line">    Q.<span class="built_in">push_back</span>(i); </span><br><span class="line">    <span class="keyword">if</span> (i &gt;= m - <span class="number">1</span>)</span><br><span class="line">        cout &lt;&lt; V[Q.<span class="built_in">front</span>()] &lt;&lt; <span class="string">&quot; &quot;</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>模拟单调队列</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line">ll a[MAX],q[MAX],front=<span class="number">1</span>,rear=<span class="number">0</span>;<span class="comment">//front队首，rear队尾 </span></span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=n;i++)</span><br><span class="line">    &#123;</span><br><span class="line">		<span class="keyword">while</span>(front&lt;=rear&amp;&amp;a[q[rear]]&gt;=a[i])</span><br><span class="line">			rear--;</span><br><span class="line">		q[++rear]=i;</span><br><span class="line">		<span class="keyword">if</span>(q[front]&lt;i-k+<span class="number">1</span>)</span><br><span class="line">			front++;</span><br><span class="line">		<span class="keyword">if</span>(i&gt;=k)</span><br><span class="line">		cout&lt;&lt;a[q[front]]&lt;&lt;<span class="string">&quot; &quot;</span>;</span><br><span class="line">	&#125;</span><br><span class="line">	cout&lt;&lt;endl;</span><br><span class="line">	</span><br><span class="line">	<span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=n;i++)&#123;</span><br><span class="line">		<span class="keyword">while</span>(front&lt;=rear&amp;&amp;a[q[rear]]&lt;=a[i])</span><br><span class="line">			rear--;</span><br><span class="line">		q[++rear]=i;</span><br><span class="line">		<span class="keyword">if</span>(q[front]&lt;i-k+<span class="number">1</span>)</span><br><span class="line">			front++;</span><br><span class="line">		<span class="keyword">if</span>(i&gt;=k)</span><br><span class="line">		cout&lt;&lt;a[q[front]]&lt;&lt;<span class="string">&quot; &quot;</span>;</span><br><span class="line">	&#125;</span><br></pre></td></tr></table></figure>
<h2 id="字典树"><a href="#字典树" class="headerlink" title="字典树"></a>字典树</h2><h3 id="数组存储"><a href="#数组存储" class="headerlink" title="数组存储"></a>数组存储</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="keyword">typedef</span> <span class="type">long</span> <span class="type">long</span> ll;</span><br><span class="line"><span class="comment">//Trie</span></span><br><span class="line"><span class="type">const</span> <span class="type">int</span> MAX = <span class="number">1e6</span> + <span class="number">10</span>;</span><br><span class="line"><span class="type">const</span> <span class="type">int</span> charsize = <span class="number">27</span>;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">//记录此节点的子节点编号（默认为小写字母）</span></span><br><span class="line"><span class="type">int</span> nxt[MAX][charsize];</span><br><span class="line"></span><br><span class="line"><span class="comment">//是否为终止节点</span></span><br><span class="line"><span class="type">bool</span> isend[MAX];</span><br><span class="line"></span><br><span class="line"><span class="comment">//cnt保存当前节点编号数</span></span><br><span class="line"><span class="type">int</span> root = <span class="number">0</span>, cnt = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">insert</span><span class="params">(<span class="type">char</span> s[], <span class="type">int</span> len)</span> </span>&#123;</span><br><span class="line">	<span class="type">int</span> now = <span class="number">0</span>;</span><br><span class="line">	<span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt;= len; i++) &#123;</span><br><span class="line">		<span class="type">int</span> x = s[i] - <span class="number">1</span>;</span><br><span class="line">		<span class="keyword">if</span> (!nxt[now][x])</span><br><span class="line">			nxt[now][x] = ++cnt;</span><br><span class="line">		now = nxt[now][x];</span><br><span class="line">	&#125;</span><br><span class="line">	isend[now] = <span class="number">1</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">bool</span> <span class="title">search</span><span class="params">(<span class="type">char</span> s[], <span class="type">int</span> len)</span> </span>&#123;</span><br><span class="line">	<span class="type">int</span> now = <span class="number">0</span>;</span><br><span class="line">	<span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt;= len; i++) &#123;</span><br><span class="line">		<span class="type">int</span> x = s[i] - <span class="string">&#x27;a&#x27;</span>;</span><br><span class="line">		<span class="keyword">if</span> (!nxt[now][x])</span><br><span class="line">			<span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">		now = nxt[now][x];</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> isend[now];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">	std::ios::<span class="built_in">sync_with_stdio</span>(<span class="literal">false</span>);</span><br><span class="line">	cin.<span class="built_in">tie</span>(<span class="number">0</span>); cout.<span class="built_in">tie</span>(<span class="number">0</span>);</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="结构体写法"><a href="#结构体写法" class="headerlink" title="结构体写法"></a>结构体写法</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//正常</span></span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">TreeNode1</span> &#123;</span><br><span class="line">	<span class="type">int</span> nxt[charsize];</span><br><span class="line">	<span class="type">bool</span> isend;</span><br><span class="line">&#125;tree1[MAX];</span><br><span class="line"></span><br><span class="line"><span class="comment">//字符集较大</span></span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">TreeNode2</span> &#123;</span><br><span class="line">	unordered_map&lt;<span class="type">char</span>, <span class="type">int</span>&gt; nxt_map;</span><br><span class="line">	<span class="type">bool</span> isend;</span><br><span class="line">&#125;tree2[MAX];</span><br><span class="line"></span><br><span class="line"><span class="comment">//指针写法</span></span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">TreeNode3</span> &#123;</span><br><span class="line">	TreeNode3* nxt[charsize];</span><br><span class="line">	<span class="type">bool</span> isend;</span><br><span class="line">&#125;tree3[MAX];<span class="comment">//insert search的操作思路类似，不写了。</span></span><br></pre></td></tr></table></figure>
<h3 id="统计前缀"><a href="#统计前缀" class="headerlink" title="统计前缀"></a>统计前缀</h3><p>把isend数组改成tol数组记录一下以某个位置为重点的字符串为前缀的数量就可以了。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="keyword">typedef</span> <span class="type">long</span> <span class="type">long</span> ll;</span><br><span class="line"><span class="type">const</span> <span class="type">int</span> charsize = <span class="number">70</span>;</span><br><span class="line"><span class="type">const</span> <span class="type">int</span> MAXN = <span class="number">3e6</span> + <span class="number">10</span>;</span><br><span class="line"><span class="type">int</span> nxt[MAXN][charsize],root,cnt;</span><br><span class="line"><span class="type">int</span> tol[MAXN];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">getnum</span><span class="params">(<span class="type">char</span> x)</span> </span>&#123;</span><br><span class="line">	<span class="keyword">if</span> (x &gt;= <span class="string">&#x27;A&#x27;</span> &amp;&amp; x &lt;= <span class="string">&#x27;Z&#x27;</span>)</span><br><span class="line">		<span class="keyword">return</span> x - <span class="string">&#x27;A&#x27;</span>;</span><br><span class="line">	<span class="keyword">else</span> <span class="keyword">if</span> (x &gt;= <span class="string">&#x27;a&#x27;</span> &amp;&amp; x &lt;= <span class="string">&#x27;z&#x27;</span>)</span><br><span class="line">		<span class="keyword">return</span> x - <span class="string">&#x27;a&#x27;</span> + <span class="number">26</span>;</span><br><span class="line">	<span class="keyword">else</span></span><br><span class="line">		<span class="keyword">return</span> x - <span class="string">&#x27;0&#x27;</span> + <span class="number">52</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">init</span><span class="params">(<span class="type">int</span> n)</span> </span>&#123;</span><br><span class="line">	<span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; n; i++) &#123;</span><br><span class="line">		<span class="keyword">for</span> (<span class="type">int</span> j = <span class="number">0</span>; j &lt; charsize; j++) &#123;</span><br><span class="line">			nxt[i][j] = <span class="number">0</span>;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; n; i++)</span><br><span class="line">		tol[i] = <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">	std::ios::<span class="built_in">sync_with_stdio</span>(<span class="literal">false</span>);</span><br><span class="line">	cin.<span class="built_in">tie</span>(<span class="number">0</span>); cout.<span class="built_in">tie</span>(<span class="number">0</span>);</span><br><span class="line">	<span class="type">int</span> T; cin &gt;&gt; T;</span><br><span class="line">	<span class="keyword">while</span> (T--) &#123;</span><br><span class="line">		<span class="built_in">init</span>(cnt + <span class="number">1</span>);</span><br><span class="line">		root = <span class="number">0</span>, cnt = <span class="number">0</span>;</span><br><span class="line">		<span class="type">int</span> n, q; cin &gt;&gt; n &gt;&gt; q;</span><br><span class="line">		<span class="keyword">while</span>(n--)&#123;</span><br><span class="line">			string s; cin &gt;&gt; s;</span><br><span class="line">			<span class="type">int</span> now = <span class="number">0</span>;</span><br><span class="line">			<span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; s.<span class="built_in">size</span>(); i++) &#123;</span><br><span class="line">				<span class="type">int</span> x = <span class="built_in">getnum</span>(s[i]);</span><br><span class="line">				<span class="keyword">if</span> (!nxt[now][x])</span><br><span class="line">					nxt[now][x] = ++cnt;</span><br><span class="line">				now = nxt[now][x];</span><br><span class="line">				tol[now]++;</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">while</span>(q--) &#123;</span><br><span class="line">			string pat; cin &gt;&gt; pat;</span><br><span class="line">			<span class="type">int</span> now = <span class="number">0</span>,flag=<span class="number">1</span>;</span><br><span class="line">			<span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; pat.<span class="built_in">size</span>(); i++) &#123;</span><br><span class="line">				<span class="type">int</span> x = <span class="built_in">getnum</span>(pat[i]);</span><br><span class="line">				<span class="keyword">if</span> (!nxt[now][x]) &#123;</span><br><span class="line">					flag = <span class="number">0</span>;</span><br><span class="line">					cout &lt;&lt; <span class="number">0</span> &lt;&lt; endl;</span><br><span class="line">					<span class="keyword">break</span>;</span><br><span class="line">				&#125;</span><br><span class="line">				now = nxt[now][x];</span><br><span class="line">			&#125;</span><br><span class="line">			<span class="keyword">if</span>(flag)</span><br><span class="line">			cout &lt;&lt; tol[now] &lt;&lt; endl;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="链表"><a href="#链表" class="headerlink" title="链表"></a>链表</h2><h3 id="单链"><a href="#单链" class="headerlink" title="单链"></a>单链</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">struct</span> <span class="title class_">link</span></span><br><span class="line">&#123;</span><br><span class="line">	<span class="type">int</span> data;</span><br><span class="line">	link* next;</span><br><span class="line">	link* last;</span><br><span class="line">&#125; ;</span><br><span class="line"></span><br><span class="line"><span class="function">link* <span class="title">creatlink</span><span class="params">()</span><span class="comment">//创建一个头结点，链表的起始位置。</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	link* headNode = (link*)<span class="built_in">malloc</span>(<span class="built_in">sizeof</span>(link));</span><br><span class="line">	<span class="keyword">if</span> (headNode == <span class="literal">NULL</span>)</span><br><span class="line">		<span class="built_in">exit</span>(<span class="number">1</span>);</span><br><span class="line">	headNode-&gt;next = <span class="literal">NULL</span>;</span><br><span class="line">	headNode-&gt;last = <span class="literal">NULL</span>;</span><br><span class="line">	<span class="keyword">return</span> headNode;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function">link* <span class="title">creatNode</span><span class="params">(<span class="type">int</span> data)</span><span class="comment">//创建一个结点，后续将其插入链表。</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	link* NewNode = (link*)<span class="built_in">malloc</span>(<span class="built_in">sizeof</span>(link));</span><br><span class="line">	<span class="keyword">if</span> (NewNode == <span class="literal">NULL</span>)</span><br><span class="line">		<span class="built_in">exit</span>(<span class="number">1</span>);</span><br><span class="line">	NewNode-&gt;data = data;</span><br><span class="line">	NewNode-&gt;next = <span class="literal">NULL</span>;</span><br><span class="line">	NewNode-&gt;last = <span class="literal">NULL</span>;</span><br><span class="line">	<span class="keyword">return</span> NewNode;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"> <span class="function"><span class="type">void</span> <span class="title">addNode</span><span class="params">(link * headNode,<span class="type">int</span> data)</span><span class="comment">//为该链表添加一个结点</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	link* AddNode = <span class="built_in">creatNode</span>(data); </span><br><span class="line">	AddNode-&gt;next = headNode-&gt;next;</span><br><span class="line">	headNode-&gt;next = AddNode;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"> <span class="function"><span class="type">void</span> <span class="title">delNode</span><span class="params">(link* headNode, <span class="type">int</span> num)</span><span class="comment">//删除某个节点</span></span></span><br><span class="line"><span class="function"> </span>&#123;</span><br><span class="line">	 link* pmove = headNode-&gt;next;</span><br><span class="line">	 link* p1move = headNode;         <span class="keyword">if</span>(p1move-&gt;data==num)&#123;            headNode-&gt;next=<span class="literal">NULL</span>;            headNode=pmove;                    &#125;</span><br><span class="line">	 <span class="keyword">while</span> (pmove)</span><br><span class="line">	 &#123;	</span><br><span class="line">		 <span class="keyword">if</span> (pmove-&gt;data == num)</span><br><span class="line">		 &#123;</span><br><span class="line">			 p1move-&gt;next = pmove-&gt;next;</span><br><span class="line">		 &#125;</span><br><span class="line">		 pmove=pmove-&gt;next;</span><br><span class="line">		 p1move=p1move-&gt;next;</span><br><span class="line">	 &#125;</span><br><span class="line"> &#125;</span><br><span class="line"></span><br><span class="line"> <span class="function"><span class="type">void</span> <span class="title">insertNode</span><span class="params">(link* headNode, <span class="type">int</span> num,<span class="type">int</span> data)</span> </span>&#123;</span><br><span class="line">	 link* pmove = headNode-&gt;next;</span><br><span class="line">	 link* p1move = headNode;</span><br><span class="line">	 link* node = <span class="built_in">creatNode</span>(data);</span><br><span class="line">	 <span class="keyword">while</span> (pmove)</span><br><span class="line">	 &#123;</span><br><span class="line">		 <span class="keyword">if</span> (pmove-&gt;data == num)</span><br><span class="line">		 &#123;</span><br><span class="line">			 node-&gt;next = pmove-&gt;next;</span><br><span class="line">			 pmove-&gt;next = node;</span><br><span class="line">			 <span class="keyword">break</span>;</span><br><span class="line">		 &#125;</span><br><span class="line">		 pmove = pmove-&gt;next;</span><br><span class="line">		 p1move = p1move-&gt;next;</span><br><span class="line">	 &#125;</span><br><span class="line"> &#125;</span><br><span class="line"><span class="function"><span class="type">int</span>  <span class="title">printflink</span><span class="params">(link* headNode)</span><span class="comment">//打印节点数据</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	link* ptrmove = headNode-&gt;next;</span><br><span class="line">	<span class="keyword">while</span> (ptrmove)</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="built_in">printf</span>(<span class="string">&quot;%d\n&quot;</span>, ptrmove-&gt;data);</span><br><span class="line">		ptrmove =ptrmove-&gt;next;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">lastaddNode</span><span class="params">(link* headNode, <span class="type">int</span> num)</span><span class="comment">//在链表末尾添加一个新的节点</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	link* Node1 = <span class="built_in">lastNode</span>(headNode); </span><br><span class="line">	link* AddNode = <span class="built_in">creatNode</span>(num);</span><br><span class="line">	Node1-&gt;next = AddNode;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function">link* <span class="title">lastNode</span><span class="params">(link* headNode)</span><span class="comment">//使当前指针指到链表最后一个节点。</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="keyword">while</span> (headNode-&gt;next)</span><br><span class="line">	&#123;</span><br><span class="line">		headNode = headNode-&gt;next;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> headNode;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="双链"><a href="#双链" class="headerlink" title="双链"></a>双链</h3><p>双链只需要在数据结构上附加一个域，包含指向前一个单元的指针即可。</p>
<h3 id="Floyd-判圈算法"><a href="#Floyd-判圈算法" class="headerlink" title="Floyd 判圈算法"></a>Floyd 判圈算法</h3><p><em><strong>判断是否有环</strong></em><br>定义两个指针p1与p2，起始时，都指向链表的起点A，p1每次移动1个长度，p2每次移动2个长度。如果p2在移到链表的尾端时，并未与p1相遇，表明链表中不存在环。如果p1与p2相遇在环上的某一点C，表明链表有环。</p>
<p><em><strong>环的长度</strong></em><br>将指针p1固定在相遇位置C，移动p2，每次移动1个长度，并用变量计数。当p2再次与p1相遇时，此时该变量的值就是环的长度。</p>
<p><em><strong>环的起点</strong></em><br>将指针p1指向链表的起始位置A，指针p2仍在位置C，指针p1与p2每次均移动一个单位，p1与p2再次相遇的位置就是环的起点位置点B。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//判断链表中是否有环</span></span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">Node</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">int</span> data;</span><br><span class="line">    Node* next;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="function"><span class="type">bool</span> <span class="title">findCircle</span><span class="params">(Node* list)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (list == <span class="literal">NULL</span> || list-&gt;next == <span class="literal">NULL</span>)</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    Node* ptr_slow = list, *ptr_fast = list;</span><br><span class="line">    <span class="keyword">while</span> (ptr_fast != ptr_slow) &#123;</span><br><span class="line">        <span class="keyword">if</span> (ptr_fast == <span class="literal">NULL</span> || ptr_fast-&gt;next == <span class="literal">NULL</span>)</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">        ptr_slow = ptr_slow-&gt;next;</span><br><span class="line">        ptr_fast = ptr_fast-&gt;next-&gt;next;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//寻找环的起点</span></span><br><span class="line"> <span class="function">Node *<span class="title">detectCycle</span><span class="params">(Node *head)</span> </span>&#123;</span><br><span class="line">       Node *ptr_slow = head, *ptr_fast = head;</span><br><span class="line">        <span class="keyword">while</span> (ptr_fast != <span class="literal">NULL</span>) &#123;</span><br><span class="line">            ptr_slow = ptr_slow-&gt;next;</span><br><span class="line">            <span class="keyword">if</span> (ptr_fast-&gt;ptr_next == <span class="literal">NULL</span>)</span><br><span class="line">                <span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line">            ptr_fast = ptr_fast-&gt;next-&gt;next;</span><br><span class="line">            <span class="keyword">if</span> (ptr_fast == ptr_slow) &#123;</span><br><span class="line">                Node *ptr = head;</span><br><span class="line">                <span class="keyword">while</span> (ptr != ptr_slow) &#123;</span><br><span class="line">                    ptr = ptr-&gt;next;</span><br><span class="line">                    ptr_slow = ptr_slow-&gt;next;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">return</span> ptr;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="树"><a href="#树" class="headerlink" title="树"></a>树</h2><h3 id="二叉查找树"><a href="#二叉查找树" class="headerlink" title="二叉查找树"></a>二叉查找树</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">struct</span> <span class="title class_">DoubleTree</span></span><br><span class="line">&#123;</span><br><span class="line">	<span class="type">int</span> data;</span><br><span class="line">	DoubleTree* lchild;</span><br><span class="line">	DoubleTree* rchild;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="function">DoubleTree* <span class="title">creatHead</span><span class="params">(<span class="type">int</span> num)</span> </span>&#123;</span><br><span class="line">	DoubleTree* Tree = <span class="keyword">new</span> DoubleTree;</span><br><span class="line">	Tree-&gt;data = num;</span><br><span class="line">	Tree-&gt;lchild = <span class="literal">NULL</span>;</span><br><span class="line">	Tree-&gt;rchild = <span class="literal">NULL</span>;</span><br><span class="line">	<span class="keyword">return</span> Tree;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function">DoubleTree* <span class="title">MakeEmpty</span><span class="params">(DoubleTree* Tree)</span> </span>&#123;</span><br><span class="line">	<span class="keyword">if</span> (Tree != <span class="literal">NULL</span>) &#123;</span><br><span class="line">		<span class="built_in">MakeEmpty</span>(Tree-&gt;lchild);</span><br><span class="line">		<span class="built_in">MakeEmpty</span>(Tree-&gt;rchild);</span><br><span class="line">		<span class="built_in">free</span>(Tree);</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function">DoubleTree* <span class="title">Find</span><span class="params">(DoubleTree* Tree, <span class="type">int</span> Key)</span> </span>&#123;</span><br><span class="line">	<span class="keyword">if</span> (Tree == <span class="literal">NULL</span>) <span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line">	<span class="keyword">if</span> (Key &lt; Tree-&gt;data)</span><br><span class="line">		<span class="keyword">return</span> <span class="built_in">Find</span>(Tree-&gt;lchild, Key);</span><br><span class="line">	<span class="keyword">else</span> <span class="keyword">if</span> (Key &gt; Tree-&gt;data)</span><br><span class="line">		<span class="keyword">return</span> <span class="built_in">Find</span>(Tree-&gt;rchild, Key);</span><br><span class="line">	<span class="keyword">else</span></span><br><span class="line">		<span class="keyword">return</span> Tree;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function">DoubleTree* <span class="title">FindMin</span><span class="params">(DoubleTree* Tree)</span> </span>&#123;</span><br><span class="line">	<span class="keyword">if</span> (Tree == <span class="literal">NULL</span>) <span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line">	<span class="keyword">else</span> <span class="keyword">if</span> (Tree-&gt;lchild == <span class="literal">NULL</span>) <span class="keyword">return</span> Tree;</span><br><span class="line">	<span class="keyword">else</span> <span class="keyword">return</span> <span class="built_in">FindMin</span>(Tree-&gt;lchild);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function">DoubleTree* <span class="title">FindMax</span><span class="params">(DoubleTree* Tree)</span> </span>&#123;</span><br><span class="line">	<span class="keyword">if</span> (Tree == <span class="literal">NULL</span>) <span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line">	<span class="keyword">else</span> <span class="keyword">if</span> (Tree-&gt;rchild == <span class="literal">NULL</span>) <span class="keyword">return</span> Tree;</span><br><span class="line">	<span class="keyword">else</span> <span class="keyword">return</span> <span class="built_in">FindMax</span>(Tree-&gt;rchild);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function">DoubleTree* <span class="title">insert</span><span class="params">(DoubleTree* Tree, <span class="type">int</span> x)</span> </span>&#123;</span><br><span class="line">	<span class="keyword">if</span> (Tree == <span class="literal">NULL</span>) &#123;</span><br><span class="line">		Tree = <span class="keyword">new</span> DoubleTree;</span><br><span class="line">		<span class="keyword">if</span> (Tree == <span class="literal">NULL</span>) <span class="built_in">exit</span>(<span class="number">1</span>);</span><br><span class="line">		<span class="keyword">else</span> &#123;</span><br><span class="line">			Tree-&gt;data = x;</span><br><span class="line">			Tree-&gt;lchild = <span class="literal">NULL</span>;</span><br><span class="line">			Tree-&gt;rchild = <span class="literal">NULL</span>;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">else</span> <span class="keyword">if</span> (x &lt; Tree-&gt;data)</span><br><span class="line">		Tree-&gt;lchild = <span class="built_in">insert</span>(Tree-&gt;lchild, x);</span><br><span class="line">	<span class="keyword">else</span> <span class="keyword">if</span> (x &gt; Tree-&gt;data)</span><br><span class="line">		Tree-&gt;rchild = <span class="built_in">insert</span>(Tree-&gt;rchild, x);</span><br><span class="line">	<span class="keyword">return</span> Tree;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function">DoubleTree* <span class="title">DeleteNode</span><span class="params">(DoubleTree* Tree, <span class="type">int</span> x)</span> </span>&#123;</span><br><span class="line">	DoubleTree* temp;</span><br><span class="line">	<span class="keyword">if</span> (Tree == <span class="literal">NULL</span>) <span class="built_in">exit</span>(<span class="number">1</span>);</span><br><span class="line">	<span class="keyword">else</span> <span class="keyword">if</span> ((x &lt; Tree-&gt;data))</span><br><span class="line">		Tree-&gt;lchild = <span class="built_in">DeleteNode</span>(Tree-&gt;lchild, x);</span><br><span class="line">	<span class="keyword">else</span> <span class="keyword">if</span> ((x &gt; Tree-&gt;data))</span><br><span class="line">		Tree-&gt;rchild = <span class="built_in">DeleteNode</span>(Tree-&gt;rchild, x);</span><br><span class="line">	<span class="keyword">else</span> <span class="keyword">if</span> (Tree-&gt;lchild &amp;&amp; Tree-&gt;rchild) &#123;</span><br><span class="line">		temp = <span class="built_in">FindMin</span>(Tree-&gt;rchild);</span><br><span class="line">		Tree-&gt;data = temp-&gt;data;</span><br><span class="line">		Tree-&gt;rchild = <span class="built_in">DeleteNode</span>(Tree-&gt;rchild, Tree-&gt;data);</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">else</span> &#123;</span><br><span class="line">		temp = Tree; </span><br><span class="line">		<span class="keyword">if</span> (Tree-&gt;lchild == <span class="literal">NULL</span>) Tree = Tree-&gt;rchild;</span><br><span class="line">		<span class="keyword">else</span> <span class="keyword">if</span> (Tree-&gt;rchild == <span class="literal">NULL</span>) Tree = Tree-&gt;lchild;</span><br><span class="line">		<span class="built_in">free</span>(temp);</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> Tree;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">print</span><span class="params">(DoubleTree* Tree)</span> </span>&#123;</span><br><span class="line">	<span class="keyword">if</span> (Tree == <span class="literal">NULL</span>)</span><br><span class="line">		<span class="keyword">return</span>;</span><br><span class="line">	cout &lt;&lt; Tree-&gt;data &lt;&lt; <span class="string">&quot; &quot;</span>;</span><br><span class="line">	<span class="built_in">print</span>(Tree-&gt;lchild);</span><br><span class="line">	<span class="built_in">print</span>(Tree-&gt;rchild);</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>


<h3 id="AVL树（平衡二叉树）"><a href="#AVL树（平衡二叉树）" class="headerlink" title="AVL树（平衡二叉树）"></a>AVL树（平衡二叉树）</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">AVLtree* <span class="title">SingerotateWihtleft</span><span class="params">(AVLtree* T)</span> </span>&#123;<span class="comment">//左左</span></span><br><span class="line">	AVLtree* T1;</span><br><span class="line">	T1 = T-&gt;lchild;</span><br><span class="line">	T-&gt;lchild = T1-&gt;rchild;</span><br><span class="line">	T1-&gt;rchild = T;</span><br><span class="line">	T-&gt;height = <span class="built_in">max</span>(<span class="built_in">returnHeight</span>(T-&gt;lchild), <span class="built_in">returnHeight</span>(T-&gt;rchild)) + <span class="number">1</span>;</span><br><span class="line">	T1-&gt;height = <span class="built_in">max</span>(<span class="built_in">returnHeight</span>(T1-&gt;lchild), T-&gt;height) + <span class="number">1</span>;</span><br><span class="line">	<span class="keyword">return</span> T1;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function">AVLtree* <span class="title">SingerotateWihtright</span><span class="params">(AVLtree* T)</span> </span>&#123;<span class="comment">//右右</span></span><br><span class="line">	AVLtree* T1;</span><br><span class="line">	T1 = T-&gt;rchild;</span><br><span class="line">	T-&gt;rchild = T1-&gt;lchild;</span><br><span class="line">	T1-&gt;lchild = T;</span><br><span class="line">	T-&gt;height = <span class="built_in">max</span>(<span class="built_in">returnHeight</span>(T-&gt;lchild), <span class="built_in">returnHeight</span>(T-&gt;rchild)) + <span class="number">1</span>;</span><br><span class="line">	T1-&gt;height = <span class="built_in">max</span>(T-&gt;height, <span class="built_in">returnHeight</span>(T1-&gt;rchild)) + <span class="number">1</span>;</span><br><span class="line">	<span class="keyword">return</span> T1;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function">AVLtree* <span class="title">DoublerotateWihtleft</span><span class="params">(AVLtree* T)</span> </span>&#123;<span class="comment">//左右</span></span><br><span class="line">	T-&gt;lchild = <span class="built_in">SingerotateWihtright</span>(T-&gt;lchild);</span><br><span class="line">	<span class="keyword">return</span> <span class="built_in">SingerotateWihtleft</span>(T);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function">AVLtree* <span class="title">DoublerotateWihtright</span><span class="params">(AVLtree* T)</span> </span>&#123;<span class="comment">//右坐</span></span><br><span class="line">	T-&gt;rchild = <span class="built_in">SingerotateWihtleft</span>(T-&gt;rchild);</span><br><span class="line">	<span class="keyword">return</span> <span class="built_in">SingerotateWihtright</span>(T);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function">AVLtree* <span class="title">insertNode</span><span class="params">(AVLtree* T,<span class="type">int</span> x)</span> </span>&#123;</span><br><span class="line">	<span class="keyword">if</span> (T == <span class="literal">NULL</span>) &#123;</span><br><span class="line">		T = <span class="keyword">new</span> AVLtree;</span><br><span class="line">		<span class="keyword">if</span> (T == <span class="literal">NULL</span>) <span class="built_in">exit</span>(<span class="number">1</span>);</span><br><span class="line">		<span class="keyword">else</span> &#123;</span><br><span class="line">			T-&gt;data = x; T-&gt;height = <span class="number">0</span>;</span><br><span class="line">			T-&gt;lchild = <span class="literal">NULL</span>; T-&gt;rchild = <span class="literal">NULL</span>;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">else</span> <span class="keyword">if</span> (x &lt; T-&gt;data) &#123;</span><br><span class="line">		T-&gt;lchild = <span class="built_in">insertNode</span>(T-&gt;lchild, x);</span><br><span class="line">		<span class="keyword">if</span> (<span class="built_in">returnHeight</span>(T-&gt;lchild) - <span class="built_in">returnHeight</span>(T-&gt;rchild) == <span class="number">2</span>) &#123;</span><br><span class="line">			<span class="keyword">if</span> (x &lt; T-&gt;lchild-&gt;data)</span><br><span class="line">				T = <span class="built_in">SingerotateWihtleft</span>(T);</span><br><span class="line">			<span class="keyword">else</span></span><br><span class="line">				T = <span class="built_in">DoublerotateWihtleft</span>(T);</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">else</span> <span class="keyword">if</span> (x &gt; T-&gt;data) &#123;</span><br><span class="line">		T-&gt;rchild = <span class="built_in">insertNode</span>(T-&gt;rchild, x);</span><br><span class="line">		<span class="keyword">if</span> (<span class="built_in">returnHeight</span>(T-&gt;rchild) - <span class="built_in">returnHeight</span>(T-&gt;lchild) == <span class="number">2</span>) &#123;</span><br><span class="line">			<span class="keyword">if</span> (x &gt; T-&gt;rchild-&gt;data)</span><br><span class="line">				T = <span class="built_in">SingerotateWihtright</span>(T);</span><br><span class="line">			<span class="keyword">else</span></span><br><span class="line">				T = <span class="built_in">DoublerotateWihtright</span>(T);</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	T-&gt;height = <span class="built_in">max</span>(<span class="built_in">returnHeight</span>(T-&gt;lchild), <span class="built_in">returnHeight</span>(T-&gt;rchild))+<span class="number">1</span>;</span><br><span class="line">	<span class="keyword">return</span> T;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function">AVLtree* <span class="title">DeleteNode</span><span class="params">(AVLtree* T, <span class="type">int</span> num)</span> </span>&#123;<span class="comment">//太麻烦了，删除操作相对较少懒惰删除是最好的策略</span></span><br><span class="line">	AVLtree* temp = <span class="literal">NULL</span>;</span><br><span class="line">	<span class="keyword">if</span> (T == <span class="literal">NULL</span>) cout &lt;&lt; <span class="string">&quot;NO data&quot;</span> &lt;&lt; endl;</span><br><span class="line">	<span class="keyword">else</span> <span class="keyword">if</span> (num &lt; T-&gt;data)</span><br><span class="line">		T-&gt;lchild = <span class="built_in">DeleteNode</span>(T-&gt;lchild, num);</span><br><span class="line">	<span class="keyword">else</span> <span class="keyword">if</span> (num &gt; T-&gt;data)</span><br><span class="line">		T-&gt;rchild = <span class="built_in">DeleteNode</span>(T-&gt;rchild, num);</span><br><span class="line">	<span class="keyword">else</span> <span class="keyword">if</span> (T-&gt;lchild &amp;&amp; T-&gt;rchild) &#123;</span><br><span class="line">		temp = <span class="built_in">FindMin</span>(T);</span><br><span class="line">		T-&gt;data = temp-&gt;data;</span><br><span class="line">		T-&gt;rchild = <span class="built_in">DeleteNode</span>(T-&gt;rchild, T-&gt;data);</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">else</span> &#123;</span><br><span class="line">		temp = T;</span><br><span class="line">		<span class="keyword">if</span> (T-&gt;lchild == <span class="literal">NULL</span>)</span><br><span class="line">			T = T-&gt;rchild;</span><br><span class="line">		<span class="keyword">else</span> <span class="keyword">if</span> (T-&gt;rchild == <span class="literal">NULL</span>)</span><br><span class="line">			T = T-&gt;lchild;</span><br><span class="line">		<span class="built_in">free</span>(temp);</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">if</span> (T!=<span class="literal">NULL</span>) &#123;</span><br><span class="line">		<span class="type">int</span> lheight = <span class="built_in">returnHeight</span>(T-&gt;lchild), rheight = <span class="built_in">returnHeight</span>(T-&gt;rchild);</span><br><span class="line">		T-&gt;height = (lheight &gt; rheight ? lheight : rheight)+<span class="number">1</span>;</span><br><span class="line">		<span class="keyword">if</span> (lheight - rheight == <span class="number">2</span>) &#123;</span><br><span class="line">			<span class="keyword">if</span> (<span class="built_in">returnHeight</span>(T-&gt;lchild-&gt;lchild) &gt;= <span class="built_in">returnHeight</span>(T-&gt;lchild-&gt;rchild))</span><br><span class="line">				T = <span class="built_in">SingerotateWihtleft</span>(T);</span><br><span class="line">			<span class="keyword">else</span></span><br><span class="line">				T = <span class="built_in">DoublerotateWihtleft</span>(T);</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">else</span> <span class="keyword">if</span> (rheight - lheight == <span class="number">2</span>) &#123;</span><br><span class="line">			<span class="keyword">if</span> (<span class="built_in">returnHeight</span>(T-&gt;rchild-&gt;rchild) &gt;= <span class="built_in">returnHeight</span>(T-&gt;rchild-&gt;lchild))</span><br><span class="line">				T = <span class="built_in">SingerotateWihtright</span>(T);</span><br><span class="line">			<span class="keyword">else</span></span><br><span class="line">				T = <span class="built_in">DoublerotateWihtright</span>(T);</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> T;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="树状数组"><a href="#树状数组" class="headerlink" title="树状数组"></a>树状数组</h2><h3 id="树状数组的基本实现"><a href="#树状数组的基本实现" class="headerlink" title="树状数组的基本实现"></a>树状数组的基本实现</h3><p>时间复杂度为O(logN)<br>lowbit(x) &#x3D; x&amp;(-x); （说简单点就是x的二进制数从左往右数第一个1的位数，比如100的lowbit运算结果为3）<br>功能（在O（logN）的时间复杂度下）<br>单点加<br>查询前缀和<br>P3374 【模板】树状数组 1 - 洛谷 |</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">const</span> <span class="type">int</span> MAX = <span class="number">5e5</span> + <span class="number">5</span>;</span><br><span class="line"><span class="type">int</span> a[MAX], c[MAX],n;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">query</span><span class="params">(<span class="type">int</span> x)</span> </span>&#123; <span class="comment">//查询1-x的和</span></span><br><span class="line">	<span class="type">int</span> s = <span class="number">0</span>;</span><br><span class="line">	<span class="keyword">for</span> (; x; x -= x &amp; (-x)) </span><br><span class="line">		s += c[x];</span><br><span class="line">	<span class="keyword">return</span> s;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">modify</span><span class="params">(<span class="type">int</span> x, <span class="type">long</span> <span class="type">long</span> k)</span> </span>&#123;<span class="comment">//修改树状数组</span></span><br><span class="line">	<span class="keyword">for</span> (; x &lt;= n; x += x &amp; (-x) )</span><br><span class="line">		c[x]+=k;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">	<span class="type">int</span>  m; cin &gt;&gt; n &gt;&gt; m;</span><br><span class="line">	<span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt;= n; i++) &#123;</span><br><span class="line">		<span class="type">int</span> num; cin &gt;&gt; num;</span><br><span class="line">		<span class="built_in">modify</span>(i, num);</span><br><span class="line">	&#125; </span><br><span class="line">	<span class="keyword">while</span> (m--) &#123;</span><br><span class="line">		<span class="type">int</span> choice,x,y; cin &gt;&gt; choice;</span><br><span class="line">		<span class="keyword">if</span> (choice == <span class="number">1</span>) &#123;</span><br><span class="line">			cin &gt;&gt; x &gt;&gt; y;</span><br><span class="line">			<span class="built_in">modify</span>(x, y);</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">else</span> &#123;</span><br><span class="line">			cin &gt;&gt; x &gt;&gt; y;</span><br><span class="line">			cout &lt;&lt; <span class="built_in">query</span>(y) - <span class="built_in">query</span>(x<span class="number">-1</span>) &lt;&lt; endl; <span class="comment">//计算x---y的和</span></span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>区间加</p>
<p>对于数组a，区间[l,r]加上k，则对于其差分数组d(对于ai，ai&#x3D;d1到di之和)，dl+&#x3D;k，dr-&#x3D;k;<br>这里就不多赘述了，与上述模板相比，就是将树状数组c的初始值初始化为a的差分数组，然后再修改值的时候，加上一个modify(r+1,-k);<br>P3368 【模板】树状数组 2 - 洛谷 | 计算机科学教育新生态 (luogu.com.cn)</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="type">const</span> <span class="type">int</span> MAX = <span class="number">5e5</span> + <span class="number">5</span>;</span><br><span class="line"><span class="type">int</span>  c[MAX], n;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">query</span><span class="params">(<span class="type">int</span> x)</span> </span>&#123; <span class="comment">//查询1-x的和</span></span><br><span class="line">    <span class="type">int</span> s = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> (; x; x -= x &amp; (-x))</span><br><span class="line">        s += c[x];</span><br><span class="line">    <span class="keyword">return</span> s;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">modify</span><span class="params">(<span class="type">int</span> x, <span class="type">long</span> <span class="type">long</span> k)</span> </span>&#123;<span class="comment">//修改树状数组</span></span><br><span class="line">    <span class="keyword">for</span> (; x &lt;= n; x += x &amp; (-x))</span><br><span class="line">        c[x] += k;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="type">int</span>  m; cin &gt;&gt; n &gt;&gt; m;</span><br><span class="line">    <span class="type">int</span> last = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt;= n; i++) &#123;</span><br><span class="line">        <span class="type">int</span> now; cin &gt;&gt; now;</span><br><span class="line">        <span class="built_in">modify</span>(i, now-last);</span><br><span class="line">        last = now;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">while</span> (m--) &#123;</span><br><span class="line">        <span class="type">int</span> choice, x, y, k ; cin &gt;&gt; choice;</span><br><span class="line">        <span class="keyword">if</span> (choice == <span class="number">1</span>) &#123;</span><br><span class="line">            cin &gt;&gt; x &gt;&gt; y&gt;&gt; k ;</span><br><span class="line">            <span class="built_in">modify</span>(x, k);</span><br><span class="line">            <span class="built_in">modify</span>(y + <span class="number">1</span>, -k);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> &#123;</span><br><span class="line">            cin &gt;&gt; x;</span><br><span class="line">            cout &lt;&lt; <span class="built_in">query</span>(x) &lt;&lt; endl;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="一维树状数组基本应用"><a href="#一维树状数组基本应用" class="headerlink" title="一维树状数组基本应用"></a>一维树状数组基本应用</h3><p>P1908 逆序对<br>对pair数组的first进行排序，这里的first表示值，second表示下标。后面在创建一个数组A，从pair数组的第一个值开始，使得A[pair[i].second]&#x3D;i，最后可以使得数组A和原数组，数据大小是相反对应的，比如在下标3处，原数组存储的是最大值，A数组存储的则是最小值1。<br>最后将A数组，从第一个数开始，ans+&#x3D;query(A[i]),再modify(A[i],1)，这一操作，表示ans+&#x3D;（以i为分界点，满足j&lt; i,且Aj&lt; Ai的元素个数），直到最后一个元素，最后ans就是最后的结果（因为答案要求的是j&lt; i,且Aj&gt;Ai，是相反的，正好A数组和原数组数据大小是相反对应的，所以最后的结果是正确的）</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="type">const</span> <span class="type">int</span> MAX = <span class="number">5e5</span> + <span class="number">5</span>;</span><br><span class="line"><span class="keyword">typedef</span> <span class="type">long</span> <span class="type">long</span> ll;</span><br><span class="line"><span class="keyword">typedef</span> pair&lt;ll, ll&gt; Pll;</span><br><span class="line"><span class="type">int</span> n, a[MAX], c[MAX];</span><br><span class="line">Pll temp[MAX];</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">cmp</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">bool</span> <span class="title">operator</span><span class="params">()</span><span class="params">(<span class="type">const</span> Pll&amp; p1, <span class="type">const</span> Pll&amp; p2)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (p1.first &gt; p2.first)</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> (p1.first == p2.first &amp;&amp; p1.second &gt; p2.second)</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">            <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function">ll <span class="title">query</span><span class="params">(<span class="type">int</span> x)</span> </span>&#123;</span><br><span class="line">    ll s = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> (; x; x -= x &amp; (-x))</span><br><span class="line">        s += c[x];</span><br><span class="line">    <span class="keyword">return</span> s;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">modify</span><span class="params">(<span class="type">int</span> x, <span class="type">int</span> d)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">for</span> (; x &lt;= n; x += x &amp; (-x))</span><br><span class="line">        c[x] += d;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    cin &gt;&gt; n;</span><br><span class="line">    ll ans = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt;= n; i++) &#123;</span><br><span class="line">        cin &gt;&gt; temp[i].first;</span><br><span class="line">        temp[i].second = i;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">sort</span>(temp + <span class="number">1</span>, temp + <span class="number">1</span> + n, <span class="built_in">cmp</span>());</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt;= n; i++)</span><br><span class="line">        a[temp[i].second] = i;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt;= n; i++) &#123;</span><br><span class="line">        ans += <span class="built_in">query</span>(a[i]);</span><br><span class="line">        <span class="built_in">modify</span>(a[i], <span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    cout &lt;&lt; ans &lt;&lt; endl;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="高维树状数组"><a href="#高维树状数组" class="headerlink" title="高维树状数组"></a>高维树状数组</h3><p>这里以二维树状数组为例：<br>在一维树状数组中，tree[x]（树状数组中的那个“数组”）记录的是右端点为x、长度为lowbit(x)的区间的区间和。<br>那么在二维树状数组中，可以类似地定义tree[x][y]记录的是右下角为(x, y)，高为lowbit(x), 宽为 lowbit(y)的区间的区间和。<br>时间复杂度为	O（log2N）<br>基本实现和一位数状数组相差不多，拓展到k维树状数组就是嵌套k维数组，k 层for循环。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="type">long</span> <span class="type">long</span> ll;</span><br><span class="line"><span class="type">const</span> <span class="type">int</span> MAX = <span class="number">5</span> - <span class="number">1</span>;</span><br><span class="line">ll c[MAX][MAX], n;</span><br><span class="line"><span class="function">ll <span class="title">query</span><span class="params">(<span class="type">int</span> x)</span> </span>&#123;</span><br><span class="line">    ll s = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> p=x; p; p -= p &amp; (-p))</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> q=x;q;q-=q&amp;(-q))    </span><br><span class="line">            s += c[p][q];</span><br><span class="line">    <span class="keyword">return</span> s;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">modify</span><span class="params">(<span class="type">int</span> x, ll d)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> p = x; p &lt;= n; p += p &amp; (-p))</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> q = x; q &lt;= n; q += q &amp; (-q))</span><br><span class="line">            c[p][q] += d;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="线段树"><a href="#线段树" class="headerlink" title="线段树"></a>线段树</h2><h3 id="区间查询最小值"><a href="#区间查询最小值" class="headerlink" title="区间查询最小值"></a>区间查询最小值</h3><p>单点修改<br>区间查询(树状数组仅可以进行前缀和查询)<br>时间复杂度O(logN)，可采用数组实现。<br>线段树可以进行多种查询，以下的板子为查询区间内的最小值。</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="type">const</span> <span class="type">int</span> MAX = <span class="number">2e5</span> + <span class="number">5</span>;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> a[MAX];</span><br><span class="line"></span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">Node</span> &#123;</span><br><span class="line">	<span class="type">int</span> minv;</span><br><span class="line">&#125;tree[<span class="number">4</span>*MAX];</span><br><span class="line"></span><br><span class="line"><span class="comment">//更新数据</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">update</span><span class="params">(<span class="type">int</span> id)</span> </span>&#123;</span><br><span class="line">	tree[id].minv = <span class="built_in">min</span>(tree[id * <span class="number">2</span>].minv, tree[id * <span class="number">2</span> + <span class="number">1</span>].minv);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//建树</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">build</span><span class="params">(<span class="type">int</span> id, <span class="type">int</span> l, <span class="type">int</span> r)</span> </span>&#123;</span><br><span class="line">	<span class="keyword">if</span> (l == r) &#123;</span><br><span class="line">		tree[id].minv = a[l];</span><br><span class="line">		<span class="keyword">return</span>;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">else</span> &#123;</span><br><span class="line">		<span class="type">int</span> mid = (l + r) / <span class="number">2</span>;</span><br><span class="line">		<span class="built_in">build</span>(id * <span class="number">2</span>, l, mid);</span><br><span class="line">		<span class="built_in">build</span>(id * <span class="number">2</span>+<span class="number">1</span>, mid+<span class="number">1</span>, r);</span><br><span class="line">		<span class="built_in">update</span>(id);</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//节点为id，将区间[l,r]的数据，a[pos]修改为val</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">change</span><span class="params">(<span class="type">int</span> id, <span class="type">int</span> l, <span class="type">int</span> r, <span class="type">int</span> pos, <span class="type">int</span> val)</span> </span>&#123;</span><br><span class="line">	<span class="keyword">if</span> (l == r) &#123;</span><br><span class="line">		tree[id].minv = val;</span><br><span class="line">		<span class="keyword">return</span>;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">else</span> &#123;</span><br><span class="line">		<span class="type">int</span> mid = (l + r) / <span class="number">2</span>;</span><br><span class="line">		<span class="keyword">if</span> (pos &lt;= mid)</span><br><span class="line">			<span class="built_in">change</span>(id * <span class="number">2</span>, l, mid, pos, val);</span><br><span class="line">		<span class="keyword">else</span> </span><br><span class="line">			<span class="built_in">change</span>(id * <span class="number">2</span> + <span class="number">1</span>, mid + <span class="number">1</span>, r, pos, val);</span><br><span class="line">		<span class="built_in">update</span>(id);</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//[dl,dr]表示要查询的区间</span></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">query</span><span class="params">(<span class="type">int</span> id, <span class="type">int</span> l, <span class="type">int</span> r, <span class="type">int</span> dl, <span class="type">int</span> dr)</span> </span>&#123;</span><br><span class="line">	<span class="keyword">if</span> (l == dl &amp;&amp; r == dr)</span><br><span class="line">		<span class="keyword">return</span> tree[id].minv;</span><br><span class="line">	<span class="type">int</span> mid = (l + r) / <span class="number">2</span>;</span><br><span class="line">	<span class="comment">//[l,mid],[mid+1,r];</span></span><br><span class="line">	<span class="keyword">if</span> (dr &lt;= mid)</span><br><span class="line">		<span class="keyword">return</span> <span class="built_in">query</span>(<span class="number">2</span> * id, l, mid, dl, dr);</span><br><span class="line">	<span class="keyword">else</span> <span class="keyword">if</span> (dl &gt; mid)</span><br><span class="line">		<span class="keyword">return</span> <span class="built_in">query</span>(<span class="number">2</span> * id + <span class="number">1</span>, mid + <span class="number">1</span>, r, dl, dr);</span><br><span class="line">	<span class="keyword">else</span> &#123;</span><br><span class="line">		<span class="comment">// dr&gt; mid, dl&lt;=mid</span></span><br><span class="line">		<span class="comment">//[ql,mid],[mid+1,dr];</span></span><br><span class="line">		<span class="keyword">return</span> <span class="built_in">min</span>(<span class="built_in">query</span>(id * <span class="number">2</span>, l, mid, dl, mid), <span class="built_in">query</span>(id * <span class="number">2</span> + <span class="number">1</span>, mid + <span class="number">1</span>, r, mid+<span class="number">1</span>, dr));</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">	<span class="comment">// 3 2 4 6 8 9 5 3</span></span><br><span class="line">	<span class="type">int</span> n; cin &gt;&gt; n;</span><br><span class="line">	<span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt;= n; i++)</span><br><span class="line">		cin &gt;&gt; a[i];</span><br><span class="line">	<span class="built_in">build</span>(<span class="number">1</span>, <span class="number">1</span>, n);</span><br><span class="line">	<span class="built_in">change</span>(<span class="number">1</span>, <span class="number">1</span>, n, <span class="number">2</span>, <span class="number">99</span>);</span><br><span class="line">	cout &lt;&lt; <span class="built_in">query</span>(<span class="number">1</span>, <span class="number">1</span>, n, <span class="number">2</span>, n - <span class="number">1</span>) &lt;&lt; endl;</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="区间查询最大字段和"><a href="#区间查询最大字段和" class="headerlink" title="区间查询最大字段和"></a>区间查询最大字段和</h3><p>高度封装板子，wls真是永远的神</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="type">const</span> <span class="type">int</span> MAX = <span class="number">2e5</span> + <span class="number">5</span>;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> a[MAX];</span><br><span class="line"></span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">info</span> &#123;</span><br><span class="line">	<span class="type">int</span> mPrefix,mSuffix,mSum,s;</span><br><span class="line">	<span class="built_in">info</span>()&#123;&#125;</span><br><span class="line">	<span class="built_in">info</span>(<span class="type">int</span> a):<span class="built_in">mPrefix</span>(a),<span class="built_in">mSuffix</span>(a),<span class="built_in">mSum</span>(a),<span class="built_in">s</span>(a)&#123;&#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">info <span class="keyword">operator</span>+(<span class="type">const</span> info&amp; left, <span class="type">const</span> info&amp; right) &#123;</span><br><span class="line">	info a;</span><br><span class="line">	a.mSum = <span class="built_in">max</span>(&#123; left.mSum, right.mSum, left.mSuffix + right.mPrefix &#125;);</span><br><span class="line">	a.mPrefix = <span class="built_in">max</span>(left.mPrefix, left.s + right.mPrefix);</span><br><span class="line">	a.mSuffix = <span class="built_in">max</span>(right.mSuffix, right.s + left.mSuffix);</span><br><span class="line">	a.s = left.s + right.s;</span><br><span class="line">	<span class="keyword">return</span> a;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">Node</span> &#123;</span><br><span class="line">	info val;</span><br><span class="line">&#125;tree[<span class="number">4</span> * MAX];</span><br><span class="line"></span><br><span class="line"><span class="comment">//更新数据</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">update</span><span class="params">(<span class="type">int</span> id)</span> </span>&#123;</span><br><span class="line">	tree[id].val = tree[id * <span class="number">2</span>].val + tree[id * <span class="number">2</span> + <span class="number">1</span>].val;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//建树</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">build</span><span class="params">(<span class="type">int</span> id, <span class="type">int</span> l, <span class="type">int</span> r)</span> </span>&#123;</span><br><span class="line">	<span class="keyword">if</span> (l == r) &#123;</span><br><span class="line">		tree[id].val = <span class="built_in">info</span>(a[l]);</span><br><span class="line">		<span class="keyword">return</span>;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">else</span> &#123;</span><br><span class="line">		<span class="type">int</span> mid = (l + r) / <span class="number">2</span>;</span><br><span class="line">		<span class="built_in">build</span>(id * <span class="number">2</span>, l, mid);</span><br><span class="line">		<span class="built_in">build</span>(id * <span class="number">2</span>+<span class="number">1</span>, mid+<span class="number">1</span>, r);</span><br><span class="line">		<span class="built_in">update</span>(id);</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//节点为id，将区间[l,r]的数据，a[pos]修改为val</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">change</span><span class="params">(<span class="type">int</span> id, <span class="type">int</span> l, <span class="type">int</span> r, <span class="type">int</span> pos, <span class="type">int</span> val)</span> </span>&#123;</span><br><span class="line">	<span class="keyword">if</span> (l == r) &#123;</span><br><span class="line">		tree[id].val = <span class="built_in">info</span>(val);</span><br><span class="line">		<span class="keyword">return</span>;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">else</span> &#123;</span><br><span class="line">		<span class="type">int</span> mid = (l + r) / <span class="number">2</span>;</span><br><span class="line">		<span class="keyword">if</span> (pos &lt;= mid)</span><br><span class="line">			<span class="built_in">change</span>(id * <span class="number">2</span>, l, mid, pos, val);</span><br><span class="line">		<span class="keyword">else</span> </span><br><span class="line">			<span class="built_in">change</span>(id * <span class="number">2</span> + <span class="number">1</span>, mid + <span class="number">1</span>, r, pos, val);</span><br><span class="line">		<span class="built_in">update</span>(id);</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//[dl,dr]表示要查询的区间</span></span><br><span class="line"><span class="function">info <span class="title">query</span><span class="params">(<span class="type">int</span> id, <span class="type">int</span> l, <span class="type">int</span> r, <span class="type">int</span> dl, <span class="type">int</span> dr)</span> </span>&#123;</span><br><span class="line">	<span class="keyword">if</span> (l == dl &amp;&amp; r == dr)</span><br><span class="line">		<span class="keyword">return</span> tree[id].val;</span><br><span class="line">	<span class="type">int</span> mid = (l + r) / <span class="number">2</span>;</span><br><span class="line">	<span class="comment">//[l,mid],[mid+1,r];</span></span><br><span class="line">	<span class="keyword">if</span> (dr &lt;= mid)</span><br><span class="line">		<span class="keyword">return</span> <span class="built_in">query</span>(<span class="number">2</span> * id, l, mid, dl, dr);</span><br><span class="line">	<span class="keyword">else</span> <span class="keyword">if</span> (dl &gt; mid)</span><br><span class="line">		<span class="keyword">return</span> <span class="built_in">query</span>(<span class="number">2</span> * id + <span class="number">1</span>, mid + <span class="number">1</span>, r, dl, dr);</span><br><span class="line">	<span class="keyword">else</span> &#123;</span><br><span class="line">		<span class="comment">// dr&gt; mid, dl&lt;=mid</span></span><br><span class="line">		<span class="comment">//[ql,mid],[mid+1,dr];</span></span><br><span class="line">		<span class="keyword">return</span> <span class="built_in">query</span>(id * <span class="number">2</span>, l, mid, dl, mid)+<span class="built_in">query</span>(id * <span class="number">2</span> + <span class="number">1</span>, mid + <span class="number">1</span>, r, mid+<span class="number">1</span>, dr);</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">	<span class="comment">/*</span></span><br><span class="line"><span class="comment">	 5 5</span></span><br><span class="line"><span class="comment">	-1 2 -3 4 -5</span></span><br><span class="line"><span class="comment">	2 4 5</span></span><br><span class="line"><span class="comment">	1 2 4</span></span><br><span class="line"><span class="comment">	2 1 5</span></span><br><span class="line"><span class="comment">	1 4 -1</span></span><br><span class="line"><span class="comment">	2 2 4</span></span><br><span class="line"><span class="comment">	*/</span></span><br><span class="line">	std::ios::<span class="built_in">sync_with_stdio</span>(<span class="literal">false</span>); </span><br><span class="line">	cin.<span class="built_in">tie</span>(<span class="number">0</span>); cout.<span class="built_in">tie</span>(<span class="number">0</span>);</span><br><span class="line">	<span class="type">int</span> n,q; cin &gt;&gt; n&gt;&gt;q;</span><br><span class="line">	<span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt;= n; i++)</span><br><span class="line">		cin &gt;&gt; a[i];</span><br><span class="line">	<span class="built_in">build</span>(<span class="number">1</span>, <span class="number">1</span>, n);</span><br><span class="line">	<span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; q; i++) &#123;</span><br><span class="line">		<span class="type">int</span> ty; cin &gt;&gt; ty;</span><br><span class="line">		<span class="keyword">if</span> (ty == <span class="number">1</span>) &#123;</span><br><span class="line">			<span class="type">int</span> x, d; cin &gt;&gt; x &gt;&gt; d;</span><br><span class="line">			<span class="built_in">change</span>(<span class="number">1</span>, <span class="number">1</span>, n, x, d);</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">else</span> &#123;</span><br><span class="line">			<span class="type">int</span> l, r; cin &gt;&gt; l &gt;&gt; r;</span><br><span class="line">			<span class="keyword">auto</span> ans = <span class="built_in">query</span>(<span class="number">1</span>, <span class="number">1</span>, n, l, r);</span><br><span class="line">			cout &lt;&lt; ans.mSum &lt;&lt; endl;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="线段树打标记"><a href="#线段树打标记" class="headerlink" title="线段树打标记"></a>线段树打标记</h3><p>用于线段树区间修改<br>打标记：<br><strong>懒标记</strong>:懒标记的作用是记录每次、每个节点要更新的值  	<br><strong>标记永久化</strong>:将标记永久记录（ 不建议）<br><strong>标记下传</strong>:因为线段树分成了一个一个区间，所以可以将某个节点的懒标记，下传给他的子结点，并且将当前节点的懒标记置为0。<br><strong>标记合并</strong>：将之前存在的相同节点的多个标记合并<br>更新信息</p>
<h4 id="查询区间最大值"><a href="#查询区间最大值" class="headerlink" title="查询区间最大值"></a>查询区间最大值</h4><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="keyword">typedef</span> <span class="type">long</span> <span class="type">long</span> ll;</span><br><span class="line"><span class="type">const</span> <span class="type">int</span> MAX = <span class="number">2e5</span> + <span class="number">5</span>;</span><br><span class="line"></span><br><span class="line">ll a[MAX];</span><br><span class="line"></span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">info</span> &#123;</span><br><span class="line">    ll maxv;</span><br><span class="line">    <span class="built_in">info</span>() &#123;&#125;</span><br><span class="line">    <span class="built_in">info</span>(ll x):<span class="built_in">maxv</span>(x) &#123;&#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">tag</span> &#123;</span><br><span class="line">    ll add;</span><br><span class="line">    <span class="built_in">tag</span>()&#123;&#125;</span><br><span class="line">    <span class="built_in">tag</span>(ll x) :<span class="built_in">add</span>(x) &#123;&#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">info <span class="keyword">operator</span>+(<span class="type">const</span> info&amp; left, <span class="type">const</span> info&amp; right) &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">info</span>(<span class="built_in">max</span>(left.maxv, right.maxv));</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">info <span class="keyword">operator</span>+(<span class="type">const</span> info&amp; val, <span class="type">const</span> tag&amp; t) &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">info</span>(val.maxv+t.add);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">tag <span class="keyword">operator</span>+(<span class="type">const</span> tag&amp; t1, <span class="type">const</span> tag&amp; t2) &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">tag</span>(t1.add+t2.add);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">Node</span> &#123;</span><br><span class="line">    tag t;</span><br><span class="line">    info val;</span><br><span class="line">&#125;tree[<span class="number">4</span> * MAX];</span><br><span class="line"></span><br><span class="line"><span class="comment">//更新数据</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">update</span><span class="params">(<span class="type">int</span> id)</span> </span>&#123;</span><br><span class="line">    tree[id].val = tree[id * <span class="number">2</span>].val + tree[id * <span class="number">2</span> + <span class="number">1</span>].val;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//设置懒标记</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">settag</span><span class="params">(<span class="type">int</span> id,tag t)</span> </span>&#123;</span><br><span class="line">    tree[id].val = tree[id].val + t;</span><br><span class="line">    tree[id].t = tree[id].t + t;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//下传操作</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">pushDown</span><span class="params">(<span class="type">int</span> id)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (tree[id].t.add != <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="built_in">settag</span>(id * <span class="number">2</span>, tree[id].t);</span><br><span class="line">        <span class="built_in">settag</span>(id * <span class="number">2</span>+<span class="number">1</span>, tree[id].t);</span><br><span class="line">        tree[id].t = <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//建树</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">build</span><span class="params">(<span class="type">int</span> id, <span class="type">int</span> l, <span class="type">int</span> r)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (l == r) &#123;</span><br><span class="line">        tree[id].val = <span class="built_in">info</span>(a[l]);</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="type">int</span> mid = (l + r) / <span class="number">2</span>;</span><br><span class="line">        <span class="built_in">build</span>(id * <span class="number">2</span>, l, mid);</span><br><span class="line">        <span class="built_in">build</span>(id * <span class="number">2</span> + <span class="number">1</span>, mid + <span class="number">1</span>, r);</span><br><span class="line">        <span class="built_in">update</span>(id);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//节点为id，将区间[l,r]的数据，a[pos]修改为val</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">modify</span><span class="params">(<span class="type">int</span> id, <span class="type">int</span> l, <span class="type">int</span> r, <span class="type">int</span> dl,<span class="type">int</span> dr,tag t)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (l == dl &amp;&amp; r == dr) &#123;</span><br><span class="line">        <span class="built_in">settag</span>(id, t);</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="type">int</span> mid = (l + r) / <span class="number">2</span>;</span><br><span class="line">    <span class="comment">//[l,mid],[mid+1,r];</span></span><br><span class="line">    <span class="built_in">pushDown</span>(id);</span><br><span class="line">    <span class="keyword">if</span> (dr &lt;= mid)</span><br><span class="line">      <span class="built_in">modify</span>(<span class="number">2</span> * id, l, mid, dl, dr,t);</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span> (dl &gt; mid)</span><br><span class="line">      <span class="built_in">modify</span>(<span class="number">2</span> * id + <span class="number">1</span>, mid + <span class="number">1</span>, r, dl, dr,t);</span><br><span class="line">    <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="comment">// dr&gt; mid, dl&lt;=mid</span></span><br><span class="line">        <span class="comment">//[ql,mid],[mid+1,dr];</span></span><br><span class="line">        <span class="built_in">modify</span>(id * <span class="number">2</span>, l, mid, dl, mid,t);</span><br><span class="line">        <span class="built_in">modify</span>(id * <span class="number">2</span> + <span class="number">1</span>, mid + <span class="number">1</span>, r, mid + <span class="number">1</span>, dr,t);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">update</span>(id);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//[dl,dr]表示要查询的区间</span></span><br><span class="line"><span class="function">info <span class="title">query</span><span class="params">(<span class="type">int</span> id, <span class="type">int</span> l, <span class="type">int</span> r, <span class="type">int</span> dl, <span class="type">int</span> dr)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (l == dl &amp;&amp; r == dr)</span><br><span class="line">        <span class="keyword">return</span> tree[id].val;</span><br><span class="line">    <span class="type">int</span> mid = (l + r) / <span class="number">2</span>;</span><br><span class="line">    <span class="comment">//[l,mid],[mid+1,r];</span></span><br><span class="line">    <span class="built_in">pushDown</span>(id);</span><br><span class="line">    <span class="keyword">if</span> (dr &lt;= mid)</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">query</span>(<span class="number">2</span> * id, l, mid, dl, dr);</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span> (dl &gt; mid)</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">query</span>(<span class="number">2</span> * id + <span class="number">1</span>, mid + <span class="number">1</span>, r, dl, dr);</span><br><span class="line">    <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="comment">// dr&gt; mid, dl&lt;=mid</span></span><br><span class="line">        <span class="comment">//[ql,mid],[mid+1,dr];</span></span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">query</span>(id * <span class="number">2</span>, l, mid, dl, mid) + <span class="built_in">query</span>(id * <span class="number">2</span> + <span class="number">1</span>, mid + <span class="number">1</span>, r, mid + <span class="number">1</span>, dr);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="comment">/*</span></span><br><span class="line"><span class="comment">     5 5</span></span><br><span class="line"><span class="comment">    1 2 3 4 5 </span></span><br><span class="line"><span class="comment">    2 4 5</span></span><br><span class="line"><span class="comment">    1 1 5 1 </span></span><br><span class="line"><span class="comment">    2 1 4</span></span><br><span class="line"><span class="comment">    1 2 3 10</span></span><br><span class="line"><span class="comment">    2 2 4</span></span><br><span class="line"><span class="comment">    */</span></span><br><span class="line">    std::ios::<span class="built_in">sync_with_stdio</span>(<span class="literal">false</span>);</span><br><span class="line">    cin.<span class="built_in">tie</span>(<span class="number">0</span>); cout.<span class="built_in">tie</span>(<span class="number">0</span>);</span><br><span class="line">    <span class="type">int</span> n, q; cin &gt;&gt; n &gt;&gt; q;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt;= n; i++)</span><br><span class="line">        cin &gt;&gt; a[i];</span><br><span class="line">    <span class="built_in">build</span>(<span class="number">1</span>, <span class="number">1</span>, n);</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; q; i++) &#123;</span><br><span class="line">        <span class="type">int</span> ty; cin &gt;&gt; ty;</span><br><span class="line">        <span class="keyword">if</span> (ty == <span class="number">1</span>) &#123;</span><br><span class="line">            <span class="type">int</span> l,r, d; cin &gt;&gt; l&gt;&gt;r &gt;&gt; d;</span><br><span class="line">           <span class="built_in">modify</span>(<span class="number">1</span>, <span class="number">1</span>, n, l, r,<span class="built_in">tag</span>(d));</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="type">int</span> l, r; cin &gt;&gt; l &gt;&gt; r;</span><br><span class="line">            <span class="keyword">auto</span> ans = <span class="built_in">query</span>(<span class="number">1</span>, <span class="number">1</span>, n, l, r);</span><br><span class="line">            cout &lt;&lt; ans.maxv &lt;&lt; endl;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="查询区间和"><a href="#查询区间和" class="headerlink" title="查询区间和"></a>查询区间和</h4><p>可以进行区间乘和加某个数的操作</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="keyword">typedef</span> <span class="type">long</span> <span class="type">long</span> ll;</span><br><span class="line"><span class="type">const</span> <span class="type">int</span> MAX = <span class="number">1e5</span> + <span class="number">5</span>;</span><br><span class="line"></span><br><span class="line">ll a[MAX],mod;</span><br><span class="line"></span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">Node</span> &#123;</span><br><span class="line">    ll val = <span class="number">0</span>, size = <span class="number">0</span>;</span><br><span class="line">    ll mul = <span class="number">1</span>, add = <span class="number">0</span>;</span><br><span class="line">&#125;tree[<span class="number">4</span> * MAX];</span><br><span class="line"></span><br><span class="line"><span class="comment">//更新数据</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">update</span><span class="params">(<span class="type">int</span> id)</span> </span>&#123;</span><br><span class="line">    tree[id].val = (tree[id * <span class="number">2</span>].val + tree[id * <span class="number">2</span> + <span class="number">1</span>].val)%mod;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//设置懒标记</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">settag</span><span class="params">(<span class="type">int</span> id,ll add,ll mul)</span> </span>&#123;</span><br><span class="line">    tree[id].mul = (tree[id].mul * mul)%mod;</span><br><span class="line">    tree[id].add = (tree[id].add*mul+add)%mod;</span><br><span class="line">    tree[id].val = (tree[id].val*mul+tree[id].size*add)%mod ;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//下传操作</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">pushDown</span><span class="params">(<span class="type">int</span> id)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (tree[id].add != <span class="number">0</span> || tree[id].mul != <span class="number">1</span>) &#123;</span><br><span class="line">        <span class="built_in">settag</span>(id * <span class="number">2</span>, tree[id].add,tree[id].mul);</span><br><span class="line">        <span class="built_in">settag</span>(id * <span class="number">2</span>+<span class="number">1</span>, tree[id].add,tree[id].mul);</span><br><span class="line">        tree[id].add = <span class="number">0</span>;</span><br><span class="line">        tree[id].mul = <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//建树</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">build</span><span class="params">(<span class="type">int</span> id, <span class="type">int</span> l, <span class="type">int</span> r)</span> </span>&#123;</span><br><span class="line">    tree[id].size = r - l + <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">if</span> (l == r) &#123;</span><br><span class="line">        tree[id].val = a[l];</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="type">int</span> mid = (l + r) / <span class="number">2</span>;</span><br><span class="line">        <span class="built_in">build</span>(id * <span class="number">2</span>, l, mid);</span><br><span class="line">        <span class="built_in">build</span>(id * <span class="number">2</span> + <span class="number">1</span>, mid + <span class="number">1</span>, r);</span><br><span class="line">        <span class="built_in">update</span>(id);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//节点为id，将区间[l,r]的数据，增加t</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">modify</span><span class="params">(<span class="type">int</span> id, <span class="type">int</span> l, <span class="type">int</span> r, <span class="type">int</span> dl,<span class="type">int</span> dr,ll add,ll mul)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (dl == l &amp;&amp; r == dr) &#123;</span><br><span class="line">        <span class="built_in">settag</span>(id, add,mul);</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">pushDown</span>(id);</span><br><span class="line">    <span class="type">int</span> mid = (l + r) / <span class="number">2</span>;</span><br><span class="line">    <span class="comment">//[l,mid],[mid+1,r];</span></span><br><span class="line">    <span class="keyword">if</span> (dr &lt;= mid)</span><br><span class="line">       <span class="built_in">modify</span>(<span class="number">2</span> * id, l, mid, dl, dr,add,mul);</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span> (dl &gt; mid)</span><br><span class="line">       <span class="built_in">modify</span>(<span class="number">2</span> * id + <span class="number">1</span>, mid + <span class="number">1</span>, r, dl, dr,add,mul);</span><br><span class="line">    <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="comment">// dr&gt; mid, dl&lt;=mid</span></span><br><span class="line">        <span class="comment">//[ql,mid],[mid+1,dr];</span></span><br><span class="line">        <span class="built_in">modify</span>(id * <span class="number">2</span>, l, mid, dl, mid,add,mul);</span><br><span class="line">        <span class="built_in">modify</span>(id * <span class="number">2</span> + <span class="number">1</span>, mid + <span class="number">1</span>, r, mid + <span class="number">1</span>, dr, add, mul);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">update</span>(id);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//[dl,dr]表示要查询的区间</span></span><br><span class="line"><span class="function">ll <span class="title">query</span><span class="params">(<span class="type">int</span> id, <span class="type">int</span> l, <span class="type">int</span> r, <span class="type">int</span> dl, <span class="type">int</span> dr)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (dl == l &amp;&amp; r == dr)</span><br><span class="line">        <span class="keyword">return</span> tree[id].val;</span><br><span class="line">    <span class="built_in">pushDown</span>(id);</span><br><span class="line">    ll mid = (l + r) / <span class="number">2</span>;</span><br><span class="line">    <span class="comment">//[l,mid],[mid+1,r];</span></span><br><span class="line">    <span class="keyword">if</span> (dr &lt;=mid)                               </span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">query</span>(<span class="number">2</span> * id, l, mid, dl, dr);</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span> (dl &gt; mid)</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">query</span>(<span class="number">2</span> * id + <span class="number">1</span>, mid + <span class="number">1</span>, r, dl, dr);</span><br><span class="line">    <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="comment">// dr&gt; mid, dl&lt;=mid</span></span><br><span class="line">        <span class="comment">//[ql,mid],[mid+1,dr];</span></span><br><span class="line">        <span class="built_in">return</span> (<span class="built_in">query</span>(id * <span class="number">2</span>, l, mid, dl, mid) + <span class="built_in">query</span>(id * <span class="number">2</span> + <span class="number">1</span>, mid + <span class="number">1</span>, r, mid + <span class="number">1</span>, dr))%mod;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    std::ios::<span class="built_in">sync_with_stdio</span>(<span class="literal">false</span>);</span><br><span class="line">    cin.<span class="built_in">tie</span>(<span class="number">0</span>); cout.<span class="built_in">tie</span>(<span class="number">0</span>);</span><br><span class="line">    <span class="type">int</span> n, q; cin &gt;&gt; n &gt;&gt; q&gt;&gt;mod;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt;= n; i++)</span><br><span class="line">        cin &gt;&gt; a[i];</span><br><span class="line">    <span class="built_in">build</span>(<span class="number">1</span>, <span class="number">1</span>, n);</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; q; i++) &#123;</span><br><span class="line">        <span class="type">int</span> ty; cin &gt;&gt; ty;</span><br><span class="line">        <span class="keyword">if</span> (ty == <span class="number">1</span>) &#123;</span><br><span class="line">            <span class="type">int</span> l,r, k; cin &gt;&gt; l &gt;&gt; r &gt;&gt; k;</span><br><span class="line">            <span class="built_in">modify</span>(<span class="number">1</span>, <span class="number">1</span>, n, l, r, <span class="number">0</span>, k);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span>(ty==<span class="number">2</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="type">int</span> l, r, d; cin &gt;&gt; l &gt;&gt; r &gt;&gt; d;</span><br><span class="line">            <span class="built_in">modify</span>(<span class="number">1</span>, <span class="number">1</span>, n, l, r, d, <span class="number">1</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="type">int</span> l, r; cin &gt;&gt; l &gt;&gt; r;</span><br><span class="line">            <span class="keyword">auto</span> ans = <span class="built_in">query</span>(<span class="number">1</span>, <span class="number">1</span>, n, l, r);</span><br><span class="line">            cout &lt;&lt; ans &lt;&lt; endl;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="优先队列（堆）"><a href="#优先队列（堆）" class="headerlink" title="优先队列（堆）"></a>优先队列（堆）</h2><h3 id="初始化"><a href="#初始化" class="headerlink" title="初始化"></a>初始化</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">struct</span> <span class="title class_">heapStruct</span> &#123;</span><br><span class="line">    <span class="type">int</span> Capacity;<span class="comment">//规模</span></span><br><span class="line">    <span class="type">int</span> Size;<span class="comment">//数据数量</span></span><br><span class="line">    <span class="type">int</span> *data;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function">heapStruct* <span class="title">Init</span><span class="params">(<span class="type">int</span> MaxData)</span> </span>&#123;</span><br><span class="line">    heapStruct* H;</span><br><span class="line">    H = <span class="keyword">new</span> heapStruct;</span><br><span class="line">    <span class="keyword">if</span> (H == <span class="literal">NULL</span>) <span class="built_in">exit</span>(<span class="number">1</span>);</span><br><span class="line">    H-&gt;data = <span class="keyword">new</span> <span class="type">int</span>[(MaxData + <span class="number">1</span>)];</span><br><span class="line">    <span class="keyword">if</span> (H-&gt;data == <span class="literal">NULL</span>) <span class="built_in">exit</span>(<span class="number">1</span>);</span><br><span class="line">    H-&gt;Capacity = MaxData;</span><br><span class="line">    H-&gt;Size = <span class="number">0</span>;</span><br><span class="line">    H-&gt;data[<span class="number">0</span>] = INT_MIN;</span><br><span class="line">    <span class="keyword">return</span> H;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="插入"><a href="#插入" class="headerlink" title="插入"></a>插入</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">insert</span><span class="params">(<span class="type">int</span> x, heapStruct* H)</span> </span>&#123;<span class="comment">//</span></span><br><span class="line">    <span class="type">int</span> i;</span><br><span class="line">    <span class="keyword">for</span> (i = ++H-&gt;Size; H-&gt;data[i / <span class="number">2</span>] &gt; x; i /= <span class="number">2</span>)<span class="comment">//上滤操作，直到找到正确位置</span></span><br><span class="line">        H-&gt;data[i] = H-&gt;data[i / <span class="number">2</span>];</span><br><span class="line">    H-&gt;data[i] = x;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="删除最小元"><a href="#删除最小元" class="headerlink" title="删除最小元"></a>删除最小元</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">int</span> <span class="title">DeleteMin</span><span class="params">(heapStruct* H)</span> </span>&#123;</span><br><span class="line">    <span class="type">int</span> i, child;</span><br><span class="line">    <span class="type">int</span> MinData, LastData;</span><br><span class="line">    MinData = H-&gt;data[<span class="number">1</span>];</span><br><span class="line">    LastData = H-&gt;data[H-&gt;Size--];</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i * <span class="number">2</span> &lt;= H-&gt;Size; i = child) &#123;<span class="comment">//下虑操作</span></span><br><span class="line">        child = i * <span class="number">2</span>;</span><br><span class="line">        <span class="keyword">if</span> (child != H-&gt;Size &amp;&amp; H-&gt;data[child + <span class="number">1</span>] &lt; H-&gt;data[child])  child++;</span><br><span class="line">        <span class="keyword">if</span> (LastData &gt; H-&gt;data[child]) H-&gt;data[i] = H-&gt;data[child];</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    H-&gt;data[i] = LastData;</span><br><span class="line">    <span class="keyword">return</span> MinData;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="哈曼夫树"><a href="#哈曼夫树" class="headerlink" title="哈曼夫树"></a>哈曼夫树</h2><p>哈夫曼树指的就是，WPL最小的二叉树，最优二叉树。通过构建哈夫曼树，我们可以很容易的求出最小WPL。我们可以采用优先队列（堆）的方式，求出最小WPL。</p>
<p>P1090 [NOIP2004 提高组] 合并果子 &#x2F; [USACO06NOV] Fence Repair G - 洛谷 </p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iomanip&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;queue&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	priority_queue&lt;<span class="type">int</span>,vector&lt;<span class="type">int</span>&gt;,greater&lt;<span class="type">int</span>&gt;&gt; h;</span><br><span class="line">	<span class="type">int</span> n,res=<span class="number">0</span>; cin &gt;&gt; n;</span><br><span class="line">	<span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; n; i++)</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="type">int</span> num;</span><br><span class="line">		cin &gt;&gt; num;</span><br><span class="line">		h.<span class="built_in">push</span>(num);</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">while</span> (h.<span class="built_in">size</span>()&gt;<span class="number">1</span>)</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="type">int</span> sum = <span class="number">0</span>;</span><br><span class="line">		sum += h.<span class="built_in">top</span>(); h.<span class="built_in">pop</span>();</span><br><span class="line">		sum += h.<span class="built_in">top</span>(); h.<span class="built_in">pop</span>();</span><br><span class="line">		h.<span class="built_in">push</span>(sum);</span><br><span class="line">		res += sum;</span><br><span class="line">	&#125;</span><br><span class="line">	cout &lt;&lt; res;</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="并查集"><a href="#并查集" class="headerlink" title="并查集"></a>并查集</h2><p>处理不相交可合并的集合关系的数据结构叫做并查集。使用前得初始化。</p>
<h3 id="查询"><a href="#查询" class="headerlink" title="查询"></a>查询</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">int</span> <span class="title">find</span><span class="params">(<span class="type">int</span> n)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  <span class="keyword">return</span> n==f[n]?n:(f[n]=<span class="built_in">find</span>(f[n]));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="合并"><a href="#合并" class="headerlink" title="合并"></a>合并</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">merge</span><span class="params">(<span class="type">int</span> i,<span class="type">int</span> j)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">   f[<span class="built_in">find</span>(i)]=<span class="built_in">find</span>(j);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="典例题"><a href="#典例题" class="headerlink" title="典例题"></a>典例题</h3><p>P1551 亲戚 - 洛谷 | 计算机科学教育新生态 (luogu.com.cn)</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="type">const</span> <span class="type">int</span> MAX = <span class="number">2e6</span>+<span class="number">5</span>;</span><br><span class="line"><span class="type">int</span> f[MAX];</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">init</span><span class="params">(<span class="type">int</span> *f,<span class="type">int</span> n)</span><span class="comment">//初始化并查集</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt;= n; i++)</span><br><span class="line">		f[i] = i;</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">Find</span><span class="params">(<span class="type">int</span> n)</span><span class="comment">//查询父节点</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="keyword">return</span> n == f[n] ? n : (f[n] = <span class="built_in">Find</span>(f[n]));</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">merge</span><span class="params">(<span class="type">int</span> i,<span class="type">int</span> j)</span><span class="comment">//合并</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	f[<span class="built_in">Find</span>(i)] = <span class="built_in">Find</span>(j);</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="type">int</span> p1, p2;</span><br><span class="line">	<span class="type">int</span> n, m, p; cin &gt;&gt; n &gt;&gt; m &gt;&gt; p;</span><br><span class="line">	<span class="built_in">init</span>(f, n);</span><br><span class="line">	<span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt;= m; i++)</span><br><span class="line">	&#123;</span><br><span class="line">		cin &gt;&gt; p1 &gt;&gt; p2;</span><br><span class="line">		<span class="built_in">merge</span>(p1, p2);</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">for</span> (<span class="type">int</span> j = <span class="number">1</span>; j &lt;= p; j++)</span><br><span class="line">	&#123;</span><br><span class="line">		cin &gt;&gt; p1 &gt;&gt; p2;</span><br><span class="line">		<span class="keyword">if</span> (<span class="built_in">Find</span>(p1) == <span class="built_in">Find</span>(p2))</span><br><span class="line">			cout &lt;&lt; <span class="string">&quot;Yes&quot;</span> &lt;&lt; endl;</span><br><span class="line">		<span class="keyword">else</span></span><br><span class="line">			cout &lt;&lt; <span class="string">&quot;No&quot;</span> &lt;&lt; endl;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="哈希表-x2F-散列表"><a href="#哈希表-x2F-散列表" class="headerlink" title="哈希表&#x2F;散列表"></a>哈希表&#x2F;散列表</h2><h3 id="一种字符串hash："><a href="#一种字符串hash：" class="headerlink" title="一种字符串hash："></a>一种字符串hash：</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="type">unsigned</span> <span class="type">long</span> <span class="type">long</span> LL;</span><br><span class="line"><span class="type">int</span> prime = <span class="number">233317</span>;</span><br><span class="line">LL mod = <span class="number">212370440130137957ll</span>,base=<span class="number">123</span>;</span><br><span class="line"><span class="function">LL <span class="title">Hash</span><span class="params">(<span class="type">char</span> s[])</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="type">int</span> len = <span class="built_in">strlen</span>(s);</span><br><span class="line">    LL res = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; len; i++)</span><br><span class="line">        res = (res * base + (LL)s[i]) % mod + prime;</span><br><span class="line">    <span class="keyword">return</span> res;    </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="STL-hash"><a href="#STL-hash" class="headerlink" title="STL hash"></a>STL hash</h3><p>C++ STL 自带hash。</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    string str = <span class="string">&quot;Cirno is the strongest&quot;</span>;</span><br><span class="line">    hash&lt;string&gt; hash_fn;</span><br><span class="line">    <span class="type">size_t</span> str_hash = <span class="built_in">hash_fn</span>(str);</span><br><span class="line">    cout &lt;&lt; str_hash;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="解决冲突的方法"><a href="#解决冲突的方法" class="headerlink" title="解决冲突的方法"></a>解决冲突的方法</h3><h4 id="分离链接法"><a href="#分离链接法" class="headerlink" title="分离链接法"></a>分离链接法</h4><h2 id="图"><a href="#图" class="headerlink" title="图"></a>图</h2><h3 id="邻接矩阵"><a href="#邻接矩阵" class="headerlink" title="邻接矩阵"></a>邻接矩阵</h3><h3 id="邻接表"><a href="#邻接表" class="headerlink" title="邻接表"></a>邻接表</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="type">const</span> <span class="type">int</span> MAX = <span class="number">1000</span>;</span><br><span class="line"><span class="type">int</span> m, n;<span class="comment">//图中m顶点，n条边。</span></span><br><span class="line">vector&lt;pair&lt;<span class="type">int</span>, <span class="type">int</span>&gt;&gt; P[MAX];</span><br><span class="line"><span class="type">int</span> v[MAX][MAX];</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	cin &gt;&gt; m &gt;&gt; n;</span><br><span class="line">	<span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt;= m; i++)</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="type">int</span> u, v, l; cin &gt;&gt; u &gt;&gt; v &gt;&gt; l;</span><br><span class="line">		P[u].<span class="built_in">push_back</span>(&#123; v,l &#125;);</span><br><span class="line">		<span class="comment">//P[v].push_back(&#123;u,l&#125;)</span></span><br><span class="line">		<span class="comment">//如果是无向图，则还需要将终点，起始点颠倒过来存储一下</span></span><br><span class="line">	&#125;</span><br><span class="line"> </span><br><span class="line">	<span class="comment">//将邻接表转换为邻接矩阵</span></span><br><span class="line">	<span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt;= m; i++)</span><br><span class="line">		<span class="keyword">for</span> (<span class="type">int</span> j = <span class="number">0</span>; j &lt; P[i].<span class="built_in">size</span>(); j++)</span><br><span class="line">			v[i][P[i][j].first] = P[i][j].second;</span><br><span class="line">	<span class="comment">//对于邻接矩阵v[i][j]，j就是终点，即为P[i][j].first，</span></span><br><span class="line">	<span class="comment">//其储存的值为边权，也就是P[i][j].second</span></span><br><span class="line"> </span><br><span class="line"> </span><br><span class="line">	<span class="comment">//output</span></span><br><span class="line">	<span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt;= m; i++) &#123;</span><br><span class="line">		<span class="keyword">for</span> (<span class="type">int</span> j = <span class="number">1</span>; j &lt;= m; j++)</span><br><span class="line">			cout &lt;&lt; v[i][j] &lt;&lt; <span class="string">&quot; &quot;</span>;</span><br><span class="line">		cout &lt;&lt; endl;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="图的遍历"><a href="#图的遍历" class="headerlink" title="图的遍历"></a>图的遍历</h3><h4 id="DFS遍历"><a href="#DFS遍历" class="headerlink" title="DFS遍历"></a>DFS遍历</h4><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">dfs</span><span class="params">(<span class="type">int</span> x)</span> </span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	vis[x] = <span class="literal">true</span>;</span><br><span class="line">	cout &lt;&lt; x &lt;&lt; <span class="string">&quot; &quot;</span>; </span><br><span class="line">	<span class="keyword">for</span> (<span class="type">int</span> i=<span class="number">0</span>; i&lt;P[x].<span class="built_in">size</span>(); i++)</span><br><span class="line">		<span class="keyword">if</span> (!vis[P[x][i]]) </span><br><span class="line">            <span class="built_in">dfs</span>(P[x][i]);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="BFS遍历"><a href="#BFS遍历" class="headerlink" title="BFS遍历"></a>BFS遍历</h4><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">queue&lt;<span class="type">int</span>&gt; q;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">bfs</span><span class="params">(<span class="type">int</span> x)</span> </span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="built_in">memset</span>(vis, <span class="literal">false</span>, <span class="built_in">sizeof</span>(vis));</span><br><span class="line">	vis[x] = <span class="literal">true</span>;</span><br><span class="line">	q.<span class="built_in">push</span>(x);</span><br><span class="line">	<span class="keyword">while</span> (!q.<span class="built_in">empty</span>())</span><br><span class="line">     &#123;</span><br><span class="line">		<span class="type">int</span> v = q.<span class="built_in">front</span>();</span><br><span class="line">		q.<span class="built_in">pop</span>();</span><br><span class="line">		cout &lt;&lt; v &lt;&lt; <span class="string">&quot; &quot;</span>;</span><br><span class="line">		<span class="keyword">for</span> (<span class="type">int</span> i=<span class="number">0</span>; i&lt;P[v].<span class="built_in">size</span>(); i++) </span><br><span class="line">			<span class="keyword">if</span> (!vis[P[v][i]]) </span><br><span class="line">            &#123;</span><br><span class="line">				vis[P[v][i]] = <span class="literal">true</span>;</span><br><span class="line">				q.<span class="built_in">push</span>(P[v][i]);</span><br><span class="line">			&#125;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="DAG与拓扑排序"><a href="#DAG与拓扑排序" class="headerlink" title="DAG与拓扑排序"></a>DAG与拓扑排序</h3><p>DAG：对于一个图而言，如果这个图是没有环的，但是边是有方向的，那么就称之为有向无环图，即DAG。</p>
<p>拓扑排序：拓扑排序就是在DAG的基础上对点进行排序，使得在搜到点x时所有能到达点x的点y已经被搜过了。<br>其具体实现流程如下：<br>1.将所有入度为0的点加入处理队列<br>2.将处于队头的点x取出，遍历x所能到达的所有点y。<br>3. 对于每一个y，删除从点x到点y的边。<br>4.如果点y的入度减为0了，说明说明所有能到y的点都被计算过了，再将点y加入处理队列。<br>5.重复2，直到队列为空。<br>一道用到拓扑排序的经典例题：<br>P4017 最大食物链计数 - 洛谷 | 计算机科学教育新生态 (luogu.com.cn)</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="type">const</span> <span class="type">int</span> MAX = <span class="number">5e5</span> + <span class="number">10</span>;</span><br><span class="line"><span class="type">const</span> <span class="type">int</span> MOD = <span class="number">80112002</span>;</span><br><span class="line">vector&lt;<span class="type">int</span>&gt; V[MAX];</span><br><span class="line">queue&lt;<span class="type">int</span>&gt; Q;</span><br><span class="line"><span class="type">int</span> ind[MAX], outd[MAX], f[MAX];<span class="comment">//入度，出度，食物链数</span></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="type">int</span> n, m, res = <span class="number">0</span>; cin &gt;&gt; n &gt;&gt; m;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; m; i++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="type">int</span> x, y; cin &gt;&gt; x &gt;&gt; y;</span><br><span class="line">        outd[x]++; ind[y]++;</span><br><span class="line">        V[x].<span class="built_in">push_back</span>(y);</span><br><span class="line">    &#125;</span><br><span class="line"> </span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt;= n; i++) &#123;</span><br><span class="line">        <span class="keyword">if</span> (ind[i] == <span class="number">0</span>)</span><br><span class="line">            Q.<span class="built_in">push</span>(i),f[i]=<span class="number">1</span>;</span><br><span class="line">    &#125;<span class="comment">//将入度为0的数据入队</span></span><br><span class="line"> </span><br><span class="line">    <span class="keyword">while</span> (!Q.<span class="built_in">empty</span>()) &#123;</span><br><span class="line">        <span class="type">int</span> x = Q.<span class="built_in">front</span>(); Q.<span class="built_in">pop</span>();</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; V[x].<span class="built_in">size</span>(); i++) &#123;</span><br><span class="line">            <span class="type">int</span> y = V[x][i];</span><br><span class="line">            f[y] = (f[x] + f[y]) % MOD;</span><br><span class="line">            ind[y]--;</span><br><span class="line">            <span class="keyword">if</span> (ind[y] == <span class="number">0</span>)</span><br><span class="line">                Q.<span class="built_in">push</span>(y);<span class="comment">//入度为0，就入队</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"> </span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt;= n; i++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span> (outd[i] == <span class="number">0</span>)</span><br><span class="line">            res = (res + f[i]) % MOD;</span><br><span class="line">    &#125;</span><br><span class="line">    cout &lt;&lt; res;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="最短路问题"><a href="#最短路问题" class="headerlink" title="最短路问题"></a>最短路问题</h3><h4 id="无权最短路问题"><a href="#无权最短路问题" class="headerlink" title="无权最短路问题"></a>无权最短路问题</h4><p>运用到了BFS ，没有访问到的标记为INF。</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="type">const</span> <span class="type">int</span> MAX = <span class="number">1e6</span>;</span><br><span class="line"><span class="type">const</span> <span class="type">int</span> MOD = <span class="number">100003</span>;</span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">Node</span> &#123;</span><br><span class="line">    <span class="type">bool</span> vis=<span class="literal">false</span>;</span><br><span class="line">    <span class="type">int</span> Dist = INFINITY;</span><br><span class="line">    <span class="type">int</span> path;</span><br><span class="line">&#125;;</span><br><span class="line">vector&lt;<span class="type">int</span>&gt; V[MAX];</span><br><span class="line">queue&lt;<span class="type">int</span>&gt; Q;</span><br><span class="line">Node NodeArr[MAX];</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="type">int</span> m, n; cin &gt;&gt; m &gt;&gt; n;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt;= n; i++) &#123;</span><br><span class="line">        <span class="type">int</span> x, y; cin &gt;&gt; x &gt;&gt; y;</span><br><span class="line">        V[x].<span class="built_in">push_back</span>(y);</span><br><span class="line">        V[y].<span class="built_in">push_back</span>(x);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt;= m; i++) &#123;</span><br><span class="line">        NodeArr[i].vis = <span class="literal">false</span>;</span><br><span class="line">        NodeArr[i].Dist = INFINITY;</span><br><span class="line">    &#125;</span><br><span class="line">    Q.<span class="built_in">push</span>(<span class="number">1</span>); NodeArr[<span class="number">1</span>].Dist = <span class="number">0</span>; NodeArr[<span class="number">1</span>].vis = <span class="literal">true</span>;</span><br><span class="line">    <span class="keyword">while</span> (!Q.<span class="built_in">empty</span>()) &#123;</span><br><span class="line">        <span class="type">int</span> x = Q.<span class="built_in">front</span>(); Q.<span class="built_in">pop</span>();</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; V[x].<span class="built_in">size</span>(); i++) &#123;</span><br><span class="line">            <span class="keyword">if</span> (NodeArr[V[x][i]].vis==<span class="literal">false</span>) &#123;</span><br><span class="line">                NodeArr[V[x][i]].vis = <span class="literal">true</span>;</span><br><span class="line">                NodeArr[V[x][i]].Dist = NodeArr[x].Dist + <span class="number">1</span>;</span><br><span class="line">                NodeArr[V[x][i]].path = x;</span><br><span class="line">                Q.<span class="built_in">push</span>(V[x][i]);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt;= m; i++)</span><br><span class="line">        cout &lt;&lt; NodeArr[i].Dist &lt;&lt; endl;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>P1144 最短路计数 - 洛谷 | 计算机科学教育新生态 (luogu.com.cn)<br>以下为这题题解，这题除了可以求出1到各个结点的无权最短路长度以外，还可以求出到不同结点一共有多少种最短路情况。</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="type">const</span> <span class="type">int</span> MAX = <span class="number">1e6</span>;</span><br><span class="line"><span class="type">const</span> <span class="type">int</span> MOD = <span class="number">100003</span>;</span><br><span class="line">vector&lt;<span class="type">int</span>&gt; V[MAX];</span><br><span class="line">queue&lt;<span class="type">int</span>&gt; Q;</span><br><span class="line"><span class="type">bool</span> judge[MAX];</span><br><span class="line"><span class="type">int</span> cnt[MAX],depth[MAX];</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">	<span class="type">int</span> m, n; cin &gt;&gt; m &gt;&gt; n;</span><br><span class="line">	<span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt;= n; i++) &#123;</span><br><span class="line">		<span class="type">int</span> x, y; cin &gt;&gt; x &gt;&gt; y;</span><br><span class="line">		V[x].<span class="built_in">push_back</span>(y);</span><br><span class="line">		V[y].<span class="built_in">push_back</span>(x);</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt;= m; i++) <span class="built_in">sort</span>(V[i].<span class="built_in">begin</span>(), V[i].<span class="built_in">end</span>());</span><br><span class="line">	Q.<span class="built_in">push</span>(<span class="number">1</span>); judge[<span class="number">1</span>] = <span class="number">1</span>; cnt[<span class="number">1</span>] = <span class="number">1</span>;</span><br><span class="line">	<span class="keyword">while</span> (!Q.<span class="built_in">empty</span>()) &#123;</span><br><span class="line">		<span class="type">int</span> x = Q.<span class="built_in">front</span>(); Q.<span class="built_in">pop</span>();</span><br><span class="line">		<span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; V[x].<span class="built_in">size</span>(); i++) &#123;</span><br><span class="line">			<span class="type">int</span> n = V[x][i];</span><br><span class="line">			<span class="keyword">if</span> (!judge[n]) &#123;</span><br><span class="line">				judge[n] = <span class="number">1</span>;</span><br><span class="line">				depth[n] = depth[x] + <span class="number">1</span>;</span><br><span class="line">				Q.<span class="built_in">push</span>(n);</span><br><span class="line">			&#125;</span><br><span class="line">			<span class="keyword">if</span>(depth[n]==depth[x]+<span class="number">1</span>) cnt[n]=(cnt[n]+cnt[x])%MOD;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt;= m; i++)</span><br><span class="line">		cout &lt;&lt; cnt[i] &lt;&lt; endl;</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="Dijkstra算法"><a href="#Dijkstra算法" class="headerlink" title="Dijkstra算法"></a>Dijkstra算法</h4><p>基于贪心思想，使用堆优化，可以求得有权最短路径的结果</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="type">const</span> <span class="type">int</span> MAX = <span class="number">2e5</span>+<span class="number">5</span>;</span><br><span class="line"><span class="type">const</span> <span class="type">int</span> INF = <span class="number">2147483647</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">Node</span> &#123;</span><br><span class="line">    <span class="type">int</span> dist = INF;</span><br><span class="line">    <span class="type">bool</span> vis = <span class="literal">false</span>;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> pair&lt;<span class="type">int</span>, <span class="type">int</span>&gt; pll;</span><br><span class="line"></span><br><span class="line">Node NodeArr[MAX];</span><br><span class="line">vector&lt;pll&gt; V[MAX];</span><br><span class="line">priority_queue&lt;pll,vector&lt;pll&gt;,greater&lt;pll&gt;&gt; Q;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">Dijkstra</span><span class="params">(vector&lt;pair&lt;<span class="type">int</span>, <span class="type">int</span>&gt;&gt; V[], <span class="type">int</span> start)</span> </span>&#123;</span><br><span class="line">    NodeArr[start].dist = <span class="number">0</span>;</span><br><span class="line">    Q.<span class="built_in">push</span>(&#123; <span class="number">0</span>,start &#125;); </span><br><span class="line">    <span class="keyword">while</span> (!Q.<span class="built_in">empty</span>()) &#123;</span><br><span class="line">        <span class="type">int</span> x = Q.<span class="built_in">top</span>().second; Q.<span class="built_in">pop</span>();</span><br><span class="line">        <span class="keyword">if</span> (NodeArr[x].vis)</span><br><span class="line">            <span class="keyword">continue</span>;</span><br><span class="line">        NodeArr[x].vis = <span class="literal">true</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; V[x].<span class="built_in">size</span>(); i++)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="type">int</span> temp = NodeArr[x].dist + V[x][i].first;</span><br><span class="line">            <span class="keyword">if</span> (NodeArr[V[x][i].second].dist &gt; temp)</span><br><span class="line">                NodeArr[V[x][i].second].dist = temp,Q.<span class="built_in">push</span>(&#123; NodeArr[V[x][i].second].dist, V[x][i].second &#125;);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;.</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="type">int</span> n, m, s; cin &gt;&gt; n &gt;&gt; m &gt;&gt; s;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt;= m; i++) &#123;</span><br><span class="line">        <span class="type">int</span> x, y, l; <span class="built_in">scanf</span>(<span class="string">&quot;%d%d%d&quot;</span>, &amp;x, &amp;y, &amp;l);</span><br><span class="line">            V[x].<span class="built_in">push_back</span>(&#123; l, y &#125;);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">Dijkstra</span>(V, s);</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt;= n; i++)</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;%d &quot;</span>, NodeArr[i].dist);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="floyd算法"><a href="#floyd算法" class="headerlink" title="floyd算法"></a>floyd算法</h4><p>可以求出任意两节点之间的最短路径，因此它是比Dijkstra更一般的算法。</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="type">const</span> <span class="type">int</span> MAX = <span class="number">5e3</span> + <span class="number">5</span>;</span><br><span class="line"><span class="type">const</span> <span class="type">int</span> INF = <span class="number">2e5</span>;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> Martix[MAX][MAX];</span><br><span class="line"><span class="type">int</span> n, m;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> pathMatirx[MAX][MAX];<span class="comment">//存储中间点</span></span><br><span class="line"><span class="type">int</span> shortPath[MAX][MAX];<span class="comment">//存储两边之间最小值</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">floyd</span><span class="params">(<span class="type">int</span> x,<span class="type">int</span> y)</span> </span>&#123;<span class="comment">//起点，终点</span></span><br><span class="line"></span><br><span class="line">	<span class="comment">//init</span></span><br><span class="line">	<span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt;= n; i++)</span><br><span class="line">		<span class="keyword">for</span> (<span class="type">int</span> j = <span class="number">1</span>; j &lt;= n; j++) &#123;</span><br><span class="line">			pathMatirx[i][j] = j;</span><br><span class="line">			shortPath[i][j] = Martix[i][j];</span><br><span class="line">		&#125;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt;= n; i++)</span><br><span class="line">		<span class="keyword">for</span> (<span class="type">int</span> j = <span class="number">1</span>; j &lt;= n; j++)</span><br><span class="line">			<span class="keyword">for</span> (<span class="type">int</span> k = <span class="number">1</span>; k &lt;= n; k++) &#123;</span><br><span class="line">				<span class="keyword">if</span> (shortPath[j][k] &gt; (shortPath[j][i] + shortPath[i][k])) &#123;</span><br><span class="line">					shortPath[j][k] = shortPath[j][i] + shortPath[i][k];</span><br><span class="line">					pathMatirx[j][k] = pathMatirx[j][i];</span><br><span class="line">				&#125;</span><br><span class="line">			&#125;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt;= n; i++) &#123;</span><br><span class="line">		<span class="keyword">for</span> (<span class="type">int</span> j = <span class="number">1</span>; j &lt;= n; j++)</span><br><span class="line">			cout &lt;&lt; shortPath[i][j] &lt;&lt; <span class="string">&quot; &quot;</span>;</span><br><span class="line">		cout &lt;&lt; endl;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	cout &lt;&lt; x &lt;&lt; <span class="string">&quot; &quot;</span>;</span><br><span class="line">	<span class="type">int</span> k = pathMatirx[x][y];</span><br><span class="line">	<span class="keyword">while</span> (k != y) &#123;</span><br><span class="line">		cout &lt;&lt; k &lt;&lt; <span class="string">&quot; &quot;</span>;</span><br><span class="line">		k = pathMatirx[k][y];</span><br><span class="line">	&#125;</span><br><span class="line">	cout &lt;&lt; y &lt;&lt; endl;</span><br><span class="line">	cout &lt;&lt; shortPath[x][y] &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">	std::ios::<span class="built_in">sync_with_stdio</span>(<span class="literal">false</span>);</span><br><span class="line">	cin.<span class="built_in">tie</span>(<span class="number">0</span>);</span><br><span class="line">	cin &gt;&gt; n &gt;&gt; m;</span><br><span class="line">	<span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt;= n; i++)</span><br><span class="line">		<span class="keyword">for</span> (<span class="type">int</span> j = <span class="number">1</span>; j &lt;= n; j++) &#123;</span><br><span class="line">			<span class="keyword">if</span> (i == j)</span><br><span class="line">				Martix[i][j] = <span class="number">0</span>;</span><br><span class="line">			<span class="keyword">else</span></span><br><span class="line">				Martix[i][j] = INF;</span><br><span class="line">		&#125;</span><br><span class="line">	<span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt;= m; i++) &#123;</span><br><span class="line">		<span class="type">int</span> x, y, v; cin &gt;&gt; x &gt;&gt; y &gt;&gt; v;</span><br><span class="line">		Martix[x][y] = v;</span><br><span class="line">		Martix[y][x] = v;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="built_in">floyd</span>(<span class="number">1</span>,<span class="number">2</span>);</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="最小生成树"><a href="#最小生成树" class="headerlink" title="最小生成树"></a>最小生成树</h3><h4 id="Prim算法"><a href="#Prim算法" class="headerlink" title="Prim算法"></a>Prim算法</h4><p>算法和dijkstra非常像，甚至可以说是一模一样.</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="type">const</span> <span class="type">int</span> MAX = <span class="number">2e5</span> + <span class="number">5</span>;</span><br><span class="line"><span class="type">const</span> <span class="type">int</span> INF = <span class="number">1</span>&lt;&lt;<span class="number">30</span>;</span><br><span class="line"><span class="keyword">typedef</span> pair&lt;<span class="type">long</span> , <span class="type">long</span> &gt; pll;<span class="comment">//权重，终点</span></span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">Node</span> &#123;</span><br><span class="line">	<span class="type">long</span> <span class="type">long</span> dist = INF;</span><br><span class="line">	<span class="type">bool</span> vis = <span class="literal">false</span>;</span><br><span class="line">&#125; node[MAX];</span><br><span class="line"></span><br><span class="line">priority_queue&lt;pll, vector&lt;pll&gt;, greater&lt;pll&gt;&gt; q;</span><br><span class="line">vector&lt;pll&gt; V[MAX];</span><br><span class="line"><span class="type">int</span> N, M;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">prim</span><span class="params">()</span> </span>&#123;</span><br><span class="line">	<span class="type">int</span> ans = <span class="number">0</span>, tot = <span class="number">0</span>;</span><br><span class="line">	q.<span class="built_in">push</span>(&#123; <span class="number">0</span>,<span class="number">1</span> &#125;);</span><br><span class="line">	node[<span class="number">1</span>].dist = <span class="number">0</span>;</span><br><span class="line">	<span class="keyword">while</span> (!q.<span class="built_in">empty</span>()) &#123;</span><br><span class="line">		pll x = q.<span class="built_in">top</span>();</span><br><span class="line">		q.<span class="built_in">pop</span>();</span><br><span class="line">		<span class="keyword">if</span> (node[x.second].vis)</span><br><span class="line">			<span class="keyword">continue</span>;</span><br><span class="line">		tot++;</span><br><span class="line">		ans += node[x.second].dist;</span><br><span class="line">		node[x.second].vis = <span class="literal">true</span>;</span><br><span class="line">		<span class="keyword">for</span> (<span class="keyword">auto</span> i : V[x.second]) &#123;</span><br><span class="line">			<span class="keyword">if</span> (!node[i.second].vis &amp;&amp; i.first &lt; node[i.second].dist) &#123;</span><br><span class="line">				node[i.second].dist = i.first;</span><br><span class="line">				q.<span class="built_in">push</span>(&#123; node[i.second].dist,i.second &#125;);</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">if</span> (tot != N)</span><br><span class="line">		cout &lt;&lt; <span class="string">&quot;orz&quot;</span> &lt;&lt; endl;</span><br><span class="line">	<span class="keyword">else</span></span><br><span class="line">		cout &lt;&lt; ans &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">(<span class="type">void</span>)</span> </span>&#123;</span><br><span class="line">	std::ios::<span class="built_in">sync_with_stdio</span>(<span class="literal">false</span>);</span><br><span class="line">	cin.<span class="built_in">tie</span>(<span class="number">0</span>); cout.<span class="built_in">tie</span>(<span class="number">0</span>);</span><br><span class="line">	cin &gt;&gt; N &gt;&gt; M;</span><br><span class="line">	<span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt;= M; i++) &#123;</span><br><span class="line">		<span class="type">int</span> x, y, l;</span><br><span class="line">		cin &gt;&gt; x &gt;&gt; y &gt;&gt; l;</span><br><span class="line">		V[x].<span class="built_in">push_back</span>(&#123; l,y &#125;);</span><br><span class="line">		V[y].<span class="built_in">push_back</span>(&#123; l,x &#125;);</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="built_in">prim</span>();</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="Kruskal算法"><a href="#Kruskal算法" class="headerlink" title="Kruskal算法"></a>Kruskal算法</h4><p>也是一种求最小生成树的算法，使用到了并查集的知识，将结点根据权值有小到大进行排列，从第一个结点开始遍历，如果结点起点和终点不属于同一个集合，则将两点合并到同一个集合，并且使计数cnt–，ans增加起点到终点的权值，最后可以到达求最小生成树的目的。其基本思想是贪心。</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="type">const</span> <span class="type">int</span> MAX=<span class="number">2e5</span>+<span class="number">5</span>;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> m,n,f[MAX];</span><br><span class="line"></span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">Node</span>&#123;</span><br><span class="line">	<span class="type">int</span> x,y,v;</span><br><span class="line">	<span class="type">bool</span> <span class="keyword">operator</span>&lt;(<span class="type">const</span> Node&amp; a) <span class="type">const</span>&#123;</span><br><span class="line">		<span class="keyword">return</span> v&lt;a.v;</span><br><span class="line">	&#125;</span><br><span class="line">&#125; M[MAX];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">find</span><span class="params">(<span class="type">int</span> n)</span></span>&#123;</span><br><span class="line">	<span class="keyword">return</span> n==f[n]?n:(f[n]=<span class="built_in">find</span>(f[n]));</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">merge</span><span class="params">(<span class="type">int</span> x,<span class="type">int</span> y)</span></span>&#123;</span><br><span class="line">	f[<span class="built_in">find</span>(x)]=<span class="built_in">find</span>(y);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">init</span><span class="params">(<span class="type">int</span> n)</span></span>&#123;</span><br><span class="line">	<span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=n;i++)</span><br><span class="line">		f[i]=i;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">Kurskal</span><span class="params">()</span></span>&#123;</span><br><span class="line">	<span class="built_in">init</span>(m);</span><br><span class="line">	<span class="built_in">sort</span>(M+<span class="number">1</span>,M+<span class="number">1</span>+n);</span><br><span class="line">	<span class="type">int</span> ans=<span class="number">0</span>,cnt=m;</span><br><span class="line">	<span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=n;i++)&#123;</span><br><span class="line">		<span class="type">int</span> x=<span class="built_in">find</span>(M[i].x),y=<span class="built_in">find</span>(M[i].y);	</span><br><span class="line">		<span class="keyword">if</span>(x!=y)&#123;</span><br><span class="line">			<span class="built_in">merge</span>(x,y);</span><br><span class="line">			ans+=M[i].v;</span><br><span class="line">			cnt--;</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">if</span>(cnt==<span class="number">1</span>)</span><br><span class="line">			<span class="keyword">break</span>;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">if</span>(cnt!=<span class="number">1</span>)</span><br><span class="line">		cout&lt;&lt;<span class="string">&quot;orz&quot;</span>&lt;&lt;endl;</span><br><span class="line">	<span class="keyword">else</span> </span><br><span class="line">		cout&lt;&lt;ans&lt;&lt;endl;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">	cin&gt;&gt;m&gt;&gt;n;</span><br><span class="line">	<span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=n;i++)&#123;</span><br><span class="line">		cin&gt;&gt;M[i].x&gt;&gt;M[i].y&gt;&gt;M[i].v;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="built_in">Kurskal</span>();</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h1 id="java快读类"><a href="#java快读类" class="headerlink" title="java快读类"></a>java快读类</h1><p>  鉴定为十分有用</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/** 快速输入类 */</span></span><br><span class="line"><span class="keyword">static</span> <span class="keyword">class</span> <span class="title class_">Reader</span> &#123;</span><br><span class="line">    <span class="keyword">static</span> <span class="type">BufferedReader</span> <span class="variable">reader</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">BufferedReader</span>(<span class="keyword">new</span> <span class="title class_">InputStreamReader</span>(System.in));</span><br><span class="line">    <span class="keyword">static</span> <span class="type">StringTokenizer</span> <span class="variable">tokenizer</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">StringTokenizer</span>(<span class="string">&quot;&quot;</span>);</span><br><span class="line">    <span class="comment">/** 获取下一段文本 */</span></span><br><span class="line">    <span class="keyword">static</span> String <span class="title function_">next</span><span class="params">()</span> <span class="keyword">throws</span> IOException &#123;</span><br><span class="line">        <span class="keyword">while</span> ( ! tokenizer.hasMoreTokens() ) &#123;</span><br><span class="line">            tokenizer = <span class="keyword">new</span> <span class="title class_">StringTokenizer</span>(reader.readLine());</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> tokenizer.nextToken();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">static</span> <span class="type">int</span> <span class="title function_">nextInt</span><span class="params">()</span> <span class="keyword">throws</span> IOException &#123;</span><br><span class="line">        <span class="keyword">return</span> Integer.parseInt( next() );</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">static</span> <span class="type">double</span> <span class="title function_">nextDouble</span><span class="params">()</span> <span class="keyword">throws</span> IOException &#123;</span><br><span class="line">        <span class="keyword">return</span> Double.parseDouble( next() );</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></article><div class="post-copyright"><div class="post-copyright__author"><span class="post-copyright-meta">文章作者: </span><span class="post-copyright-info"><a href="http://example.com">TheWiseCirno</a></span></div><div class="post-copyright__type"><span class="post-copyright-meta">文章链接: </span><span class="post-copyright-info"><a href="http://example.com/2023/07/01/%E7%AE%97%E6%B3%95%E6%9D%BF%E5%AD%90%E6%B1%87%E6%80%BB/">http://example.com/2023/07/01/%E7%AE%97%E6%B3%95%E6%9D%BF%E5%AD%90%E6%B1%87%E6%80%BB/</a></span></div><div class="post-copyright__notice"><span class="post-copyright-meta">版权声明: </span><span class="post-copyright-info">本博客所有文章除特别声明外，均采用 <a href="https://creativecommons.org/licenses/by-nc-sa/4.0/" target="_blank">CC BY-NC-SA 4.0</a> 许可协议。转载请注明来自 <a href="http://example.com" target="_blank">Cirno's Blog</a>！</span></div></div><div class="tag_share"><div class="post-meta__tag-list"><a class="post-meta__tags" href="/tags/%E7%AE%97%E6%B3%95-C-Java/">算法,C++,Java</a></div><div class="post_share"><div class="social-share" data-image="/img/avatar.jpg" data-sites="facebook,twitter,wechat,weibo,qq"></div><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/butterfly-extsrc/sharejs/dist/css/share.min.css" media="print" onload="this.media='all'"><script src="https://cdn.jsdelivr.net/npm/butterfly-extsrc/sharejs/dist/js/social-share.min.js" defer></script></div></div><nav class="pagination-post" id="pagination"><div class="next-post pull-full"><a href="/2023/07/01/Welcome%20to%20My%20blog/" title="Welcome to Cirno's Blog!!"><div class="cover" style="background: var(--default-bg-color)"></div><div class="pagination-info"><div class="label">下一篇</div><div class="next_info">Welcome to Cirno's Blog!!</div></div></a></div></nav></div><div class="aside-content" id="aside-content"><div class="card-widget card-info"><div class="is-center"><div class="avatar-img"><img src="/img/avatar.jpg" onerror="this.onerror=null;this.src='/img/friend_404.gif'" alt="avatar"/></div><div class="author-info__name">TheWiseCirno</div><div class="author-info__description">你说得对，但是...</div></div><div class="card-info-data site-data is-center"><a href="/archives/"><div class="headline">文章</div><div class="length-num">2</div></a><a href="/tags/"><div class="headline">标签</div><div class="length-num">1</div></a><a href="/categories/"><div class="headline">分类</div><div class="length-num">0</div></a></div><a id="card-info-btn" target="_blank" rel="noopener" href="https://github.com/xxxxxx"><i class="fab fa-github"></i><span>Follow Me</span></a></div><div class="card-widget card-announcement"><div class="item-headline"><i class="fas fa-bullhorn fa-shake"></i><span>公告</span></div><div class="announcement_content">This is my Blog</div></div><div class="sticky_layout"><div class="card-widget" id="card-toc"><div class="item-headline"><i class="fas fa-stream"></i><span>目录</span><span class="toc-percentage"></span></div><div class="toc-content"><ol class="toc"><li class="toc-item toc-level-1"><a class="toc-link" href="#%E6%8E%92%E5%BA%8F%E7%AE%97%E6%B3%95"><span class="toc-number">1.</span> <span class="toc-text">排序算法</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E8%AE%A1%E6%95%B0%E6%8E%92%E5%BA%8F"><span class="toc-number">1.1.</span> <span class="toc-text">计数排序</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%B8%8C%E5%B0%94%E6%8E%92%E5%BA%8F"><span class="toc-number">1.2.</span> <span class="toc-text">希尔排序</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%BD%92%E5%B9%B6%E6%8E%92%E5%BA%8F"><span class="toc-number">1.3.</span> <span class="toc-text">归并排序</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%8F%92%E5%85%A5%E6%8E%92%E5%BA%8F"><span class="toc-number">1.4.</span> <span class="toc-text">插入排序</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%BF%AB%E9%80%9F%E6%8E%92%E5%BA%8F"><span class="toc-number">1.5.</span> <span class="toc-text">快速排序</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%9F%BA%E6%95%B0%E6%8E%92%E5%BA%8F"><span class="toc-number">1.6.</span> <span class="toc-text">基数排序</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%A0%86%E6%8E%92%E5%BA%8F"><span class="toc-number">1.7.</span> <span class="toc-text">堆排序</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E5%B7%AE%E5%88%86%E4%B8%8E%E5%89%8D%E7%BC%80%E5%92%8C"><span class="toc-number">2.</span> <span class="toc-text">差分与前缀和</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E9%AB%98%E7%B2%BE%E5%BA%A6%E7%AE%97%E6%B3%95"><span class="toc-number">3.</span> <span class="toc-text">高精度算法</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E9%AB%98%E7%B2%BE%E5%8A%A0"><span class="toc-number">3.1.</span> <span class="toc-text">高精加</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E9%AB%98%E7%B2%BE%E4%B9%98"><span class="toc-number">3.2.</span> <span class="toc-text">高精乘</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E6%9E%9A%E4%B8%BE"><span class="toc-number">4.</span> <span class="toc-text">枚举</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E4%BA%8C%E8%BF%9B%E5%88%B6%E6%9E%9A%E4%B8%BE"><span class="toc-number">4.1.</span> <span class="toc-text">二进制枚举</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92"><span class="toc-number">5.</span> <span class="toc-text">动态规划</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E8%83%8C%E5%8C%85dp"><span class="toc-number">5.1.</span> <span class="toc-text">背包dp</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#01%E8%83%8C%E5%8C%85"><span class="toc-number">5.1.1.</span> <span class="toc-text">01背包</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%AE%8C%E5%85%A8%E8%83%8C%E5%8C%85"><span class="toc-number">5.1.2.</span> <span class="toc-text">完全背包</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%A4%9A%E9%87%8D%E8%83%8C%E5%8C%85"><span class="toc-number">5.1.3.</span> <span class="toc-text">多重背包</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E4%BA%8C%E8%BF%9B%E5%88%B6%E4%BC%98%E5%8C%96"><span class="toc-number">5.1.3.1.</span> <span class="toc-text">二进制优化</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%B7%B7%E5%90%88%E8%83%8C%E5%8C%85"><span class="toc-number">5.1.4.</span> <span class="toc-text">混合背包</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%88%86%E7%BB%84%E8%83%8C%E5%8C%85"><span class="toc-number">5.1.5.</span> <span class="toc-text">分组背包</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%8D%95%E8%B0%83%E9%98%9F%E5%88%97%E4%BC%98%E5%8C%96"><span class="toc-number">5.1.6.</span> <span class="toc-text">单调队列优化</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%8C%BA%E9%97%B4dp"><span class="toc-number">5.2.</span> <span class="toc-text">区间dp</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%A0%91%E5%BD%A2dp"><span class="toc-number">5.3.</span> <span class="toc-text">树形dp</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E7%8A%B6%E5%8E%8Bdp"><span class="toc-number">5.4.</span> <span class="toc-text">状压dp</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%95%B0%E4%BD%8Ddp"><span class="toc-number">5.5.</span> <span class="toc-text">数位dp</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E6%90%9C%E7%B4%A2"><span class="toc-number">6.</span> <span class="toc-text">搜索</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#DFS%E5%9F%BA%E6%9C%AC%E5%BD%A2%E5%BC%8F"><span class="toc-number">6.1.</span> <span class="toc-text">DFS基本形式</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#DFS%E5%9F%BA%E6%9C%AC%E8%BF%90%E7%94%A8%EF%BC%9AN%E7%9A%87%E5%90%8E%E9%97%AE%E9%A2%98"><span class="toc-number">6.2.</span> <span class="toc-text">DFS基本运用：N皇后问题</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#BFS%E5%9F%BA%E6%9C%AC%E5%BD%A2%E5%BC%8F"><span class="toc-number">7.</span> <span class="toc-text">BFS基本形式</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#BFS%E7%9A%84%E5%9F%BA%E6%9C%AC%E5%BA%94%E7%94%A8%EF%BC%9A"><span class="toc-number">7.1.</span> <span class="toc-text">BFS的基本应用：</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E5%AD%97%E7%AC%A6%E4%B8%B2%E7%AE%97%E6%B3%95"><span class="toc-number">8.</span> <span class="toc-text">字符串算法</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#KMP"><span class="toc-number">8.1.</span> <span class="toc-text">KMP</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#EXkmp"><span class="toc-number">8.2.</span> <span class="toc-text">EXkmp</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#BM%E7%AE%97%E6%B3%95"><span class="toc-number">8.3.</span> <span class="toc-text">BM算法</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%9C%80%E9%95%BF%E5%9B%9E%E6%96%87%E5%AD%90%E4%B8%B2"><span class="toc-number">8.4.</span> <span class="toc-text">最长回文子串</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#Manacher%E7%AE%97%E6%B3%95"><span class="toc-number">8.4.1.</span> <span class="toc-text">Manacher算法</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#dp%E5%AE%9E%E7%8E%B0"><span class="toc-number">8.4.2.</span> <span class="toc-text">dp实现</span></a></li></ol></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E6%95%B0%E8%AE%BA"><span class="toc-number">9.</span> <span class="toc-text">数论</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%9F%83%E6%B0%8F%E7%AD%9B"><span class="toc-number">9.1.</span> <span class="toc-text">埃氏筛</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%AC%A7%E6%8B%89%E7%AD%9B"><span class="toc-number">9.2.</span> <span class="toc-text">欧拉筛</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84"><span class="toc-number">10.</span> <span class="toc-text">数据结构</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%8D%95%E8%B0%83%E6%A0%88"><span class="toc-number">10.1.</span> <span class="toc-text">单调栈</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%8D%95%E8%B0%83%E9%98%9F%E5%88%97"><span class="toc-number">10.2.</span> <span class="toc-text">单调队列</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%AD%97%E5%85%B8%E6%A0%91"><span class="toc-number">10.3.</span> <span class="toc-text">字典树</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%95%B0%E7%BB%84%E5%AD%98%E5%82%A8"><span class="toc-number">10.3.1.</span> <span class="toc-text">数组存储</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%BB%93%E6%9E%84%E4%BD%93%E5%86%99%E6%B3%95"><span class="toc-number">10.3.2.</span> <span class="toc-text">结构体写法</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%BB%9F%E8%AE%A1%E5%89%8D%E7%BC%80"><span class="toc-number">10.3.3.</span> <span class="toc-text">统计前缀</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E9%93%BE%E8%A1%A8"><span class="toc-number">10.4.</span> <span class="toc-text">链表</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%8D%95%E9%93%BE"><span class="toc-number">10.4.1.</span> <span class="toc-text">单链</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%8F%8C%E9%93%BE"><span class="toc-number">10.4.2.</span> <span class="toc-text">双链</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#Floyd-%E5%88%A4%E5%9C%88%E7%AE%97%E6%B3%95"><span class="toc-number">10.4.3.</span> <span class="toc-text">Floyd 判圈算法</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%A0%91"><span class="toc-number">10.5.</span> <span class="toc-text">树</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%BA%8C%E5%8F%89%E6%9F%A5%E6%89%BE%E6%A0%91"><span class="toc-number">10.5.1.</span> <span class="toc-text">二叉查找树</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#AVL%E6%A0%91%EF%BC%88%E5%B9%B3%E8%A1%A1%E4%BA%8C%E5%8F%89%E6%A0%91%EF%BC%89"><span class="toc-number">10.5.2.</span> <span class="toc-text">AVL树（平衡二叉树）</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%A0%91%E7%8A%B6%E6%95%B0%E7%BB%84"><span class="toc-number">10.6.</span> <span class="toc-text">树状数组</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%A0%91%E7%8A%B6%E6%95%B0%E7%BB%84%E7%9A%84%E5%9F%BA%E6%9C%AC%E5%AE%9E%E7%8E%B0"><span class="toc-number">10.6.1.</span> <span class="toc-text">树状数组的基本实现</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%B8%80%E7%BB%B4%E6%A0%91%E7%8A%B6%E6%95%B0%E7%BB%84%E5%9F%BA%E6%9C%AC%E5%BA%94%E7%94%A8"><span class="toc-number">10.6.2.</span> <span class="toc-text">一维树状数组基本应用</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E9%AB%98%E7%BB%B4%E6%A0%91%E7%8A%B6%E6%95%B0%E7%BB%84"><span class="toc-number">10.6.3.</span> <span class="toc-text">高维树状数组</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E7%BA%BF%E6%AE%B5%E6%A0%91"><span class="toc-number">10.7.</span> <span class="toc-text">线段树</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%8C%BA%E9%97%B4%E6%9F%A5%E8%AF%A2%E6%9C%80%E5%B0%8F%E5%80%BC"><span class="toc-number">10.7.1.</span> <span class="toc-text">区间查询最小值</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%8C%BA%E9%97%B4%E6%9F%A5%E8%AF%A2%E6%9C%80%E5%A4%A7%E5%AD%97%E6%AE%B5%E5%92%8C"><span class="toc-number">10.7.2.</span> <span class="toc-text">区间查询最大字段和</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%BA%BF%E6%AE%B5%E6%A0%91%E6%89%93%E6%A0%87%E8%AE%B0"><span class="toc-number">10.7.3.</span> <span class="toc-text">线段树打标记</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%9F%A5%E8%AF%A2%E5%8C%BA%E9%97%B4%E6%9C%80%E5%A4%A7%E5%80%BC"><span class="toc-number">10.7.3.1.</span> <span class="toc-text">查询区间最大值</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%9F%A5%E8%AF%A2%E5%8C%BA%E9%97%B4%E5%92%8C"><span class="toc-number">10.7.3.2.</span> <span class="toc-text">查询区间和</span></a></li></ol></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E4%BC%98%E5%85%88%E9%98%9F%E5%88%97%EF%BC%88%E5%A0%86%EF%BC%89"><span class="toc-number">10.8.</span> <span class="toc-text">优先队列（堆）</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%88%9D%E5%A7%8B%E5%8C%96"><span class="toc-number">10.8.1.</span> <span class="toc-text">初始化</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%8F%92%E5%85%A5"><span class="toc-number">10.8.2.</span> <span class="toc-text">插入</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%88%A0%E9%99%A4%E6%9C%80%E5%B0%8F%E5%85%83"><span class="toc-number">10.8.3.</span> <span class="toc-text">删除最小元</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%93%88%E6%9B%BC%E5%A4%AB%E6%A0%91"><span class="toc-number">10.9.</span> <span class="toc-text">哈曼夫树</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%B9%B6%E6%9F%A5%E9%9B%86"><span class="toc-number">10.10.</span> <span class="toc-text">并查集</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%9F%A5%E8%AF%A2"><span class="toc-number">10.10.1.</span> <span class="toc-text">查询</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%90%88%E5%B9%B6"><span class="toc-number">10.10.2.</span> <span class="toc-text">合并</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%85%B8%E4%BE%8B%E9%A2%98"><span class="toc-number">10.10.3.</span> <span class="toc-text">典例题</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%93%88%E5%B8%8C%E8%A1%A8-x2F-%E6%95%A3%E5%88%97%E8%A1%A8"><span class="toc-number">10.11.</span> <span class="toc-text">哈希表&#x2F;散列表</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%B8%80%E7%A7%8D%E5%AD%97%E7%AC%A6%E4%B8%B2hash%EF%BC%9A"><span class="toc-number">10.11.1.</span> <span class="toc-text">一种字符串hash：</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#STL-hash"><span class="toc-number">10.11.2.</span> <span class="toc-text">STL hash</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E8%A7%A3%E5%86%B3%E5%86%B2%E7%AA%81%E7%9A%84%E6%96%B9%E6%B3%95"><span class="toc-number">10.11.3.</span> <span class="toc-text">解决冲突的方法</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%88%86%E7%A6%BB%E9%93%BE%E6%8E%A5%E6%B3%95"><span class="toc-number">10.11.3.1.</span> <span class="toc-text">分离链接法</span></a></li></ol></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%9B%BE"><span class="toc-number">10.12.</span> <span class="toc-text">图</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E9%82%BB%E6%8E%A5%E7%9F%A9%E9%98%B5"><span class="toc-number">10.12.1.</span> <span class="toc-text">邻接矩阵</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E9%82%BB%E6%8E%A5%E8%A1%A8"><span class="toc-number">10.12.2.</span> <span class="toc-text">邻接表</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%9B%BE%E7%9A%84%E9%81%8D%E5%8E%86"><span class="toc-number">10.12.3.</span> <span class="toc-text">图的遍历</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#DFS%E9%81%8D%E5%8E%86"><span class="toc-number">10.12.3.1.</span> <span class="toc-text">DFS遍历</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#BFS%E9%81%8D%E5%8E%86"><span class="toc-number">10.12.3.2.</span> <span class="toc-text">BFS遍历</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#DAG%E4%B8%8E%E6%8B%93%E6%89%91%E6%8E%92%E5%BA%8F"><span class="toc-number">10.12.4.</span> <span class="toc-text">DAG与拓扑排序</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%9C%80%E7%9F%AD%E8%B7%AF%E9%97%AE%E9%A2%98"><span class="toc-number">10.12.5.</span> <span class="toc-text">最短路问题</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%97%A0%E6%9D%83%E6%9C%80%E7%9F%AD%E8%B7%AF%E9%97%AE%E9%A2%98"><span class="toc-number">10.12.5.1.</span> <span class="toc-text">无权最短路问题</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#Dijkstra%E7%AE%97%E6%B3%95"><span class="toc-number">10.12.5.2.</span> <span class="toc-text">Dijkstra算法</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#floyd%E7%AE%97%E6%B3%95"><span class="toc-number">10.12.5.3.</span> <span class="toc-text">floyd算法</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%9C%80%E5%B0%8F%E7%94%9F%E6%88%90%E6%A0%91"><span class="toc-number">10.12.6.</span> <span class="toc-text">最小生成树</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#Prim%E7%AE%97%E6%B3%95"><span class="toc-number">10.12.6.1.</span> <span class="toc-text">Prim算法</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#Kruskal%E7%AE%97%E6%B3%95"><span class="toc-number">10.12.6.2.</span> <span class="toc-text">Kruskal算法</span></a></li></ol></li></ol></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#java%E5%BF%AB%E8%AF%BB%E7%B1%BB"><span class="toc-number">11.</span> <span class="toc-text">java快读类</span></a></li></ol></div></div><div class="card-widget card-recent-post"><div class="item-headline"><i class="fas fa-history"></i><span>最新文章</span></div><div class="aside-list"><div class="aside-list-item no-cover"><div class="content"><a class="title" href="/2023/07/01/%E7%AE%97%E6%B3%95%E6%9D%BF%E5%AD%90%E6%B1%87%E6%80%BB/" title="算法板子">算法板子</a><time datetime="2023-07-01T09:18:26.496Z" title="发表于 2023-07-01 17:18:26">2023-07-01</time></div></div><div class="aside-list-item no-cover"><div class="content"><a class="title" href="/2023/07/01/Welcome%20to%20My%20blog/" title="Welcome to Cirno's Blog!!">Welcome to Cirno's Blog!!</a><time datetime="2023-07-01T09:18:26.494Z" title="发表于 2023-07-01 17:18:26">2023-07-01</time></div></div></div></div></div></div></main><footer id="footer"><div id="footer-wrap"><div class="copyright">&copy;2020 - 2023 By TheWiseCirno</div><div class="framework-info"><span>框架 </span><a target="_blank" rel="noopener" href="https://hexo.io">Hexo</a><span class="footer-separator">|</span><span>主题 </span><a target="_blank" rel="noopener" href="https://github.com/jerryc127/hexo-theme-butterfly">Butterfly</a></div></div></footer></div><div id="rightside"><div id="rightside-config-hide"><button id="readmode" type="button" title="阅读模式"><i class="fas fa-book-open"></i></button><button id="darkmode" type="button" title="浅色和深色模式转换"><i class="fas fa-adjust"></i></button><button id="hide-aside-btn" type="button" title="单栏和双栏切换"><i class="fas fa-arrows-alt-h"></i></button></div><div id="rightside-config-show"><button id="rightside_config" type="button" title="设置"><i class="fas fa-cog fa-spin"></i></button><button class="close" id="mobile-toc-button" type="button" title="目录"><i class="fas fa-list-ul"></i></button><button id="go-up" type="button" title="回到顶部"><span class="scroll-percent"></span><i class="fas fa-arrow-up"></i></button></div></div><div><script src="/js/utils.js"></script><script src="/js/main.js"></script><script src="https://cdn.jsdelivr.net/npm/@fancyapps/ui/dist/fancybox/fancybox.umd.min.js"></script><div class="js-pjax"><script>if (!window.MathJax) {
  window.MathJax = {
    tex: {
      inlineMath: [['$', '$'], ['\\(', '\\)']],
      tags: 'ams'
    },
    chtml: {
      scale: 1.1
    },
    options: {
      renderActions: {
        findScript: [10, doc => {
          for (const node of document.querySelectorAll('script[type^="math/tex"]')) {
            const display = !!node.type.match(/; *mode=display/)
            const math = new doc.options.MathItem(node.textContent, doc.inputJax[0], display)
            const text = document.createTextNode('')
            node.parentNode.replaceChild(text, node)
            math.start = {node: text, delim: '', n: 0}
            math.end = {node: text, delim: '', n: 0}
            doc.math.push(math)
          }
        }, '']
      }
    }
  }
  
  const script = document.createElement('script')
  script.src = 'https://cdn.jsdelivr.net/npm/mathjax/es5/tex-mml-chtml.min.js'
  script.id = 'MathJax-script'
  script.async = true
  document.head.appendChild(script)
} else {
  MathJax.startup.document.state(0)
  MathJax.texReset()
  MathJax.typesetPromise()
}</script></div><script id="canvas_nest" defer="defer" color="0,0,255" opacity="0.7" zIndex="-1" count="99" mobile="false" src="https://cdn.jsdelivr.net/npm/butterfly-extsrc/dist/canvas-nest.min.js"></script><script async data-pjax src="//busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script></div></body></html>